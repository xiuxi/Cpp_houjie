1
00:00:06,656 --> 00:00:11,008
好整个现在家标准库并不适用

2
00:00:11,264 --> 00:00:12,800
面向对象

3
00:00:13,056 --> 00:00:14,848
概念自己出来

4
00:00:15,104 --> 00:00:21,248
面向对象的概念是什么呢要有了克拉斯跟Class然后有继承

5
00:00:21,504 --> 00:00:27,648
关系最重要的是它还会有一些雪扮演重要角色的一些虚函数

6
00:00:27,904 --> 00:00:32,000
我是放弃这个标准库呢

7
00:00:32,256 --> 00:00:38,400
在比较早的版本的牧师2.9我说我们的主角吗我们主要要

8
00:00:38,656 --> 00:00:44,800
讲这个东西好源代码它里面没有太多的继承关系非常少

9
00:00:45,056 --> 00:00:51,200
所以很容易看得没有继承关系当然更就不会有去啊

10
00:00:51,456 --> 00:00:57,600
我们在看一些大型的面向对象库手Library

11
00:00:57,856 --> 00:01:04,000
很头痛的一点就是继承关系很复杂虚函数里头的

12
00:01:04,256 --> 00:01:10,400
网上逃往下跑很复杂但是看标准库里没有这

13
00:01:10,656 --> 00:01:13,216
这种困扰它主要是用

14
00:01:13,472 --> 00:01:19,616
Generic preventive概念做出来现在我们就来谈一谈kopi根据

15
00:01:19,872 --> 00:01:23,456
这两种概念的差别在哪里

16
00:01:26,784 --> 00:01:31,648
这边出现了一个是标准库里面的list链表

17
00:01:31,904 --> 00:01:32,672
设计

18
00:01:34,464 --> 00:01:38,560
这个链表里头当然是要放数据本身

19
00:01:40,096 --> 00:01:43,168
如果要对这些数据做排序的话

20
00:01:43,936 --> 00:01:47,776
根据Lp面向对象编程的概念

21
00:01:48,288 --> 00:01:50,080
数据放在那里

22
00:01:50,592 --> 00:01:52,896
操作这些数据的函数

23
00:01:53,152 --> 00:01:56,224
也放在这个类里头这个消息

24
00:01:57,504 --> 00:01:59,808
这种写法

25
00:02:00,576 --> 00:02:02,880
就表现出无比的概念

26
00:02:03,136 --> 00:02:08,256
数据和操作放在一起

27
00:02:12,352 --> 00:02:14,400
这月的还有1块

28
00:02:14,656 --> 00:02:15,936
小来讲解

29
00:02:16,192 --> 00:02:19,264
为什么这个数字放在里头

30
00:02:20,288 --> 00:02:25,408
我怎么想这句话呢因为在其他的容器里都能受都没有错

31
00:02:27,456 --> 00:02:28,992
好我们先看下一页

32
00:02:32,064 --> 00:02:38,208
刚刚上射弹道说区区旗是将data analysis methods操作对方

33
00:02:38,464 --> 00:02:40,256
方法关联在一起

34
00:02:41,536 --> 00:02:42,304
陈悦说

35
00:02:42,560 --> 00:02:46,912
知p是将data跟message分开来

36
00:02:47,424 --> 00:02:49,728
IPad合在一起现在是分开了

37
00:02:50,240 --> 00:02:51,776
最概念上基本的

38
00:02:52,800 --> 00:02:54,336
基调就不一样

39
00:02:55,360 --> 00:02:58,432
这个表现在标准库里头是怎么样

40
00:02:59,200 --> 00:03:00,224
好我们看这里

41
00:03:00,992 --> 00:03:02,784
这里有两个容器

42
00:03:03,040 --> 00:03:04,064
Extractor

43
00:03:04,576 --> 00:03:05,856
Expect

44
00:03:07,904 --> 00:03:11,232
他们里头都没有受这个

45
00:03:11,488 --> 00:03:12,512
排序的这个

46
00:03:13,024 --> 00:03:14,048
操作

47
00:03:15,584 --> 00:03:17,376
排序的这个操作呢

48
00:03:17,632 --> 00:03:21,216
被设计单独的设计在另外一块里头

49
00:03:21,472 --> 00:03:24,800
也就是你可以想象是一个全局的函数

50
00:03:25,568 --> 00:03:27,360
这里出现了两个版本

51
00:03:30,176 --> 00:03:32,736
版本11的是可以接受

52
00:03:33,760 --> 00:03:35,040
数据的头

53
00:03:35,296 --> 00:03:36,832
看数据的尾巴

54
00:03:37,088 --> 00:03:38,624
这样就可以定位出

55
00:03:39,136 --> 00:03:40,928
这个数据的范围

56
00:03:41,952 --> 00:03:46,304
版本2呢除了头跟尾之外还可以加上一个条件

57
00:03:48,096 --> 00:03:48,608
好

58
00:03:49,120 --> 00:03:51,424
这个是一个全局的

59
00:03:51,680 --> 00:03:52,448
函数

60
00:03:53,216 --> 00:03:55,520
这边的是一些数据

61
00:03:56,544 --> 00:03:57,056
所以

62
00:03:57,312 --> 00:03:58,592
GP说什么

63
00:03:58,848 --> 00:03:59,872
把数据

64
00:04:00,128 --> 00:04:02,688
焊操作分开来

65
00:04:04,736 --> 00:04:10,880
他们两个分开来要怎么样操作的部分要怎么样才能够去

66
00:04:11,136 --> 00:04:12,672
去得到数据本身呢

67
00:04:13,696 --> 00:04:16,256
这张图我想你不陌生

68
00:04:16,512 --> 00:04:18,303
在我们的一讲里面了

69
00:04:19,327 --> 00:04:20,863
出现了好几次这个图

70
00:04:21,631 --> 00:04:23,679
所以右手边这个soft

71
00:04:23,935 --> 00:04:26,239
就是属于算法的一部分

72
00:04:27,007 --> 00:04:31,871
左手边这些容器lastindex就是这里的天敌

73
00:04:32,127 --> 00:04:34,175
他们两者的关系

74
00:04:34,687 --> 00:04:36,991
要借助it better

75
00:04:38,015 --> 00:04:41,087
Iterate through我们看黄色的水分

76
00:04:41,599 --> 00:04:43,135
帮我们要去对

77
00:04:44,159 --> 00:04:46,463
这种容器做排序的时候

78
00:04:48,511 --> 00:04:49,535
我们是这么写的

79
00:04:50,303 --> 00:04:51,839
我们要调用

80
00:04:52,095 --> 00:04:53,119
Sort

81
00:04:53,375 --> 00:04:54,911
这个全局函数

82
00:04:55,935 --> 00:04:56,959
并且把

83
00:04:57,471 --> 00:05:00,287
还要操作的范围告诉他

84
00:05:00,543 --> 00:05:01,567
这个范围呢

85
00:05:02,591 --> 00:05:03,871
我这边的地址是

86
00:05:04,127 --> 00:05:04,895
选择

87
00:05:05,151 --> 00:05:06,431
某一个容器

88
00:05:06,687 --> 00:05:10,783
要用thinking and这就到头为两个指针

89
00:05:11,295 --> 00:05:15,135
其实不是指针应该讲迭代器的泛化的支撑

90
00:05:16,671 --> 00:05:22,815
这样把范围告诉右左边之后右手边这个手的就可以去开始去排序了

91
00:05:25,375 --> 00:05:25,887
所以

92
00:05:27,167 --> 00:05:28,959
这也要传达的是

93
00:05:29,983 --> 00:05:33,311
Gp4宝贝塔

94
00:05:33,823 --> 00:05:35,359
汉方式

95
00:05:35,615 --> 00:05:36,639
分开来

96
00:05:37,151 --> 00:05:38,431
这种基本概念

97
00:05:40,735 --> 00:05:41,759
上一页

98
00:05:42,783 --> 00:05:43,807
Boki

99
00:05:44,063 --> 00:05:47,135
上月的aop确适合在一起

100
00:05:49,183 --> 00:05:51,231
分开了有什么好处

101
00:05:51,487 --> 00:05:56,351
头皮引导我们做变作为那个编程的基本思想已经很多年了

102
00:05:57,119 --> 00:05:57,887
现在

103
00:05:58,143 --> 00:05:59,167
大家好不容易

104
00:05:59,423 --> 00:06:01,215
起到了这个机这个概念的

105
00:06:02,239 --> 00:06:03,519
现在却又

106
00:06:03,775 --> 00:06:07,871
出现一种新的编程的思考那是带来什么好处吗

107
00:06:12,479 --> 00:06:14,527
采用GP

108
00:06:15,039 --> 00:06:16,575
可以得到什么好处呢

109
00:06:17,343 --> 00:06:18,879
容器这边

110
00:06:19,135 --> 00:06:20,415
看算法

111
00:06:20,671 --> 00:06:24,511
这两个团队可以构词闭门造车

112
00:06:25,023 --> 00:06:26,303
你能造句

113
00:06:26,559 --> 00:06:32,703
在我们的系统是一个负面词啊哎呀你这个人就是闭门造车好像都不

114
00:06:32,959 --> 00:06:35,519
我开放但是在这里是好的

115
00:06:35,775 --> 00:06:37,567
因为两个团队故事

116
00:06:37,823 --> 00:06:43,967
分开来开发东西一直没有关联他们之间唯一的关联就是

117
00:06:45,759 --> 00:06:48,063
所以只要大家把这个接口

118
00:06:48,831 --> 00:06:49,599
定好

119
00:06:49,855 --> 00:06:53,695
就可以闭门造造车了就是在这里这是一个好事情

120
00:06:54,975 --> 00:06:56,511
举个例子

121
00:06:56,767 --> 00:06:58,303
我们看右手边

122
00:06:59,839 --> 00:07:01,375
刚刚我提的

123
00:07:01,631 --> 00:07:06,495
算法我拿了是说说太复杂了好不你头可能是

124
00:07:07,007 --> 00:07:11,103
几百行的这个源代码了不容易找到关键的地方

125
00:07:11,359 --> 00:07:13,151
我先来看这个最简单的

126
00:07:13,663 --> 00:07:14,687
Mina

127
00:07:16,735 --> 00:07:17,759
What's next

128
00:07:18,783 --> 00:07:20,319
密码是什么意思呢

129
00:07:20,575 --> 00:07:22,111
他接受a

130
00:07:22,367 --> 00:07:23,903
汉的两个参数

131
00:07:25,183 --> 00:07:26,719
找出谁比较小

132
00:07:28,767 --> 00:07:33,119
这个现在你所看到的就是标准库的源代码哦这1

133
00:07:33,375 --> 00:07:37,727
这算法最简单的这个算法它的源代码只有这么一点点而已

134
00:07:38,495 --> 00:07:40,287
他接受的一根比

135
00:07:40,543 --> 00:07:42,079
是什么类型呢

136
00:07:42,335 --> 00:07:44,639
通通都可以反正是个屁

137
00:07:45,407 --> 00:07:49,503
这个是模板的技巧啊这个后面我还会再谈一下这个模板

138
00:07:50,271 --> 00:07:53,087
好一个逼的stub类型必须相同

139
00:07:53,343 --> 00:07:55,135
至于他们怎么比大小呢

140
00:07:55,903 --> 00:08:00,511
只要用红色的这个小鱼的大小就是小于这个操作符

141
00:08:03,071 --> 00:08:03,839
这样

142
00:08:04,607 --> 00:08:05,631
闭门造车

143
00:08:05,887 --> 00:08:11,007
这个团队关起门来写出这样子至于B一根a怎么比大小

144
00:08:12,031 --> 00:08:12,543
我不管

145
00:08:13,567 --> 00:08:15,103
因为a跟B

146
00:08:15,359 --> 00:08:19,711
他是同一种东西他要怎么比大小由一根这种东西

147
00:08:22,271 --> 00:08:28,415
好比说你现在如果传进来给我吃一个整数和整数本来就可以比他小这个是语言上的

148
00:08:28,671 --> 00:08:32,767
本来就已经提供了如果传进来的是两颗石头

149
00:08:33,279 --> 00:08:34,047
Stone

150
00:08:34,815 --> 00:08:37,119
邓小平是个class

151
00:08:37,375 --> 00:08:39,423
两颗石头怎么比大小

152
00:08:39,935 --> 00:08:41,471
这不是我明明吧

153
00:08:41,983 --> 00:08:43,263
要去关系的事情

154
00:08:45,567 --> 00:08:48,639
石头怎么比大小由此投资决定

155
00:08:49,919 --> 00:08:50,687
也就是说

156
00:08:51,711 --> 00:08:54,015
石头这个Class要去

157
00:08:54,271 --> 00:08:57,599
定义apparat小鱼

158
00:08:58,879 --> 00:08:59,903
这个操作

159
00:09:01,695 --> 00:09:02,207
所以

160
00:09:03,231 --> 00:09:03,999
因为这个

161
00:09:04,511 --> 00:09:08,607
因为这样的一个一个一个一个思路所以呢

162
00:09:11,167 --> 00:09:12,447
在标准库里头

163
00:09:12,703 --> 00:09:18,079
操作符重载赞也非常扮演非常重要的角色

164
00:09:23,455 --> 00:09:23,967
好

165
00:09:24,223 --> 00:09:26,015
所以只有这一张图

166
00:09:26,271 --> 00:09:27,551
我们去了解到

167
00:09:28,831 --> 00:09:29,343
这个

168
00:09:29,599 --> 00:09:31,391
所谓能够闭门造车

169
00:09:32,159 --> 00:09:33,183
是怎么一回事

170
00:09:38,047 --> 00:09:38,815
好

171
00:09:39,583 --> 00:09:40,351
再看看

172
00:09:40,863 --> 00:09:45,983
再回到前面来刚刚在提到面向对象概念的时候

173
00:09:46,495 --> 00:09:47,519
我觉得这个例子

174
00:09:47,775 --> 00:09:49,567
我说在历史地理头

175
00:09:50,335 --> 00:09:51,871
自己有一个受

176
00:09:52,895 --> 00:09:55,455
为什么怕不能够像刚刚那个

177
00:09:56,223 --> 00:09:59,295
唱歌是什么下一页

178
00:10:00,575 --> 00:10:01,343
Sex

179
00:10:01,855 --> 00:10:07,743
为什么list就这么独特他不能够像这一种情况去用这个全局的数字呢

180
00:10:09,791 --> 00:10:11,071
有什么原因

181
00:10:12,607 --> 00:10:13,631
怎么样解释

182
00:10:15,167 --> 00:10:21,311
因为swap的设计是他的源代码在右手边能跟我说他是非常庞大的这里是最

183
00:10:21,567 --> 00:10:24,383
关键我现在要讲解了几个关键地方

184
00:10:26,431 --> 00:10:27,455
Shop

185
00:10:28,479 --> 00:10:31,295
从源代码这边看出来他调用了两个函数

186
00:10:32,575 --> 00:10:34,111
其中的第1个函数

187
00:10:34,623 --> 00:10:36,415
最关键的部分在

188
00:10:36,671 --> 00:10:39,743
也不是最关键是我现在要谈的部分的这里

189
00:10:41,023 --> 00:10:43,839
这里出现了一个红色这部分的动作

190
00:10:45,375 --> 00:10:51,263
First Class on last简first step 23为一个动作我这边写的时候是什么

191
00:10:52,031 --> 00:10:53,567
就是指针

192
00:10:53,823 --> 00:10:59,967
在这里不能但是我有时会长指针其实是指范化之间也就是也在一起啊这个

193
00:11:00,223 --> 00:11:01,759
这个迭代器在这边干什么

194
00:11:02,271 --> 00:11:03,039
家

195
00:11:03,295 --> 00:11:03,807
解

196
00:11:04,063 --> 00:11:04,831
幼雏

197
00:11:06,367 --> 00:11:07,647
这种迭代器

198
00:11:08,927 --> 00:11:15,071
能够符合这一种运算的迭代器一定是叫做random-access iterator

199
00:11:15,327 --> 00:11:18,143
随机数随机访问也大气

200
00:11:20,191 --> 00:11:21,471
比如说你想象

201
00:11:22,239 --> 00:11:23,007
一个数组

202
00:11:23,519 --> 00:11:24,799
数组里面

203
00:11:25,311 --> 00:11:27,103
指针它就是可以

204
00:11:27,871 --> 00:11:34,015
再加上那个票票三个位置建三个跳回三个位置他也可以

205
00:11:34,527 --> 00:11:36,319
加加减减还可以吃

206
00:11:36,831 --> 00:11:37,855
这种叫做

207
00:11:38,367 --> 00:11:40,415
Randomaccess Twitter

208
00:11:41,951 --> 00:11:45,023
由于source的设计上面

209
00:11:45,791 --> 00:11:50,911
这个团队在设计上所采用的数字做法呢他要对于这个

210
00:11:51,423 --> 00:11:53,727
迭代器有这样的操作

211
00:11:55,775 --> 00:12:00,383
所以传进来的这个迭代器必须是random

212
00:12:00,639 --> 00:12:02,175
Asus iterator

213
00:12:03,967 --> 00:12:05,503
而disc

214
00:12:06,783 --> 00:12:09,343
你可以想象各项历史的链表在

215
00:12:09,855 --> 00:12:13,951
内存里面他是一个一个的节点用指针串起来的

216
00:12:15,743 --> 00:12:17,791
它并不是一个连续空间

217
00:12:18,303 --> 00:12:20,095
所以它所具备的

218
00:12:20,351 --> 00:12:22,143
迭代器iterator

219
00:12:22,655 --> 00:12:24,447
是不能够跳来跳去

220
00:12:24,959 --> 00:12:31,103
他只能往前进一个在进下一个在井下一个或者往后退一个它不能够风

221
00:12:31,359 --> 00:12:34,431
供一个加5跳到第5的位置去

222
00:12:34,687 --> 00:12:37,759
跳到第10个位置距他不能这么做

223
00:12:39,807 --> 00:12:41,087
说结论是什么呢

224
00:12:43,903 --> 00:12:50,047
标准库的做法这个算法所用到的迭代器需要一定的条件

225
00:12:50,815 --> 00:12:52,863
而这个条件的是

226
00:12:53,631 --> 00:12:59,007
电表的所提供的迭代器所不能满足的说不能供应的这个条件

227
00:13:01,055 --> 00:13:01,823
所以

228
00:13:02,335 --> 00:13:02,847
他

229
00:13:03,103 --> 00:13:05,663
电表不能够像刚刚

230
00:13:05,919 --> 00:13:07,199
Vector

231
00:13:07,455 --> 00:13:08,735
Beckman

232
00:13:08,991 --> 00:13:11,295
能不能像他那样子说可以用

233
00:13:11,807 --> 00:13:13,855
全局的sort排序

234
00:13:16,159 --> 00:13:19,231
我记得在上一次第1讲一头

235
00:13:19,487 --> 00:13:25,631
未提到过因为我在那个地方的对于各种容器我播放100万个元素进去

236
00:13:26,143 --> 00:13:32,287
然后我会试着有一些容器我就排序他当时我就提过如果有

237
00:13:32,543 --> 00:13:38,175
由某些容器它自己带着瘦的话就必须用里头的瘦得去排

238
00:13:38,943 --> 00:13:41,503
如果他没有毒的话还用

239
00:13:42,271 --> 00:13:44,063
全局的所得去排

240
00:13:45,087 --> 00:13:47,391
现在所谈的这个话题

241
00:13:48,159 --> 00:13:51,487
也就是在第1讲的我们所讲的那个概念

242
00:13:51,999 --> 00:13:53,535
怎样的道理

243
00:13:59,167 --> 00:13:59,935
好

244
00:14:01,471 --> 00:14:02,495
在这个地方

245
00:14:02,751 --> 00:14:06,079
就让大家去认识到这个GP用模板

246
00:14:06,591 --> 00:14:12,735
去边去去设计整个要总库采用的是GP这个program

247
00:14:12,991 --> 00:14:16,319
概念跟过去office不太一样了

248
00:14:20,159 --> 00:14:22,463
那么这也要告诉大家的是

249
00:14:23,231 --> 00:14:25,535
其实所谓的算法

250
00:14:26,815 --> 00:14:31,679
最终所设计元素本身的操作无非就是比大小

251
00:14:33,215 --> 00:14:34,751
你要找一个东西

252
00:14:35,007 --> 00:14:36,287
Ftp等不等

253
00:14:37,567 --> 00:14:41,151
等不等如果他不小鱼也不大于它就是等于了

254
00:14:41,407 --> 00:14:43,199
这其实也是一样在比大小

255
00:14:43,711 --> 00:14:44,991
如果是排序呢

256
00:14:45,247 --> 00:14:51,391
排序有点把大大小小的位置对调一下我弄翻译一下这也都是在比大小

257
00:14:53,951 --> 00:14:55,487
比如我们看这个例子

258
00:14:58,047 --> 00:14:59,327
刚刚在上一页

259
00:15:00,863 --> 00:15:07,007
给我列出了两个最简单的算法一个我们刚才谈的生命力吗现在

260
00:15:07,519 --> 00:15:09,823
现在越南玩他没什么好了

261
00:15:11,871 --> 00:15:18,015
我把刚刚的这个商业的这个地方超过来就变成这个地方落maxmara

262
00:15:18,271 --> 00:15:18,783
版本

263
00:15:20,063 --> 00:15:21,343
我现在要谈的是

264
00:15:22,367 --> 00:15:23,391
第2个版本

265
00:15:24,671 --> 00:15:27,999
这个版本比第1个版本的差别在哪里呢

266
00:15:28,255 --> 00:15:30,303
他除了接受两个参数之外

267
00:15:30,559 --> 00:15:34,911
她还接受一个动作绿色的这个是有问题

268
00:15:35,423 --> 00:15:39,007
Cmp是什么意思就是看片就是比大小

269
00:15:40,031 --> 00:15:40,543
大小

270
00:15:41,311 --> 00:15:43,615
以我现在所给的例子

271
00:15:44,895 --> 00:15:46,431
M

272
00:15:48,735 --> 00:15:49,247
好

273
00:15:49,503 --> 00:15:50,271
我看这边

274
00:15:50,783 --> 00:15:54,367
这个是我写的一个城市要去使用这个Max吗

275
00:15:56,159 --> 00:16:01,023
我这maxmara传进去的第1个例子里头那我穿这两个字符串

276
00:16:01,535 --> 00:16:04,351
第2个例子我也是全相同的两个字符串

277
00:16:05,631 --> 00:16:07,423
在第1个例子里头

278
00:16:08,191 --> 00:16:12,799
字符串比大小一个是15欧元入一个是哈喽

279
00:16:13,055 --> 00:16:14,335
谁比较大呢

280
00:16:15,871 --> 00:16:22,015
我们没有去定义字符串的大小我们在这个地方现在没有去定义它

281
00:16:23,295 --> 00:16:25,343
所以他在比大小的时候

282
00:16:26,367 --> 00:16:28,927
现在这里说的是这个版本第1版本

283
00:16:29,951 --> 00:16:31,231
因为他是有两个参数吗

284
00:16:31,999 --> 00:16:33,535
这个参数

285
00:16:36,607 --> 00:16:39,423
所以他们在比大小用的是小于这个符号

286
00:16:41,727 --> 00:16:44,287
要去看看是哪一个字符串比较

287
00:16:44,543 --> 00:16:50,687
哪个是不是比较小那我们就如果要去看源代码的话我们就得去挖出

288
00:16:50,943 --> 00:16:55,807
字符串这个Class对于小于是怎么定义的

289
00:16:58,623 --> 00:17:04,767
字符串它本身这个全世界通用公认的一个概念是

290
00:17:05,023 --> 00:17:07,327
字符串本身有一种所谓的

291
00:17:07,583 --> 00:17:09,631
4点行驶的比大小

292
00:17:09,887 --> 00:17:10,655
你就是

293
00:17:12,191 --> 00:17:15,263
Abcc1种是比b大B种是大

294
00:17:15,775 --> 00:17:17,311
谁是最大的

295
00:17:17,823 --> 00:17:19,103
不管长度哦

296
00:17:19,871 --> 00:17:21,663
一个字符一个字符来比

297
00:17:22,687 --> 00:17:26,015
这是它默认的全世界公认的字符串

298
00:17:26,271 --> 00:17:27,295
李大小显示

299
00:17:27,807 --> 00:17:30,111
我们可以相信我们可以推想

300
00:17:30,623 --> 00:17:36,255
这个字符串标准库的这个子串一定也是采用这一种比它小的方式

301
00:17:37,279 --> 00:17:38,815
所以你看这个输出结果

302
00:17:40,095 --> 00:17:43,423
CEO of the Hollow来BC大了

303
00:17:44,191 --> 00:17:50,079
一个一个来的一个字符一比的日语就别去大所以这个输出只是由

304
00:17:51,359 --> 00:17:55,199
确实这个是一个这是我写出来的测试程序的执行结果

305
00:17:58,015 --> 00:18:00,831
但今天如果我不想

306
00:18:01,087 --> 00:18:02,367
按照那一种

307
00:18:03,135 --> 00:18:04,927
默认的方式去比大小

308
00:18:05,183 --> 00:18:07,231
默认方式就是字典形式的

309
00:18:08,255 --> 00:18:12,095
我想要说两个子不穿的比大小池长度

310
00:18:12,351 --> 00:18:16,959
芭比的话那么就应该是好多比较大

311
00:18:17,727 --> 00:18:19,007
你们好了比较长吗

312
00:18:19,519 --> 00:18:20,799
那我该怎么办呢

313
00:18:22,591 --> 00:18:23,359
这就是

314
00:18:23,871 --> 00:18:24,639
这个例子了

315
00:18:25,151 --> 00:18:26,431
我现在Max

316
00:18:26,687 --> 00:18:29,247
我还是要比z.o.o. 更好喽

317
00:18:30,271 --> 00:18:34,879
可是我要有一个我自己的比较方式我就需要写一个函数

318
00:18:35,135 --> 00:18:36,159
绿色的

319
00:18:37,951 --> 00:18:43,839
这个绿色的人被传进来将就是吃得下面这个绿色的是有问题看片

320
00:18:44,607 --> 00:18:49,471
所以这个坎贝尔就会作用在a的身上去比大小

321
00:18:52,031 --> 00:18:58,175
那这个用长度来比必须是这是我自己想要的我就没写出一个这样的一个函数出

322
00:18:58,431 --> 00:18:58,943
出来

323
00:18:59,455 --> 00:19:02,527
现在把它命名叫讯龙哥

324
00:19:03,295 --> 00:19:05,087
群龙的地方

325
00:19:05,599 --> 00:19:06,879
他怎么比大小呢

326
00:19:07,391 --> 00:19:08,927
一是这样要看

327
00:19:09,183 --> 00:19:11,487
两个字符串的size

328
00:19:11,999 --> 00:19:15,071
也就是长度用长度来比大小

329
00:19:17,119 --> 00:19:17,631
所以

330
00:19:18,399 --> 00:19:21,215
我就是要传达的意思是在这一夜里的

331
00:19:23,775 --> 00:19:24,799
这句话

332
00:19:25,055 --> 00:19:26,847
所有的算法

333
00:19:27,359 --> 00:19:29,407
最终的形式

334
00:19:29,919 --> 00:19:32,223
都是在比人数的大小

335
00:19:33,247 --> 00:19:36,063
比大小无非就是用小鱼

336
00:19:36,319 --> 00:19:38,879
或者是大于这个操作符来比

337
00:19:40,159 --> 00:19:44,767
大家看看这个元素本身有没有去重载这个小雨和大雨

338
00:19:49,631 --> 00:19:50,655
好
