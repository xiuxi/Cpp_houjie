1
00:00:05,632 --> 00:00:08,704
Cplusplus agno3 4.9

2
00:00:08,960 --> 00:00:11,264
标准分配器支持下

3
00:00:11,520 --> 00:00:13,056
请注意我的用语

4
00:00:13,824 --> 00:00:18,688
我这边说标准分配起来刚刚那一个已经是变质坏了

5
00:00:18,944 --> 00:00:25,088
Nana有它自己的名称我当我做到标准适配器我说的就是

6
00:00:25,600 --> 00:00:26,368
这个东西

7
00:00:27,136 --> 00:00:30,464
叫做allocator这个名称的这个分配器

8
00:00:32,512 --> 00:00:38,656
最刚刚那个很棒的那个到了4.9他变成体制外让他体制内的4.9自己

9
00:00:38,912 --> 00:00:40,192
这个标准的

10
00:00:41,216 --> 00:00:42,752
有什么特殊做法吗

11
00:00:43,264 --> 00:00:49,408
前面我们看过2.9的他没有特殊做法4.9那现在有代码在这里

12
00:00:50,432 --> 00:00:56,576
它的设计比较复杂一些的大的新版的有继承了谁要等等等了Class class

13
00:00:56,832 --> 00:00:57,856
现在比较多

14
00:00:58,368 --> 00:01:00,672
我们把这个调理都打抽出来

15
00:01:00,928 --> 00:01:04,256
这一个OK的继承了这个东西

16
00:01:04,512 --> 00:01:06,304
这一个东西

17
00:01:06,560 --> 00:01:11,168
Spotify这个东西就是这一个

18
00:01:12,704 --> 00:01:17,312
而这个东西就是上面这个东西

19
00:01:18,592 --> 00:01:21,664
颜色你看这个颜色就很容易找到

20
00:01:23,712 --> 00:01:29,856
所以如果这两个Class化成一个集成化成类的关系的话就用G1

21
00:01:30,112 --> 00:01:35,232
继承的这个特殊的三角符号来表现就是这一个图

22
00:01:37,536 --> 00:01:39,328
重点就在上面这里

23
00:01:40,096 --> 00:01:40,864
这两个函数

24
00:01:42,912 --> 00:01:44,704
这两个还是做什么事

25
00:01:45,984 --> 00:01:47,008
红色的这个

26
00:01:48,288 --> 00:01:49,824
他也是什么都没做

27
00:01:52,128 --> 00:01:55,968
是不是调用没落可是时间服务也是一样什么都没错

28
00:01:56,736 --> 00:01:58,784
所以这句话再看一次

29
00:01:59,808 --> 00:02:05,696
4.9版的标准的这个loake的叶子这样没有任何特殊设计

30
00:02:06,976 --> 00:02:08,512
其实我很纳闷

31
00:02:09,024 --> 00:02:15,168
为什么VC se16 2.9个弄4.9这些

32
00:02:15,424 --> 00:02:21,312
的标准分配器都是这样换汤不换药都不做特殊设计

33
00:02:22,592 --> 00:02:25,408
何不把很棒的设计就放在这里头呢

34
00:02:26,688 --> 00:02:28,224
我没有办法替他们回答

35
00:02:29,248 --> 00:02:32,832
你现在了解到了反正事实是如此

36
00:02:34,624 --> 00:02:39,744
所以如果你想要你知道现在的课程告诉你了

37
00:02:40,000 --> 00:02:41,536
怎么4.9版

38
00:02:42,048 --> 00:02:48,192
就是2.0以后了是一再加2.0之后的这些新版本其实有个很棒的比

39
00:02:48,448 --> 00:02:51,776
你这个标准分别是更好的那我们应该去用了

40
00:02:54,336 --> 00:02:55,104
怎么用

41
00:02:56,384 --> 00:02:57,664
刚刚上月才出现

42
00:02:58,176 --> 00:03:01,504
刚刚上上这里出现

43
00:03:03,296 --> 00:03:05,344
你要知道原来他的名字叫这个

44
00:03:06,880 --> 00:03:10,976
你要这样还被包在这个命名空间中你也会写出这样

45
00:03:13,280 --> 00:03:16,352
用他什么有什么好处呢我现在可以

46
00:03:16,608 --> 00:03:19,936
跳过一个小时之后的事情现在想直接告诉你

47
00:03:20,192 --> 00:03:21,728
他就去除了Gucci

48
00:03:21,984 --> 00:03:27,360
所以你100万个元素进去你可以省掉800万个字节

49
00:03:27,616 --> 00:03:28,896
不可谓不小

50
00:03:30,176 --> 00:03:33,504
因为一个元素在八个自己的故事

51
00:03:33,760 --> 00:03:34,784
100万个元素

52
00:03:35,040 --> 00:03:36,064
省掉了

53
00:03:36,320 --> 00:03:39,392
8000000 8000000的自己

54
00:03:41,696 --> 00:03:43,488
当然鼓励大家这么用

55
00:03:47,584 --> 00:03:48,864
好

56
00:03:50,400 --> 00:03:52,448
这个是一个使用的例子

57
00:03:52,960 --> 00:03:56,032
我刚刚是往前跑就是这一业绩好

58
00:03:57,056 --> 00:04:01,152
用法我看这个这边的我设计了一个测试程序

59
00:04:01,920 --> 00:04:03,200
测试程序

60
00:04:03,456 --> 00:04:05,760
右手边

61
00:04:06,272 --> 00:04:09,344
只要我的分片上你看到这个东西就

62
00:04:09,600 --> 00:04:10,880
从这里看去

63
00:04:11,648 --> 00:04:14,976
而且通常我测试程序会弄成潜规则

64
00:04:15,744 --> 00:04:20,351
而主体的部分会是白色的通常啊我尽量按照这种习惯

65
00:04:20,863 --> 00:04:22,399
所以我们现在看看

66
00:04:22,911 --> 00:04:24,191
我先试用一下

67
00:04:24,447 --> 00:04:25,727
这个东西

68
00:04:25,983 --> 00:04:29,055
因为开始也是战战兢兢

69
00:04:29,311 --> 00:04:34,943
说我我先看看不起对不对大小打印出来的大小之一

70
00:04:35,455 --> 00:04:41,599
这个大小其实对我们有太大的意义不过我这种是我的习惯了对于一个我未知的一个东西

71
00:04:41,855 --> 00:04:47,999
我想看看它的大小然后比对我我对源代码的理解看看这样有没有辐射

72
00:04:48,255 --> 00:04:51,071
这个一肯定表示

73
00:04:51,583 --> 00:04:55,935
肯定表示这个Class里头没有任何的悲惨

74
00:04:56,191 --> 00:05:01,055
说他离他的理论值是0

75
00:05:02,335 --> 00:05:05,663
而实现上了由于一些限制必须质疑

76
00:05:06,943 --> 00:05:08,223
好这是第一行

77
00:05:09,247 --> 00:05:15,391
确认得这么显示正确的之后第二行我就把它拿来作为

78
00:05:15,647 --> 00:05:17,439
容器的背后

79
00:05:17,695 --> 00:05:18,463
知识

80
00:05:19,231 --> 00:05:20,255
这个容器

81
00:05:20,511 --> 00:05:21,791
人数是整数

82
00:05:22,559 --> 00:05:24,095
背后的分配器是这一个

83
00:05:25,375 --> 00:05:27,679
这样也通过了OK好

84
00:05:27,935 --> 00:05:28,703
我就知道

85
00:05:29,215 --> 00:05:31,263
接下来我就开始用这个容器了

86
00:05:32,287 --> 00:05:35,615
顺利的跟这个体制外的东西街上鬼了

87
00:05:37,663 --> 00:05:39,199
接下来

88
00:05:39,455 --> 00:05:45,599
我这是一个用例为是用给你看看接下来那我就把这一个东西分配器

89
00:05:46,879 --> 00:05:53,023
我直接用这个分配器啊我就不猜到荣兴趣把这个分配器直接传给

90
00:05:53,279 --> 00:05:54,047
这个函数

91
00:05:56,351 --> 00:05:57,375
这个函数

92
00:05:57,631 --> 00:06:00,959
因为我在做测试的时候这个后头会出现

93
00:06:01,983 --> 00:06:05,055
Donews的Lucy有很多有五六个分配器

94
00:06:05,311 --> 00:06:05,823
我不想

95
00:06:06,079 --> 00:06:12,223
测测看所以我就写了一个测试程序我可以像这样子丢各种分配器

96
00:06:12,479 --> 00:06:12,991
进去

97
00:06:14,271 --> 00:06:15,807
究竟需要做什么呢

98
00:06:16,575 --> 00:06:19,391
这个东西丢进去就是这里

99
00:06:22,719 --> 00:06:24,511
后面就是要几个

100
00:06:25,023 --> 00:06:26,303
几个元素

101
00:06:26,559 --> 00:06:27,327
Please

102
00:06:28,351 --> 00:06:28,863
好

103
00:06:29,119 --> 00:06:31,935
这里头我怎么用这个东西丢进来的分配器

104
00:06:32,447 --> 00:06:34,751
我就allocate 3次

105
00:06:35,007 --> 00:06:36,799
我就拿了三块东西了

106
00:06:38,847 --> 00:06:44,991
我这是一个老方法也是一个粗浅的方法我就看看这33根

107
00:06:45,247 --> 00:06:47,295
指针安门的距离

108
00:06:49,343 --> 00:06:50,367
然后把它

109
00:06:50,879 --> 00:06:53,439
就你就你就是指针相减啊

110
00:06:53,951 --> 00:06:55,231
得到了结果他这边

111
00:06:58,047 --> 00:07:03,167
这边得到三根指证打印出来这边就是执行结果

112
00:07:06,239 --> 00:07:08,799
在这里有两次的执行结果

113
00:07:09,055 --> 00:07:12,127
在某一次执行结果里面是这样子

114
00:07:14,175 --> 00:07:15,455
这个距离多少

115
00:07:16,479 --> 00:07:18,271
从38到40

116
00:07:18,783 --> 00:07:23,391
相聚就是16进位所以38到400相差

117
00:07:23,647 --> 00:07:24,671
妈的自己

118
00:07:25,439 --> 00:07:28,767
40到48也是相差八个字节

119
00:07:30,047 --> 00:07:35,167
而我传进去的我到底要他每次分配多少呢准备一个大步

120
00:07:36,191 --> 00:07:37,471
这个东西存进去

121
00:07:39,519 --> 00:07:41,311
Apple传进去

122
00:07:42,335 --> 00:07:43,615
得到的结果

123
00:07:43,871 --> 00:07:45,151
一个大包是多少

124
00:07:45,407 --> 00:07:46,687
这18个字节

125
00:07:48,223 --> 00:07:52,319
现在我连续分配3块他们的距离是八个字节这可见

126
00:07:52,831 --> 00:07:56,927
每一块真的不带任何额外的开销了

127
00:07:58,463 --> 00:07:58,975
不大

128
00:08:02,303 --> 00:08:03,583
但是如果

129
00:08:04,351 --> 00:08:06,655
我用的是标准的分配器

130
00:08:10,751 --> 00:08:12,543
那么我在调用这个函数

131
00:08:13,823 --> 00:08:16,895
得到了三根指针相距是多少呢

132
00:08:17,151 --> 00:08:19,199
所以我也是要搭配哦

133
00:08:20,991 --> 00:08:26,111
相聚酒吧变8888 678差距之10h

134
00:08:27,135 --> 00:08:28,927
也就是16个自己

135
00:08:30,207 --> 00:08:31,743
这个不合我们的想象

136
00:08:31,999 --> 00:08:38,143
因为现在用的是标准分配器的标准分配器的底层就是用malloc去拿到那

137
00:08:38,399 --> 00:08:44,543
内存这里那每一块是8848个字节再加上上下QQ

138
00:08:44,799 --> 00:08:48,383
也是加起来八个字节所以加起来是16

139
00:08:49,663 --> 00:08:50,943
这就应该

140
00:08:51,199 --> 00:08:52,479
足以证明

141
00:08:52,991 --> 00:08:56,063
当你使用这一个好东西的时候

142
00:08:58,367 --> 00:08:59,647
还是不带手机

143
00:09:00,927 --> 00:09:01,695
太好了

144
00:09:02,207 --> 00:09:03,487
这就是我们要的

145
00:09:05,279 --> 00:09:09,375
所以我们就来看看这一个好东西的设计方式

146
00:09:10,399 --> 00:09:14,495
含着他的运作设计理念以及它的源代码

147
00:09:15,775 --> 00:09:18,079
不过我不会带你看4.9版的

148
00:09:19,615 --> 00:09:25,759
我会带你看他的前身2.98刚在就告诉你了完全一样2.9般比较容易

149
00:09:27,807 --> 00:09:30,111
这个家有一老如有一宝

150
00:09:30,367 --> 00:09:36,511
其实我们很幸运的我们经历过过去的一些

151
00:09:37,023 --> 00:09:41,887
技术眼镜头上有一些东西技术没有变

152
00:09:42,143 --> 00:09:47,007
但是可能设计上的由于Class的增加变得很难去阅读

153
00:09:47,775 --> 00:09:49,311
技术的本体哪边

154
00:09:49,823 --> 00:09:52,383
给我们有机会看到了早期的版本

155
00:09:52,895 --> 00:09:56,991
如果现在才突然进去使得新的版本就很难看

156
00:09:57,503 --> 00:09:58,783
很难阅读的总

157
00:10:05,183 --> 00:10:09,023
好我们再看看这是一次的执行结果

158
00:10:09,535 --> 00:10:12,351
后来在某一次执行结果出现这样

159
00:10:14,143 --> 00:10:15,167
出现这样子

160
00:10:15,423 --> 00:10:17,215
这个就不是吧的

161
00:10:17,727 --> 00:10:19,263
相序就不是吧

162
00:10:20,543 --> 00:10:23,615
他说上面这个程序吧这么就不是吧

163
00:10:24,383 --> 00:10:26,687
相聚不是吧

164
00:10:26,943 --> 00:10:29,503
并不能够表示什么意义

165
00:10:31,807 --> 00:10:33,343
银行这个分配是

166
00:10:33,599 --> 00:10:35,391
分三次再分配

167
00:10:35,647 --> 00:10:41,791
说不定他真的在当时的内存的情况之下就没有办法联系在一起

168
00:10:42,047 --> 00:10:42,559
所以这里

169
00:10:43,071 --> 00:10:45,375
并不能够推翻

170
00:10:46,143 --> 00:10:47,935
什么什么什么假设

171
00:10:48,447 --> 00:10:53,311
但是曾经执行过这个结果就让我们吃了定心丸

172
00:10:53,567 --> 00:10:55,615
确实他们没有5g

173
00:10:56,895 --> 00:10:58,687
这是两次的执行结果

174
00:11:00,735 --> 00:11:06,367
好我相信在你的电脑上执行我会付给你的整个程序你执行了一定是上面这个

175
00:11:07,647 --> 00:11:08,671
漂亮的数据

176
00:11:08,927 --> 00:11:13,279
下面这个是因为我又做了一些测试刚好中间这个插进来的

177
00:11:13,535 --> 00:11:14,303
状态

178
00:11:16,863 --> 00:11:18,911
所以这个就是

179
00:11:19,167 --> 00:11:25,311
我不知道这里那几个主流的编译器分配器的行为

180
00:11:25,567 --> 00:11:31,711
行为体制内的标准分配器的行为和体制外的一些其实很棒的

181
00:11:31,967 --> 00:11:35,551
分配器原来有这种东西这些事情了

182
00:11:35,807 --> 00:11:38,623
胶带给各位接下来我们就要来

183
00:11:38,879 --> 00:11:39,903
看看

184
00:11:40,159 --> 00:11:45,535
这个很棒的这个西北有高楼这个高楼他是怎么设计的
