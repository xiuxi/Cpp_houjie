1
00:02:14,656 --> 00:02:16,448
整个空间的中点

2
00:02:20,800 --> 00:02:22,592
现在的这个Master

3
00:02:22,848 --> 00:02:26,176
容量有80元素可以容纳八个元素

4
00:02:26,688 --> 00:02:28,736
不过现在只放了六个元素

5
00:02:28,992 --> 00:02:34,112
在这个start是从这里sina须指向这里12 and of storage就是

6
00:02:34,368 --> 00:02:38,464
储存量的尾巴能是指向这三个指针

7
00:02:40,512 --> 00:02:41,024
风

8
00:02:41,280 --> 00:02:41,792
我们

9
00:02:42,048 --> 00:02:45,888
放花和元素间距放第9个元素的时候怎么办呢

10
00:02:46,656 --> 00:02:48,704
这边写了两倍增长

11
00:02:49,472 --> 00:02:53,056
他要扩充和扩充的方式就是如果刚刚所说的

12
00:02:54,080 --> 00:02:58,432
这个容器会把内存去找到另外一个空间

13
00:02:58,944 --> 00:03:00,224
有时间的条件呢

14
00:03:00,480 --> 00:03:02,016
要两倍大

15
00:03:02,528 --> 00:03:08,672
两倍大那万一这个两倍大因此你可以想象这是一个非常刺出一多以后

16
00:03:08,928 --> 00:03:11,232
非常非常的巨大如果

17
00:03:11,744 --> 00:03:17,888
最终他找不到一个两倍大的空间的这个容器就是就是结束了生命结束失败了不能够在

18
00:03:18,144 --> 00:03:19,168
我在放元素进去了

19
00:03:20,192 --> 00:03:24,288
好这是一个两倍成长空间是不是所有的10座都

20
00:03:24,544 --> 00:03:30,432
两倍成长了你在B C底下pornsit以下可能是底下是不是都是两倍成长的

21
00:03:30,688 --> 00:03:31,200
次

22
00:03:31,712 --> 00:03:37,856
这是虽然标准规格书上没有这么说啊不过大家都是这么做的

23
00:03:38,112 --> 00:03:40,672
等下我们去看到相关的源代码

24
00:03:42,464 --> 00:03:48,608
好那先这个地方就是sata的源代码文件的部分

25
00:03:49,632 --> 00:03:51,168
Class template vector

26
00:03:52,448 --> 00:03:58,592
啊这是个62.9的版本所以前面我们已经学过了这个地方呢

27
00:03:58,848 --> 00:04:02,432
看到它默认的分配器是这个AC

28
00:04:04,992 --> 00:04:07,808
这里这张图所表现的三个指针

29
00:07:11,359 --> 00:07:12,127
好

30
00:07:12,639 --> 00:07:14,431
再看看plastic

31
00:07:14,687 --> 00:07:16,735
Capacity容量的意思

32
00:07:16,991 --> 00:07:17,503
就是这个

33
00:07:19,039 --> 00:07:21,087
他目前可以容纳多少元素

34
00:07:21,599 --> 00:07:26,207
这个怎么办呢and of storage begin

35
00:07:27,231 --> 00:07:29,279
这些都是非常简单的函数

36
00:07:30,047 --> 00:07:31,071
MTV

37
00:07:31,327 --> 00:07:34,399
Mpt只要看看begin_end这两根指针

38
00:07:34,655 --> 00:07:35,423
想不想等

39
00:07:35,935 --> 00:07:36,447
不知道

40
00:07:36,703 --> 00:07:38,495
是不是变成空了

41
00:07:38,751 --> 00:07:40,799
比如说现在这个地方

42
00:07:41,567 --> 00:07:42,591
八个元素

43
00:07:43,871 --> 00:07:49,759
可以从哪怕别人说你真的放个八个元素之后之后呢这个empty的

44
00:07:50,271 --> 00:07:53,855
并就相等了他就他目前是成功了

45
00:07:56,671 --> 00:07:57,951
号中括号

46
00:07:59,231 --> 00:08:01,791
我们会注意到一点啊

47
00:08:02,559 --> 00:08:04,351
所有的容器只要是

48
00:08:05,375 --> 00:08:11,519
带着连续空间的这种特性就会提供就必须提供中华好诗中

49
00:08:11,775 --> 00:08:17,919
拨号是一个数组的数组的一个很平常的一种操作方式所以这个

50
00:08:18,175 --> 00:08:19,967
Restaurant提供中括号

51
00:08:20,223 --> 00:08:21,759
我们后面会看到Jack

52
00:08:22,271 --> 00:08:28,415
就是说像开口的就那个有中国好因为他也是号称连续空间其实它不是

53
00:08:28,671 --> 00:08:30,463
是不过大号称是领取工具

54
00:08:31,487 --> 00:08:34,815
好这边就讲个这个地方

55
00:08:36,095 --> 00:08:37,887
我们是谁

56
00:08:38,143 --> 00:08:41,983
Master of他的行为模式能很容易掌握

57
00:08:42,751 --> 00:08:46,847
现在我想办法家来看看这里的两倍增长是怎么一回事

58
00:08:51,199 --> 00:08:54,271
他一定是发生在你放元素进去的时候

59
00:08:54,783 --> 00:08:59,135
放元素进去了我就找了一个最具代表性的函数这个不行

60
00:09:04,511 --> 00:09:06,815
不掉进去我这没有注解

61
00:09:07,327 --> 00:09:13,471
所以也许你可以把这个这个那个video苹果在这个地方的你可以好好的看这些

62
00:09:13,727 --> 00:09:15,263
艺术家也是非常有帮助的

63
00:09:17,055 --> 00:09:19,103
发生一开始就看看说

64
00:09:19,615 --> 00:09:23,199
还有没有空间可以放心的元素进去

65
00:09:23,967 --> 00:09:28,319
只要把finish and of storage就拿两个尺寸比一比这个地方

66
00:09:29,087 --> 00:09:30,879
就可以知道还有没有足够空间

67
00:09:32,415 --> 00:09:34,207
如果有那就放进去

68
00:09:34,975 --> 00:09:36,255
如果没有呢

69
00:09:36,511 --> 00:09:40,863
这边写了如果没有足够空间的话就进行下一个动作

70
00:09:41,119 --> 00:09:43,423
这一个动作叫做insert

71
00:09:43,679 --> 00:09:47,007
Axillary就是一个辅助性的函数

72
00:09:48,287 --> 00:09:53,407
这边进来我们看到你投了又做一次检查跟上面的检查是一样的

73
00:09:53,663 --> 00:09:57,247
看看有没有足够空间是不是有重复的动作了吗

74
00:09:58,015 --> 00:09:59,551
然后去下面有一个else

75
00:10:00,831 --> 00:10:04,415
这次这个动作这个衣服跟lz动作

76
00:10:04,927 --> 00:10:05,951
看上面这个

77
00:10:06,207 --> 00:10:10,303
是完全一样的一个检测动作那何必这样子做呢

78
00:10:10,559 --> 00:10:14,655
如果你一开始就只看到这两个你当然会有这样的疑惑

79
00:10:15,423 --> 00:10:18,239
那是因为这个r35

80
00:10:18,495 --> 00:10:20,543
这辅助函数除了呗

81
00:10:20,799 --> 00:10:26,943
Hitchhike调用此外它还会被其他的函数调用所以在那种情况之下的

82
00:10:27,967 --> 00:10:29,759
会需要这边做检查

83
00:10:31,551 --> 00:10:32,831
他在这个地址呢

84
00:10:33,087 --> 00:10:37,439
你说上面检查完之后下来下来又检查一次多做一次检查

85
00:10:38,207 --> 00:10:41,535
出现这种情况好那么既然

86
00:10:42,047 --> 00:10:43,839
我们现在要谈的是他的成长

87
00:10:44,095 --> 00:10:45,887
那就表示说已经没有

88
00:10:46,399 --> 00:10:47,423
备用空间了

89
00:10:47,679 --> 00:10:49,471
不用空军只是这一块

90
00:10:51,263 --> 00:10:55,615
没有备用空间的因此这边调用下来就会跑这里来

91
00:10:56,127 --> 00:10:57,151
这会很怕

92
00:10:57,407 --> 00:10:58,431
放得下一页

93
00:10:59,967 --> 00:11:03,039
邮费用空间

94
00:11:03,807 --> 00:11:07,647
好于是他要开始计算新的大小是多少

95
00:11:10,463 --> 00:11:14,047
他把原来的大小先记起来要hold site

96
00:11:15,839 --> 00:11:18,911
然后他判断oversize是不是0

97
00:11:19,423 --> 00:11:20,959
你开始会失灵了

98
00:11:21,471 --> 00:11:25,823
正better你创建一个这样的对象之后

99
00:11:26,079 --> 00:11:29,663
一开始他的空间如果你没有指定数值的话它是

100
00:11:29,919 --> 00:11:30,687
水设备

101
00:11:31,199 --> 00:11:32,735
是有可能的一开始指令

102
00:11:33,247 --> 00:11:35,295
如果一开始是0的话

103
00:11:36,319 --> 00:11:38,623
如果一开始是否会跑到这里来

104
00:11:39,903 --> 00:11:41,439
那就放一个进去

105
00:11:42,463 --> 00:11:47,327
必须有这种特殊的设计因为零的两倍还是020的无穷倍都是你

106
00:11:47,839 --> 00:11:49,887
所以必须要这样一个特殊的一个

107
00:11:50,399 --> 00:11:51,167
设计

108
00:11:52,447 --> 00:11:52,959
那么

109
00:11:53,215 --> 00:11:54,495
这个之后呢

110
00:11:55,263 --> 00:11:57,055
如果要再扩充的话就吧

111
00:11:58,079 --> 00:12:00,639
这个outsite原来的大小

112
00:12:00,895 --> 00:12:01,919
成语二

113
00:12:02,687 --> 00:12:04,991
这个地方就可以表现出

114
00:12:05,247 --> 00:12:08,575
我们前面讲的master总是两倍

115
00:12:08,831 --> 00:12:09,343
增长

116
00:12:11,135 --> 00:12:12,927
这边计算出来之后

117
00:12:13,951 --> 00:12:16,511
在分配内存的时候是用这个动作

118
00:12:17,535 --> 00:12:19,583
分配器满分配器的OK的

119
00:12:19,839 --> 00:12:22,143
他分配的是这个新计算出来的长度

120
00:12:22,399 --> 00:12:24,447
这样就两倍成长了

121
00:12:27,007 --> 00:12:29,823
两倍成长之后要做什么事情

122
00:12:30,591 --> 00:12:32,127
你要现在再回想一下

123
00:12:32,639 --> 00:12:34,175
假设现在是

124
00:12:34,431 --> 00:12:35,455
发给数

125
00:12:35,711 --> 00:12:39,295
放个第9个元素进去的时候他在做两倍成长

126
00:12:39,551 --> 00:12:42,111
于是到空间中找出一个16

127
00:12:42,367 --> 00:12:48,511
大小16个元素的这种大小本来是吧吗这边是16然后呢要把元

128
00:12:48,767 --> 00:12:51,327
原来的八个元素copy到新的地方去

129
00:12:52,351 --> 00:12:55,167
再把第9个元素放入新的元素进去

130
00:12:57,215 --> 00:12:59,007
就是这里的动作了

131
00:12:59,519 --> 00:13:03,871
分配好足够空间滞后接下来有一个Tracker

132
00:13:04,639 --> 00:13:05,663
好这个地方

133
00:13:05,919 --> 00:13:08,991
也比较复杂我把它拉这个地方来我们看看

134
00:13:09,759 --> 00:13:14,623
一个动作先把原来的内容拷贝到新的地方去

135
00:13:15,135 --> 00:13:17,695
把原来的拷贝到新的地方

136
00:13:18,463 --> 00:13:21,535
这里面调用的动作我们就不去讲它了

137
00:13:21,791 --> 00:13:23,071
因为这个这个

138
00:13:24,095 --> 00:13:26,143
就是一个函数包装了这个地方

139
00:13:27,423 --> 00:13:29,471
拷贝完原来内容是后

140
00:13:29,727 --> 00:13:30,495
接下来呢

141
00:13:32,031 --> 00:13:34,335
为新的元素是

142
00:13:34,591 --> 00:13:36,383
定初值

143
00:13:37,151 --> 00:13:40,479
找个想说八个拷贝过去的九个就是这个动作

144
00:13:41,759 --> 00:13:43,295
拷贝完事后呢

145
00:13:44,063 --> 00:13:46,367
炒绯闻之后按理说没有事情了

146
00:13:47,647 --> 00:13:52,511
把歌放到新的地方第9个放进去再来就应该没事情了

147
00:13:52,767 --> 00:13:53,535
因为

148
00:13:54,559 --> 00:13:56,863
因为刚刚事讲的是不是贝壳

149
00:13:57,119 --> 00:13:58,399
放在尾端

150
00:13:59,935 --> 00:14:06,079
但是你怎么看到这个源代码再把第9个元素放进去之后又做其他事情了

151
00:14:06,847 --> 00:14:07,615
做什么事

152
00:14:08,127 --> 00:14:10,431
他保安差点之后的

153
00:14:10,687 --> 00:14:12,479
内容也拷贝过来

154
00:14:14,271 --> 00:14:15,551
这是因为

155
00:14:16,063 --> 00:14:17,599
这一个函数

156
00:14:18,367 --> 00:14:20,415
Axillary辅助函数

157
00:14:20,671 --> 00:14:22,719
等下我提过了他不止10倍

158
00:14:22,975 --> 00:14:29,119
不需要用它还会被其他的函数调用所以在其他的函数

159
00:14:29,375 --> 00:14:31,167
有有个函数叫insert

160
00:14:31,935 --> 00:14:38,079
他在假释说是在八个元素它的第3个元素的定要安插一个新元素进去

161
00:14:38,335 --> 00:14:40,127
那也会造成要扩充

162
00:14:40,895 --> 00:14:45,759
这时候就会有安插点之前汉安差点之后

163
00:14:46,015 --> 00:14:47,551
这样的量贯东西

164
00:14:48,319 --> 00:14:53,951
最后面的一段安插点之后安差点后

165
00:14:54,463 --> 00:14:55,999
内容也要拷贝过来

166
00:14:57,791 --> 00:14:59,583
这就是这里所做的动作

167
00:15:02,399 --> 00:15:03,167
所以

168
00:15:03,935 --> 00:15:07,263
Vector非常容易使用概念非常的简单

169
00:15:07,775 --> 00:15:08,799
但是要注意点

170
00:15:09,055 --> 00:15:11,103
由于你刚看到的这个人在吗

171
00:15:11,871 --> 00:15:12,639
注意到

172
00:15:13,151 --> 00:15:15,711
每次只要成长

173
00:15:15,967 --> 00:15:19,551
就会有大量的人数的拷贝都做

174
00:15:20,063 --> 00:15:21,855
要知道元素的拷贝

175
00:15:22,111 --> 00:15:25,695
会引发copy control的拷贝构造函数

176
00:15:25,951 --> 00:15:31,583
而且拷贝过去之后原来的那一边要杀掉八个班到16个

177
00:15:31,839 --> 00:15:35,423
空间去那八个原来的八个也要一个一个删除

178
00:15:37,471 --> 00:15:38,495
析构函数

179
00:15:38,751 --> 00:15:42,079
所以每一次成长被大量调用

180
00:15:42,847 --> 00:15:45,663
大量制造出大量的看你们是有多少个

181
00:15:46,687 --> 00:15:48,991
大量调用元素的

182
00:15:49,247 --> 00:15:53,599
拷贝构造函数和析构函数这是一个大的成本

183
00:15:54,367 --> 00:15:56,927
我们在使用better手要注意这件事情

184
00:16:04,095 --> 00:16:07,167
接下来我们看看bastard iterator迭代器

185
00:16:08,447 --> 00:16:11,263
既然它是一个连续空间

186
00:16:12,799 --> 00:16:18,175
那么它的迭代器就可以不必设计的太复杂设计成一个Class不必

187
00:16:19,455 --> 00:16:21,247
我们前面在讲电表的时候

188
00:16:21,759 --> 00:16:27,903
链表的迭代器是要单独设计成一个Class双向跑来跑去往前往后跑

189
00:16:29,183 --> 00:16:33,279
那是因为链表的节点都是分离的

190
00:16:34,559 --> 00:16:35,839
但是backburner

191
00:16:36,095 --> 00:16:38,911
他既然是连续的按理说

192
00:16:39,423 --> 00:16:40,447
应该用

193
00:16:40,959 --> 00:16:43,263
指针就可以当成迭代器

194
00:16:43,775 --> 00:16:45,567
我看看是不是这样设计

195
00:16:46,591 --> 00:16:47,359
这个是

196
00:16:48,383 --> 00:16:51,199
No2点91班的实现方式

197
00:16:52,991 --> 00:16:54,783
在vector里头

198
00:16:56,575 --> 00:16:59,903
有一个定义有的差比分胶体呈灰色

199
00:17:00,927 --> 00:17:07,071
它的定义是这个样子穿着土卫六泰国废旧材不是什么人上瘾行为就差的就是的

200
00:17:08,351 --> 00:17:11,935
所以我这边的注解说他其实就是一个指针指向的

201
00:17:12,447 --> 00:17:14,239
就是元素类型

202
00:17:15,775 --> 00:17:16,543
这样就够了

203
00:17:18,591 --> 00:17:21,663
当你在使用vector的时候

204
00:17:23,711 --> 00:17:27,551
如果你要取得它的迭代器你是要这么写的

205
00:17:29,855 --> 00:17:31,647
然后声明一个变量

206
00:17:33,695 --> 00:17:37,023
可以可以一次就拿起出来了可以给他

207
00:17:37,279 --> 00:17:39,071
指向起点

208
00:17:39,839 --> 00:17:42,143
这个就是这个iterator的用法

209
00:17:44,703 --> 00:17:47,263
那我们要谈的是这个Twitter

210
00:17:50,079 --> 00:17:56,223
当算法origin算法要问问这个iterator你的那个虾

211
00:17:56,479 --> 00:17:57,759
相关类型的时候

212
00:17:59,039 --> 00:18:01,087
我要把这部分在整理一次

213
00:18:01,855 --> 00:18:04,415
怎么问呢就像这月子里所讲

214
00:18:04,927 --> 00:18:10,559
1235种相关类型这就是其中的三个的问法

215
00:18:11,839 --> 00:18:13,375
通过trace

216
00:18:13,887 --> 00:18:15,423
我们前面讲过的tricks

217
00:18:15,679 --> 00:18:21,823
Covid-19这个123不会是你一切程解应用程序你会这么写吗不会啊这个是

218
00:18:22,079 --> 00:18:23,871
Origin算法

219
00:18:24,127 --> 00:18:25,919
Party头可能会这么问

220
00:18:26,687 --> 00:18:27,455
他当然

221
00:18:27,711 --> 00:18:31,807
这是我所谓的问了这个信息出来写出来也就是答案了

222
00:18:33,855 --> 00:18:36,159
好我们看看相册这么问的话呢

223
00:18:37,183 --> 00:18:39,999
Hospital right这里

224
00:18:40,511 --> 00:18:42,047
也就是这个东西

225
00:18:42,303 --> 00:18:43,583
丢给trait

226
00:18:44,863 --> 00:18:48,191
Trace这张图各位还有印象前面我们看过了

227
00:18:48,703 --> 00:18:49,727
这个trace

228
00:18:50,495 --> 00:18:51,775
源代码在这里

229
00:18:54,079 --> 00:18:58,431
应该还有印象这个看起来有点庞大的东西前面出现过

230
00:18:59,967 --> 00:19:01,759
这个示范化的部分

231
00:19:02,271 --> 00:19:04,319
这个是天策划股份

232
00:19:04,831 --> 00:19:06,623
这是另外一个片的话

233
00:19:07,135 --> 00:19:11,231
他篇策划是要针对指针来进行平台化

234
00:19:11,999 --> 00:19:12,767
所以

235
00:19:13,023 --> 00:19:14,559
这一个指针

236
00:19:15,327 --> 00:19:21,471
这个iterator迭代器它是各自正当他丢给萃取机垂直的时候

237
00:19:21,983 --> 00:19:23,775
社会就是这一条

238
00:19:24,287 --> 00:19:25,567
这个东西

239
00:19:29,151 --> 00:19:34,783
因此萃取剂萃取技能就就会走入片刻画这个版本

240
00:19:36,575 --> 00:19:38,367
那么对于一个指针

241
00:19:39,647 --> 00:19:43,487
这五种类型我们之前已经分析过了

242
00:19:44,255 --> 00:19:46,303
他的分类category

243
00:19:46,559 --> 00:19:48,351
Trend analysis

244
00:19:48,607 --> 00:19:49,631
绿色兴奋

245
00:19:51,167 --> 00:19:52,959
他的v6台不是什么呢

246
00:19:53,727 --> 00:19:56,543
指针指向体所以没有太多就是的

247
00:19:58,335 --> 00:20:00,127
他的dif type是什么呢

248
00:20:00,383 --> 00:20:01,407
前面也提过了

249
00:20:01,663 --> 00:20:02,175
大家

250
00:20:02,943 --> 00:20:06,015
都用这一个来作为一个freestyle

251
00:20:09,343 --> 00:20:11,135
所以如果是借由这张图

252
00:20:11,391 --> 00:20:12,927
也等于是把前面的

253
00:20:13,695 --> 00:20:14,463
Trace

254
00:20:15,487 --> 00:20:16,511
概念

255
00:20:17,023 --> 00:20:17,791
再次

256
00:20:18,047 --> 00:20:21,119
这次针对的是指针而是这么早的

257
00:20:31,871 --> 00:20:33,407
这样的设计非常好

258
00:20:34,175 --> 00:20:35,199
容易看

259
00:20:35,455 --> 00:20:36,735
直观明了

260
00:20:37,247 --> 00:20:38,015
没有

261
00:20:38,271 --> 00:20:39,551
澳门去去东西

262
00:20:41,343 --> 00:20:43,135
在4.9版的

263
00:20:43,391 --> 00:20:44,671
变成这个样子

264
00:20:44,927 --> 00:20:46,975
前面看到的都是2.9啊

265
00:20:47,231 --> 00:20:49,023
很容易看到一个版本

266
00:20:49,791 --> 00:20:51,839
4.9版本

267
00:20:54,143 --> 00:20:55,679
原先只有一个class

268
00:20:56,447 --> 00:20:59,007
现在却变成了他有一个父类

269
00:20:59,775 --> 00:21:03,871
富勒内涵的一个是一个小心可能开心的泪

270
00:21:04,383 --> 00:21:06,431
这个又继承了allocate

271
00:21:06,687 --> 00:21:08,223
哇这么复杂

272
00:21:09,503 --> 00:21:10,527
其实最终

273
00:21:10,783 --> 00:21:12,063
功能是一样的

274
00:21:13,599 --> 00:21:15,647
我个人是很不欣赏

275
00:21:16,159 --> 00:21:22,304
新的版本变成是这个样子所有的容器都变成这样本来他都是单一的类

276
00:21:22,560 --> 00:21:25,120
那现在去都变成了怎么复杂

277
00:21:26,656 --> 00:21:27,424
走吗

278
00:21:27,680 --> 00:21:29,984
看起来会很辛苦

279
00:21:31,264 --> 00:21:31,776
好

280
00:21:32,032 --> 00:21:33,312
那我们来检讨一下

281
00:21:33,568 --> 00:21:38,688
在这一种版本之下它的大小是多少这就不是那么能够一目了然了

282
00:21:39,200 --> 00:21:40,992
我们再看一次前面2.9吧

283
00:21:43,296 --> 00:21:45,600
2点求版

284
00:21:46,880 --> 00:21:48,928
我要做投影片我应该往前看

285
00:21:53,024 --> 00:21:53,536
好

286
00:21:55,840 --> 00:21:57,120
这个是2.9吧

287
00:21:57,632 --> 00:22:03,520
你要看它的大小是多少就是把看看的背塔在哪里这里三个34 12

288
00:22:04,800 --> 00:22:05,824
那新版呢

289
00:22:08,128 --> 00:22:08,640
这边

290
00:22:09,152 --> 00:22:11,968
你要看它的大小也是要找出他的背他

291
00:22:12,480 --> 00:22:15,296
没有这个他没有对他那是他有父类

292
00:22:15,808 --> 00:22:17,856
最富丽的大小就是它的大小

293
00:22:18,112 --> 00:22:19,392
那我们来看一下富勒好

294
00:22:19,904 --> 00:22:21,952
父类的非法只有一个

295
00:22:24,256 --> 00:22:26,048
他是什么类型呢

296
00:22:26,304 --> 00:22:27,840
他是右边这种危险

297
00:22:29,376 --> 00:22:31,424
这个类型多大呢

298
00:22:32,448 --> 00:22:33,728
这里有他的Beta

299
00:22:34,496 --> 00:22:35,264
三个指针

300
00:22:36,288 --> 00:22:38,080
所以它的大小是12

301
00:22:41,408 --> 00:22:44,224
它的大小就是它的大小

302
00:22:44,992 --> 00:22:51,136
而它的大小就是这个数据大小这个数据多大要看他因为这个数据是这一种的

303
00:22:52,928 --> 00:22:53,952
这个多大呢

304
00:22:54,464 --> 00:22:55,232
三个指针

305
00:22:56,768 --> 00:22:57,536
32

306
00:22:58,304 --> 00:23:00,864
不是这一个还有付费吗

307
00:23:01,120 --> 00:23:01,632
Love

308
00:23:01,888 --> 00:23:03,936
富力的大小也要加进来

309
00:23:04,192 --> 00:23:05,216
我们在计算

310
00:23:05,472 --> 00:23:06,752
为什么大小的时候

311
00:23:07,264 --> 00:23:08,288
这是我们的

312
00:23:09,056 --> 00:23:12,640
基本认识吗附类似此类的一部分

313
00:23:13,920 --> 00:23:19,552
附近有没有大小呢傅雷是一个OK的没有大小他没有被打在里头

314
00:23:20,832 --> 00:23:22,880
所以整个字

315
00:23:23,136 --> 00:23:24,928
这个地方我们在探讨的better

316
00:23:25,184 --> 00:23:26,720
Size

317
00:23:29,536 --> 00:23:33,120
在这里呀我这边特别用红色的public

318
00:23:33,376 --> 00:23:37,472
写出来一般来讲我们这样话没有特别写的话

319
00:23:37,728 --> 00:23:38,496
就是指

320
00:23:39,264 --> 00:23:40,544
Public继承

321
00:23:41,568 --> 00:23:46,176
现在家里面除了public继承了还有一种继承下来的基础

322
00:23:46,432 --> 00:23:47,456
私有的

323
00:23:47,712 --> 00:23:50,784
还有一种叫做protected受保护的

324
00:23:54,880 --> 00:23:57,952
这个地方为什么用public继承

325
00:23:58,464 --> 00:23:59,744
实在是没有道理

326
00:24:01,536 --> 00:24:03,072
因为public继承

327
00:24:04,352 --> 00:24:06,400
面向对象的概念里面

328
00:24:06,656 --> 00:24:08,448
非常非常强调一件事情

329
00:24:09,216 --> 00:24:11,264
Public继承就代表

330
00:24:11,520 --> 00:24:14,592
1子饿的关系是一种

331
00:24:14,848 --> 00:24:15,616
关系

332
00:24:16,896 --> 00:24:18,432
现在这里的继承了

333
00:24:18,688 --> 00:24:24,832
其实只是要为了让这一个master implementation这个类能够一

334
00:24:25,088 --> 00:24:26,112
不用到

335
00:24:26,368 --> 00:24:28,928
上面这个分配器的功能

336
00:24:29,696 --> 00:24:32,000
所以应该用flyknit技术

337
00:24:32,256 --> 00:24:38,400
你总不能说是一种是一种的种种不能这样讲

338
00:24:40,704 --> 00:24:41,984
所以在这个地方呢

339
00:24:42,752 --> 00:24:43,776
我认为这个

340
00:24:44,032 --> 00:24:49,920
理想虽然功能上次打到而且这个根本就隐藏在非常非常深的幕后

341
00:24:50,432 --> 00:24:52,992
但是我认为这个团队在设计的时候啊

342
00:24:53,504 --> 00:24:56,832
这里是不理想的应该是private才好

343
00:25:00,160 --> 00:25:01,952
好想看

344
00:25:02,464 --> 00:25:03,744
所以刚刚看到了

345
00:25:04,000 --> 00:25:09,632
Vector载旧版一个Class的新版变成好多迪卡

346
00:25:10,400 --> 00:25:11,936
那么一只weather呢

347
00:25:12,192 --> 00:25:15,776
Vector的iterator迭代器的有什么变化吗

348
00:25:16,800 --> 00:25:20,128
出现了更令人讨厌的情况来看

349
00:25:20,896 --> 00:25:22,944
这个是4.9版的段子

350
00:25:24,736 --> 00:25:26,784
他的interpreter在这里

351
00:25:29,088 --> 00:25:30,112
这是什么

352
00:25:31,136 --> 00:25:35,232
他是某一种Class这个class

353
00:25:35,488 --> 00:25:40,864
这边界非常的复杂所以你也能让我现在推出了你可以听歌曲在什么地方

354
00:25:41,632 --> 00:25:42,656
好好地看一看

355
00:25:42,912 --> 00:25:43,936
再继续下去

356
00:25:44,448 --> 00:25:47,264
他说我不能把时间停下来所以我要继续讲下去

357
00:25:49,312 --> 00:25:55,456
这个master的iterator是这一东西紫色的这个东西

358
00:25:55,712 --> 00:25:57,248
这个东西的定义在下面

359
00:26:00,320 --> 00:26:03,392
这个下面这里的有一个变量

360
00:26:03,904 --> 00:26:05,440
小m Korean

361
00:26:05,696 --> 00:26:09,024
所以我就把它画画成标准的类的图是这样子

362
00:26:10,304 --> 00:26:14,656
打开微看一下类的名称为我现在在谈论事

363
00:26:14,912 --> 00:26:16,448
Iterator

364
00:26:16,704 --> 00:26:19,264
所以我就写出来我要描述这一个类

365
00:26:20,288 --> 00:26:22,336
它有一个变量叫Korean

366
00:26:23,616 --> 00:26:25,408
我们来看看是什么类型

367
00:26:26,432 --> 00:26:27,456
客人在这里

368
00:26:28,224 --> 00:26:31,040
他是什么类型的紫色的这个已成为it

369
00:26:31,552 --> 00:26:34,624
这个怎么来的谁这个线条往上看

370
00:26:34,880 --> 00:26:36,160
是从这里来的

371
00:26:37,952 --> 00:26:41,280
这一个又是怎么来的在循着线条往上看

372
00:26:41,792 --> 00:26:42,560
是这一个

373
00:26:43,584 --> 00:26:44,352
Twitter

374
00:26:44,608 --> 00:26:46,912
同时有什么来的这个上面这个

375
00:26:47,168 --> 00:26:53,312
然后上面这个又是什么在我上辈子经过这样层层推倒你现在当然因为时间这么短呢

376
00:26:53,568 --> 00:26:54,848
已经是

377
00:26:55,104 --> 00:27:01,248
一头雾水了但是你必须挺格下来仔细看看我画的这些线条你往上推

378
00:27:01,504 --> 00:27:07,648
就能够推出这个绿色的客人到底是什么类型的网上推往上推

379
00:27:07,904 --> 00:27:10,208
Space

380
00:27:10,976 --> 00:27:11,488
这个

381
00:27:12,256 --> 00:27:14,816
我这把得到的结果抄下来这个东西

382
00:27:16,864 --> 00:27:19,680
S10是什么

383
00:27:20,960 --> 00:27:24,800
在网上看这里飞steam特到底是什么呢

384
00:27:25,056 --> 00:27:26,592
是这个东西

385
00:27:27,104 --> 00:27:29,152
从这边再往这边推

386
00:27:29,408 --> 00:27:32,736
不会知道原来我这边画了一条线在这里

387
00:27:33,504 --> 00:27:39,648
This Point是什么就是这个东西里头的罪

388
00:27:43,488 --> 00:27:49,632
小伙说这个新版把职业事情搞得非常的复杂他可能觉得复杂是一种美我们觉得

389
00:27:49,888 --> 00:27:51,680
好

390
00:27:51,936 --> 00:27:55,264
终于那得到了这样的结果所以再吵一次

391
00:27:55,520 --> 00:27:56,800
这个point

392
00:27:57,056 --> 00:27:58,336
他是什么东西

393
00:27:59,104 --> 00:27:59,872
继续推

394
00:28:00,128 --> 00:28:03,456
你慢慢的苹果在这边慢慢地看这个源代码

395
00:28:03,712 --> 00:28:04,480
最后

396
00:28:04,736 --> 00:28:06,272
我画出来的结果是

397
00:28:06,784 --> 00:28:08,320
这一张图

398
00:28:08,576 --> 00:28:10,112
变成这一张图

399
00:28:10,624 --> 00:28:13,184
终于知道了绿色的这个科润

400
00:28:13,440 --> 00:28:14,720
他其实是什么

401
00:28:14,976 --> 00:28:16,512
就是point2d

402
00:28:17,792 --> 00:28:23,936
造了这么老大一圈不就是前面那个跟2.9版旧版的那个东西吗

403
00:28:27,008 --> 00:28:28,800
非常难看

404
00:28:31,616 --> 00:28:32,384
所以

405
00:28:33,664 --> 00:28:34,944
我们继续往下

406
00:28:35,200 --> 00:28:37,248
把这张图在抓出来看一次了

407
00:28:38,016 --> 00:28:40,064
这个是4.9版的工程

408
00:28:40,320 --> 00:28:43,648
刚刚已经分析过了层层的推倒了

409
00:28:43,904 --> 00:28:47,744
观察已经知道了这一个iterator

410
00:28:48,000 --> 00:28:49,792
就是这种东西

411
00:28:52,608 --> 00:28:53,120
于是

412
00:28:54,400 --> 00:28:56,448
在这个新版里头

413
00:28:57,216 --> 00:29:03,360
如果算法包括reason又问这种问题123这一类的问题的话

414
00:29:04,384 --> 00:29:08,480
要把iterator迭代器又给traits这时候

415
00:29:09,248 --> 00:29:10,528
这个iterator

416
00:29:11,040 --> 00:29:15,392
他本身是个Object对象他不再是个单纯的指针了

417
00:29:16,416 --> 00:29:17,952
那么走了就是这一条路

418
00:29:18,976 --> 00:29:20,000
下面这一组

419
00:29:21,536 --> 00:29:22,560
而不是上面的

420
00:29:24,608 --> 00:29:26,912
他走到下面这组来

421
00:29:29,472 --> 00:29:30,752
这些东西

422
00:29:31,264 --> 00:29:33,056
Iterator本身

423
00:29:33,568 --> 00:29:34,336
诞生

424
00:29:35,872 --> 00:29:38,944
里头有定义这些

425
00:29:39,456 --> 00:29:40,480
一个重要的

426
00:29:40,992 --> 00:29:42,016
相关类型

427
00:29:44,064 --> 00:29:45,088
所以

428
00:29:47,136 --> 00:29:48,416
犯人62年

429
00:29:48,672 --> 00:29:54,816
9板的时候非常单纯大的4.9版的曲曲折折让了这么一大堆绿

430
00:29:55,072 --> 00:29:59,168
六最后其实跟2.9版的最终实现是一样的

431
00:30:00,192 --> 00:30:01,728
我被他下了结论就是

432
00:30:02,240 --> 00:30:04,544
乱78糟舍近求远

433
00:30:04,800 --> 00:30:06,080
何必如此呢

434
00:30:07,616 --> 00:30:09,152
也许这个

435
00:30:09,408 --> 00:30:12,736
我们我们不理解这个团队有没有什么

436
00:30:13,760 --> 00:30:19,904
非常高远的目标好像把它被设计成这样也许他有为对未来的一个或从性

437
00:30:20,160 --> 00:30:26,048
我们说话还是要保留一些吗这么严厉的批评他但是市场目前

438
00:30:26,304 --> 00:30:31,936
目前我的认知啊我认为这样实在是怎么乱78糟的进球员

439
00:30:33,984 --> 00:30:35,008
不过

440
00:30:35,264 --> 00:30:41,408
毕竟2.9经过了3.0 3.5 4.0 4.5到4.9 4.9时开始新的版本

441
00:30:41,664 --> 00:30:47,808
我相信到了5.0以后6.0 7点后会是这个做法已经久就被人心这样了

442
00:30:48,064 --> 00:30:50,112
所以也许在未来

443
00:30:50,368 --> 00:30:54,464
你还有机会还有需要去看看这些源代码的话你要

444
00:30:54,720 --> 00:30:56,768
有了这个基础就看得懂了

445
00:30:58,048 --> 00:30:58,816
这个词

446
00:30:59,584 --> 00:31:00,608
Becker的部分
