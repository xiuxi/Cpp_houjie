1
00:00:06,656 --> 00:00:08,704
前面我曾经

2
00:00:09,472 --> 00:00:10,752
那你提出一个问题

3
00:00:11,264 --> 00:00:17,408
访美归还是放掉所有的内存块你是客户你是客户你所有

4
00:00:17,664 --> 00:00:22,272
所有的malloc还给他了那么sdhc统会呈现什么面貌呢

5
00:00:23,552 --> 00:00:27,392
我刚才已经告诉过你他会回复到一个初始状态

6
00:00:28,160 --> 00:00:29,440
就是这种

7
00:00:33,280 --> 00:00:34,048
一个group

8
00:00:34,560 --> 00:00:37,632
这这个就出事了刚刚已经提过了

9
00:00:38,144 --> 00:00:40,704
随着张图给大家

10
00:00:40,960 --> 00:00:42,496
形象上的看一看

11
00:00:43,776 --> 00:00:45,568
这8块是不会合并的

12
00:00:49,920 --> 00:00:50,688
猫

13
00:00:51,456 --> 00:00:52,992
整个malloc

14
00:00:53,248 --> 00:00:55,040
所有的细节我们

15
00:00:56,832 --> 00:01:01,952
我不敢说所有的细节应该是整个在太繁复了把那个90 95

16
00:01:02,464 --> 00:01:06,816
最重要的部分都看过了没落可能整个技术

17
00:01:07,328 --> 00:01:08,096
结束

18
00:01:09,888 --> 00:01:11,936
知道了这些细节以后

19
00:01:12,192 --> 00:01:13,728
首先我会去想

20
00:01:13,984 --> 00:01:14,496
那

21
00:01:15,776 --> 00:01:21,920
这整段在debug模式底下所有的区块其实都是被一根指针链子

22
00:01:22,176 --> 00:01:23,200
我们前面介绍过

23
00:01:23,712 --> 00:01:24,992
所有的区块

24
00:01:25,504 --> 00:01:26,272
即使

25
00:01:26,528 --> 00:01:32,672
Sph2他掌握着他给了我他他仍然有指针链子他这样调

26
00:01:32,928 --> 00:01:34,464
老司机才能够追踪

27
00:01:36,768 --> 00:01:38,048
我应用端

28
00:01:38,560 --> 00:01:40,352
我不小心知道了这个秘密

29
00:01:41,888 --> 00:01:44,960
我可不可以也相继发可能要去

30
00:01:45,472 --> 00:01:46,752
追踪一变的

31
00:01:47,264 --> 00:01:48,032
当然可以

32
00:01:48,288 --> 00:01:50,080
我已经试过了

33
00:01:51,616 --> 00:01:52,640
VC

34
00:01:53,408 --> 00:01:56,736
不敢说所有的版本是在vc6

35
00:01:56,992 --> 00:01:59,552
就已经提供了这种函数

36
00:02:00,832 --> 00:02:04,160
这次他把它叫做什么叫做State

37
00:02:04,416 --> 00:02:06,464
Reporting functions

38
00:02:07,232 --> 00:02:13,376
这是在中继器的状态的一些一些一些登记用的整理

39
00:02:13,632 --> 00:02:16,704
数据给你看了一些函数

40
00:02:17,216 --> 00:02:19,008
Vc6有提供

41
00:02:19,264 --> 00:02:23,360
你手上新版本就查一查有没有这些函数

42
00:02:23,872 --> 00:02:30,016
这些函数也都是有源代码的他他就是crt的一部分我前面提过了

43
00:02:30,272 --> 00:02:35,904
PC的标准库里头整个crt的源代码是给你的

44
00:02:37,184 --> 00:02:38,464
我已经看过它的源代码

45
00:02:38,976 --> 00:02:40,512
这里头70就是

46
00:02:40,768 --> 00:02:43,840
只追踪表

47
00:02:44,864 --> 00:02:46,144
在调试模式底下

48
00:02:47,168 --> 00:02:49,216
调试模式比较才有点发更黑的

49
00:02:49,472 --> 00:02:51,008
才能够去追踪他

50
00:02:51,520 --> 00:02:55,104
然后可以去看看目前有多少块

51
00:02:55,360 --> 00:03:01,504
哪些会是crt给的是压缩不申请哪些快速

52
00:03:01,760 --> 00:03:03,552
是我应用程序所申请的

53
00:03:04,064 --> 00:03:05,856
他们的量是多少

54
00:03:06,368 --> 00:03:11,488
都可以调用这些函数看得出来我不带你去看这建筑

55
00:03:11,744 --> 00:03:15,328
你手上已经会有完整的文件文档

56
00:03:15,584 --> 00:03:19,936
你可以去试试看你甚至于可以去看看他的眼袋吗

57
00:03:20,960 --> 00:03:21,984
相对于你

58
00:03:22,496 --> 00:03:28,640
提升你对于刚刚所说我说说的VC的malloc的这个技术对于这个提升是有吧

59
00:03:28,896 --> 00:03:29,408
防住的

60
00:03:31,456 --> 00:03:35,040
这个特殊的函数

61
00:03:38,112 --> 00:03:40,416
技术面已经全部探讨完毕了

62
00:03:42,208 --> 00:03:42,976
做一个

63
00:03:43,488 --> 00:03:46,560
大局观的各种整理

64
00:03:48,352 --> 00:03:51,936
我们在第2讲坛这是一个目的的分泌器

65
00:03:52,448 --> 00:03:55,264
到了第3讲坛的是VC的malloc

66
00:03:56,544 --> 00:03:58,336
这是两个不同的系统

67
00:04:00,384 --> 00:04:04,224
这个我可以拿来一起想要乱点鸳鸯谱

68
00:04:05,760 --> 00:04:07,040
前面我提过

69
00:04:07,296 --> 00:04:13,440
触类旁通这个字眼其实malloc的动作这些行为呢我们看到这里

70
00:04:13,696 --> 00:04:16,000
PC的版本这个东西

71
00:04:16,512 --> 00:04:20,095
也有一样的动作而且还更复杂一些

72
00:04:20,607 --> 00:04:22,399
我们已经没有必要

73
00:04:22,655 --> 00:04:24,447
去看各个版本

74
00:04:24,959 --> 00:04:30,079
在不同平台下载各个版本的做法没有必要我们知道啊原来

75
00:04:31,359 --> 00:04:32,383
没locked

76
00:04:32,639 --> 00:04:33,407
做法

77
00:04:34,943 --> 00:04:38,271
在一开始不做介绍了一个人要发愤的吗

78
00:04:38,527 --> 00:04:44,159
他已经发展出至整个算法并且广被采纳

79
00:04:45,439 --> 00:04:47,743
所以你如果再给moussy笔下

80
00:04:47,999 --> 00:04:54,143
他的we will rock也是差不多就这种行为也是每一块带着八个字

81
00:04:54,399 --> 00:04:55,423
字节的空气

82
00:04:55,935 --> 00:04:57,215
等等等等等

83
00:05:00,031 --> 00:05:06,175
说我现在把这两件事情了分配器12讲了分配器和第3讲的没料到

84
00:05:06,431 --> 00:05:07,455
合在一起

85
00:05:07,711 --> 00:05:08,991
希望你能够

86
00:05:09,247 --> 00:05:13,087
更让你的整张心里头的整张图更清楚

87
00:05:15,391 --> 00:05:19,999
分配器最终要内存一键还是跟malat1

88
00:05:22,303 --> 00:05:24,863
分配器这边有16条链表

89
00:05:25,375 --> 00:05:29,215
他管的是最高到128个字节

90
00:05:30,751 --> 00:05:36,127
他每次要的时候都会落到由于这个其实都很小

91
00:05:36,895 --> 00:05:38,943
最没落的时候

92
00:05:39,711 --> 00:05:40,991
都小于

93
00:05:41,247 --> 00:05:45,855
他跟没了非要没到可自己的定义是小区会叫11

94
00:05:47,135 --> 00:05:49,183
说他跟他要永远是小樱

95
00:05:51,231 --> 00:05:54,559
我说永远等一下这个在想如果都小鱼

96
00:05:55,839 --> 00:05:58,399
OK的话就有没有可能

97
00:05:59,935 --> 00:06:01,215
没老婆会不会

98
00:06:02,239 --> 00:06:04,287
速度会不会非常快

99
00:06:04,543 --> 00:06:06,335
他里头有这么复杂的管理

100
00:06:08,639 --> 00:06:09,151
所以

101
00:06:10,175 --> 00:06:12,223
右上角这个分配器

102
00:06:12,479 --> 00:06:15,295
他之所以做这些管理不是为了要

103
00:06:15,551 --> 00:06:16,575
提升速度

104
00:06:17,343 --> 00:06:19,135
Medical已经够快了

105
00:06:19,647 --> 00:06:23,487
你再用他100万次跟将他500000次的恐怕这个

106
00:06:23,743 --> 00:06:25,023
相差无几

107
00:06:26,559 --> 00:06:31,167
目的不是为了提升速度速度已经够令人放心了

108
00:06:31,679 --> 00:06:34,495
目的目的是为了去除

109
00:06:37,055 --> 00:06:38,079
你看这个图

110
00:06:38,335 --> 00:06:40,383
这些东西的上头

111
00:06:40,639 --> 00:06:41,407
这个是古迹

112
00:06:42,175 --> 00:06:48,063
一次性的分配指浪费了这个裤子可是他可以切成这么多小块

113
00:06:51,135 --> 00:06:53,951
如果你把这两者合在一起想

114
00:06:55,999 --> 00:07:00,351
你可以发挥很多你从很多的细节看他们两个的关联性

115
00:07:03,935 --> 00:07:04,447
好

116
00:07:09,567 --> 00:07:13,919
这一张图在整个课程的一开始就提过

117
00:07:14,943 --> 00:07:21,087
我们在最佳程序可以通过这个这个接一个的方式去要到内存最终都跑

118
00:07:21,343 --> 00:07:22,879
好倒霉了开来

119
00:07:24,159 --> 00:07:26,207
而我们现在已经学习到了

120
00:07:27,999 --> 00:07:30,303
Library

121
00:07:32,095 --> 00:07:33,631
他其实有缺点

122
00:07:34,143 --> 00:07:38,495
它的缺点是它不愿意还它比较霸道

123
00:07:38,751 --> 00:07:40,543
这个大的四角

124
00:07:40,799 --> 00:07:44,383
处理它OK分配器

125
00:07:45,151 --> 00:07:46,943
Music怎么样

126
00:07:47,455 --> 00:07:49,247
都有非常复杂的设计

127
00:07:50,527 --> 00:07:52,063
这让我可以告诉你

128
00:07:53,343 --> 00:07:55,391
Medical往下调用OS

129
00:07:55,647 --> 00:08:00,767
也有类似的设计也是一些自由取自由链表

130
00:08:01,791 --> 00:08:04,351
有使用内存池的方式做管理

131
00:08:05,375 --> 00:08:07,423
叠床架屋

132
00:08:08,959 --> 00:08:10,239
也从家务

133
00:08:12,799 --> 00:08:14,335
一阶到高阶

134
00:08:15,359 --> 00:08:16,895
这是不是一种浪费

135
00:08:18,943 --> 00:08:19,455
次

136
00:08:20,479 --> 00:08:22,015
是一种浪费

137
00:08:24,319 --> 00:08:25,599
有没有必要

138
00:08:27,135 --> 00:08:27,903
有

139
00:08:30,719 --> 00:08:32,767
有必要为什么呢

140
00:08:33,535 --> 00:08:34,815
这个是C

141
00:08:35,327 --> 00:08:36,351
层次

142
00:08:36,607 --> 00:08:37,887
它是跨平台的

143
00:08:38,399 --> 00:08:42,751
他并没有说他要依附在哪一个作业系统上面操作系统上面

144
00:08:44,799 --> 00:08:47,103
所以他不能够去预示

145
00:08:48,127 --> 00:08:52,479
他不能预设他下面的操作系统有没有做管理

146
00:08:55,039 --> 00:08:55,807
同样的道理

147
00:08:56,575 --> 00:08:58,111
上面这个分配器

148
00:08:58,879 --> 00:09:00,671
他最终会调用没了

149
00:09:00,927 --> 00:09:03,487
他也不能够去预测这个malloc

150
00:09:03,743 --> 00:09:06,047
有没有做这种管理

151
00:09:07,583 --> 00:09:10,143
因为他是新佳佳标准库

152
00:09:11,167 --> 00:09:15,775
他不能够依赖底层的刺激的东西所以每一个

153
00:09:16,031 --> 00:09:22,175
层次能都不敢去依赖下面不敢有先觉的一个意象

154
00:09:22,431 --> 00:09:24,223
所以自己的那一套

155
00:09:24,735 --> 00:09:29,343
的确是浪费有没有必要呢有必要

156
00:09:30,879 --> 00:09:32,159
他也没办法

157
00:09:34,975 --> 00:09:41,119
我在这个第3讲现在第3讲的一开始我有提过vc60这样vc14这

158
00:09:41,375 --> 00:09:43,423
你会看到了危机时

159
00:09:43,679 --> 00:09:49,055
VC时就没有了

160
00:09:50,847 --> 00:09:54,431
他直接调用其他把任务都

161
00:09:54,687 --> 00:09:56,735
他把责任都交给他了

162
00:09:58,015 --> 00:09:59,295
那我们只能说

163
00:10:00,831 --> 00:10:01,599
VC

164
00:10:01,855 --> 00:10:05,695
为g7plus他专门是为Windows而写的

165
00:10:05,951 --> 00:10:11,071
所以他已经自己公司了自己国家发展的他知道下面Windows

166
00:10:11,327 --> 00:10:14,143
有这个设计其他的

167
00:10:38,975 --> 00:10:40,767
也许对很多很多人的

168
00:10:41,279 --> 00:10:42,303
还是否定

169
00:10:45,375 --> 00:10:49,215
这是我们在学这些既有的系统的另外一个大生活

170
00:10:49,983 --> 00:10:55,615
如果你真的真的有需要写的话好吧这些都是这些技巧都可以借鉴

171
00:10:56,127 --> 00:10:58,687
他是很可能你去就不需要写了

172
00:11:02,527 --> 00:11:05,087
这就是我们的第3讲整个他这边

173
00:11:05,599 --> 00:11:07,647
最后张投影片结束
