1
00:00:00,256 --> 00:00:06,400
现在我打算大

2
00:00:06,656 --> 00:00:07,680
带你来看一看

3
00:00:08,704 --> 00:00:09,472
这个

4
00:00:10,496 --> 00:00:13,312
中括号数组的那个版本

5
00:00:13,824 --> 00:00:17,920
他所收到的大小又有没有什么值得注意

6
00:00:18,176 --> 00:00:20,224
关注的朋友去的地方

7
00:00:22,272 --> 00:00:23,040
现在

8
00:00:24,064 --> 00:00:25,856
我设计了这个库

9
00:00:26,112 --> 00:00:32,256
这个是延续上月的画面来看上面这个

10
00:00:35,840 --> 00:00:37,632
OK

11
00:00:38,144 --> 00:00:40,448
中括号这边收到一个大小

12
00:00:40,960 --> 00:00:44,288
没有中括了这个也收到一个大也收到一个大小

13
00:00:44,800 --> 00:00:49,408
没有中方的这个当然就是这个大小就是一个对象大小

14
00:00:50,688 --> 00:00:54,528
而中括号的这个authoritarian物它所收到的大小

15
00:00:55,808 --> 00:00:58,368
是不是就是数组里面的个数

16
00:00:59,392 --> 00:01:01,696
曾与原数的大小呢

17
00:01:04,000 --> 00:01:04,768
来看看

18
00:01:06,048 --> 00:01:08,864
首先要知道原子数是多大现在的例子

19
00:01:09,888 --> 00:01:11,424
我们的元素下服

20
00:01:11,680 --> 00:01:15,008
它的大小一个整数一个隆回一个string

21
00:01:15,520 --> 00:01:21,408
总数是40是14是加48圈多大

22
00:01:22,432 --> 00:01:27,040
你也许不知道我告诉你说你头其实是一根指针

23
00:01:28,320 --> 00:01:31,136
指针对四加10加四

24
00:01:31,392 --> 00:01:32,160
12

25
00:01:33,440 --> 00:01:34,976
一个部

26
00:01:35,232 --> 00:01:36,000
赞

27
00:01:36,256 --> 00:01:38,560
占用12个字节

28
00:01:40,608 --> 00:01:42,400
我们现在回到这边来

29
00:01:43,680 --> 00:01:44,448
这个大小

30
00:01:44,704 --> 00:01:48,032
Cyril付多少这里是执行结果

31
00:01:48,800 --> 00:01:52,896
我们就可以看到的一行出现是什么

32
00:01:53,920 --> 00:01:55,712
下面是另外一个例子

33
00:01:55,968 --> 00:02:02,112
是吧这个不这边有写如果把它附加上一个多少秋的他有趣

34
00:02:02,368 --> 00:02:03,392
还有虚函数了

35
00:02:06,464 --> 00:02:08,768
我们在这个party数课程

36
00:02:09,280 --> 00:02:10,048
前面

37
00:02:10,304 --> 00:02:13,376
单元在讲对象模型

38
00:02:14,144 --> 00:02:17,728
方只要一个内有虚函数

39
00:02:17,984 --> 00:02:21,312
它的对象就会多一个指针

40
00:02:22,336 --> 00:02:24,128
所以上面是12

41
00:02:24,640 --> 00:02:27,968
下面这一种吗这是另外一个例子了

42
00:02:29,248 --> 00:02:32,320
就是16了10加46

43
00:02:34,880 --> 00:02:36,160
接下来

44
00:02:36,928 --> 00:02:37,696
宁

45
00:02:38,464 --> 00:02:39,744
另一个元素

46
00:02:40,512 --> 00:02:41,536
Deleted

47
00:02:41,792 --> 00:02:47,936
1和2的执行结果在这边儿我就不带你看了因为这是单一的

48
00:02:48,192 --> 00:02:48,704
对象

49
00:02:49,216 --> 00:02:50,752
没有什么好吃的

50
00:02:51,264 --> 00:02:52,032
122

51
00:02:52,544 --> 00:02:55,616
或者是加上虚函数之后的一和二在这里

52
00:02:59,200 --> 00:03:00,992
我不看34

53
00:03:01,760 --> 00:03:06,112
这里是另一个数组的元素

54
00:03:07,392 --> 00:03:08,928
刚刚已经分析出

55
00:03:09,440 --> 00:03:10,976
大小是12

56
00:03:11,232 --> 00:03:13,024
下面这种情况大小是16

57
00:03:13,280 --> 00:03:15,328
我们先看上面这种情况

58
00:03:16,096 --> 00:03:20,704
大小是12有五个22乘以96时

59
00:03:21,984 --> 00:03:23,520
是不是得到

60
00:03:23,776 --> 00:03:24,800
60呢

61
00:03:28,384 --> 00:03:30,944
刚刚在商业这个中括号这里

62
00:03:33,504 --> 00:03:37,600
我这边有一个打印出来我又把这个大小打印出来

63
00:03:39,392 --> 00:03:40,928
这样子才能够观察

64
00:03:41,952 --> 00:03:44,000
打印出来的结果是什么

65
00:03:44,512 --> 00:03:47,584
我要这里来啊这是第3个动作了

66
00:03:49,120 --> 00:03:50,912
这里执行结果在这里

67
00:03:53,216 --> 00:03:57,312
我刚放出来是65个元素每个元素12

68
00:03:57,824 --> 00:04:00,128
从小16次结果是64

69
00:04:01,920 --> 00:04:02,944
这个就有趣了

70
00:04:03,968 --> 00:04:07,552
而且执行完之后有5次的构造函数

71
00:04:09,600 --> 00:04:10,624
这个是正确的

72
00:04:10,880 --> 00:04:16,000
因为一个数组就算你先都不知道这些事情并对数组呢

73
00:04:16,256 --> 00:04:18,303
他创立自然出来之后

74
00:04:19,071 --> 00:04:24,191
每个对象都要调用构造函数一次所以我

75
00:04:25,471 --> 00:04:27,519
但是这个64调怎么解释

76
00:04:28,543 --> 00:04:30,847
我画成图在右边这里

77
00:04:32,895 --> 00:04:35,199
我这个程序是在各路

78
00:04:35,711 --> 00:04:39,551
怎么4.9版本

79
00:04:40,063 --> 00:04:41,087
测试的

80
00:04:42,367 --> 00:04:48,511
这个多出来的是比起刚刚的计算是60还多次这个词其实就是这个位置

81
00:04:50,815 --> 00:04:51,583
大小

82
00:04:54,655 --> 00:04:55,935
他进入了

83
00:04:56,959 --> 00:05:00,031
他进入什么里面的值是五

84
00:05:00,287 --> 00:05:02,335
表示下面有五个元素

85
00:05:04,127 --> 00:05:05,663
这个大小是14

86
00:05:06,431 --> 00:05:10,783
所以60加四在筷子游戏

87
00:05:14,111 --> 00:05:15,135
可见

88
00:05:15,903 --> 00:05:19,743
在格罗斯底下当你要一个array的时候

89
00:05:19,999 --> 00:05:26,143
把把瑞的整包大小再加上一个counter一个计数器counter

90
00:05:26,655 --> 00:05:27,679
整包

91
00:05:28,447 --> 00:05:30,239
来分配

92
00:05:30,751 --> 00:05:31,775
这是合理的

93
00:05:32,031 --> 00:05:36,127
这是合理的呢这里主要记录表示下面15个

94
00:05:36,639 --> 00:05:42,783
然后这边两个虚线我要表达的是构造的时候是这样子来调用构造函数

95
00:05:44,319 --> 00:05:45,599
那个listing

96
00:05:46,111 --> 00:05:47,903
启动

97
00:05:48,415 --> 00:05:51,743
析构的时候是这样来调用析构函数

98
00:05:51,999 --> 00:05:55,583
这样这样子讲讲网上移动

99
00:06:01,983 --> 00:06:06,335
所以各位看是分配一大块内存之后5次构造函数

100
00:06:07,359 --> 00:06:11,711
要释放的时候呢是析构函数然后调用

101
00:06:12,479 --> 00:06:13,247
这个

102
00:06:13,759 --> 00:06:14,527
把整块

103
00:06:15,039 --> 00:06:15,807
手表

104
00:06:20,415 --> 00:06:21,439
是不是这种情况呢

105
00:06:22,463 --> 00:06:28,607
一样的分析下面是下面这种情况只是同样的代码我对于附加

106
00:06:28,863 --> 00:06:32,447
加上一个虚函数所以大小就变成16了

107
00:06:33,215 --> 00:06:33,983
16

108
00:06:34,495 --> 00:06:38,847
因此五个的话就是80时65就80

109
00:06:39,615 --> 00:06:41,407
他是传进去是吧

110
00:06:42,431 --> 00:06:44,735
在分析跟刚刚完全一样

111
00:06:50,111 --> 00:06:52,159
这种做法

112
00:06:52,415 --> 00:06:53,439
怎么做法呢

113
00:06:53,695 --> 00:06:58,303
Eagle ray的前头多了一个counter这种做法

114
00:06:58,559 --> 00:07:00,607
在各路C我们看到了

115
00:07:00,863 --> 00:07:02,399
在VC

116
00:07:03,423 --> 00:07:08,543
我现在这里没有准备把那给你看其实也是一样的做法

117
00:07:10,591 --> 00:07:12,383
也就是靠着这个啊

118
00:07:12,895 --> 00:07:15,199
这里面东西五或者下面东西五

119
00:07:17,503 --> 00:07:23,647
这个兵器材能够很快速的知道所以下面要调用复制构

120
00:07:23,903 --> 00:07:26,207
口罩和一次性购

121
00:07:35,679 --> 00:07:36,703
把我们看这边

122
00:07:44,383 --> 00:07:47,967
如果我前面附近吸引用下去

123
00:07:48,735 --> 00:07:49,503
我明明有

124
00:07:49,759 --> 00:07:52,063
重载这些特殊的函数

125
00:07:52,575 --> 00:07:54,623
但是使用的时候是这么用

126
00:07:56,159 --> 00:07:58,463
或者是这么用12344个动作

127
00:07:59,231 --> 00:08:03,327
看看已经提过了这么用的话会绕过我写的那一些

128
00:08:03,839 --> 00:08:04,607
我现在

129
00:08:05,375 --> 00:08:10,495
测试程序会打印出来就可以看出来确实他没有完全没有进入

130
00:08:10,751 --> 00:08:11,775
我所

131
00:08:12,287 --> 00:08:14,591
我所承载的那些书

132
00:08:20,479 --> 00:08:24,063
但是这个前面会加一个康德这件事情是不会变的

133
00:08:25,087 --> 00:08:31,231
如果这个事情变成了整个这个逻辑就多就会错误整个是一家家平台都是错误的

134
00:08:37,119 --> 00:08:38,655
说到这里

135
00:08:39,167 --> 00:08:40,703
我说不出的这一些

136
00:08:41,471 --> 00:08:42,239
让大家

137
00:08:43,007 --> 00:08:47,615
理解到我们可以重载全局的类重载

138
00:08:47,871 --> 00:08:49,151
成员函数了

139
00:08:49,919 --> 00:08:51,199
分别是

140
00:08:51,967 --> 00:08:55,807
翻译对象的这种方法或是对数组

141
00:08:56,063 --> 00:08:58,623
这种我们都可以从来吧

142
00:09:01,951 --> 00:09:08,095
这也要谈得再多一个你还可以存在一种特殊形式这个叫做

143
00:09:08,351 --> 00:09:09,631
Placement

144
00:09:10,655 --> 00:09:15,263
Wiseman用它的形式来我们来看看这些文字啊

145
00:09:15,519 --> 00:09:19,615
我们可以从the class member的这个东西

146
00:09:21,151 --> 00:09:21,663
注意

147
00:09:22,175 --> 00:09:24,223
这里指着这个地方

148
00:09:28,575 --> 00:09:29,855
它的形式是这样

149
00:09:31,391 --> 00:09:32,927
用起来的形式是这样

150
00:09:35,231 --> 00:09:37,023
这个跟先前不同啊

151
00:09:37,279 --> 00:09:40,351
先前是另一个class

152
00:09:40,607 --> 00:09:43,167
后面是classname并没有中间这一段

153
00:09:44,191 --> 00:09:50,335
现在允许你加上这一段带着小括号的这一段我们把它叫

154
00:09:50,591 --> 00:09:51,871
做placement

155
00:09:54,687 --> 00:09:55,455
他说

156
00:09:55,711 --> 00:09:57,247
Cplusplus可以

157
00:09:57,503 --> 00:09:59,295
也许我们重返

158
00:09:59,551 --> 00:10:02,111
而且可以重返很多的版本

159
00:10:02,367 --> 00:10:03,903
前提是什么呢

160
00:10:04,159 --> 00:10:10,047
每一个版本是名都要有独一无二的参数列

161
00:10:10,303 --> 00:10:11,839
天才能够分开来了

162
00:10:13,631 --> 00:10:15,935
什么意思这句话

163
00:10:16,959 --> 00:10:19,007
我现在写的四个版本

164
00:10:22,079 --> 00:10:26,175
这个就是一般的先前从反过来

165
00:10:26,943 --> 00:10:31,039
这个不算是现在这1这个主题的讨论不算

166
00:10:32,063 --> 00:10:32,831
这一个呢

167
00:10:34,367 --> 00:10:35,903
这一个就不一样了

168
00:10:37,183 --> 00:10:43,327
这是最标准的一般的版本这一个呢不但多不但有这个一定要有

169
00:10:43,583 --> 00:10:46,399
没有这个参数而且还多了第2个参数

170
00:10:47,679 --> 00:10:48,447
这个呢

171
00:10:48,959 --> 00:10:54,335
也是一样后头有多参数或者是参数类型不同四个版本

172
00:10:55,615 --> 00:10:57,151
肝脏上也说什么

173
00:10:57,407 --> 00:11:02,015
说每一个版本都要有独特的参数列

174
00:11:04,575 --> 00:11:08,671
也就是这里1234它的参数列都必须不一样

175
00:11:10,463 --> 00:11:12,255
当然了不然的话就

176
00:11:13,023 --> 00:11:17,119
完全重复怎么了怎么了

177
00:11:19,167 --> 00:11:20,447
我们再看上一页

178
00:11:21,215 --> 00:11:25,567
而且其中的第1参数必须是这个

179
00:11:27,615 --> 00:11:28,383
来看看

180
00:11:29,407 --> 00:11:30,687
这里有四个版本

181
00:11:30,943 --> 00:11:35,295
第1参数一定是333

182
00:11:39,135 --> 00:11:45,279
合理吗因为这些东西是要分配内存一定要知道大小并需要传进来你要给他这个

183
00:11:45,535 --> 00:11:46,047
空间

184
00:11:46,559 --> 00:11:48,351
这个参数让它传进来

185
00:11:51,167 --> 00:11:52,191
再回到上页

186
00:11:53,471 --> 00:11:56,543
第1个参数是这样其余参数

187
00:11:57,311 --> 00:12:00,127
要怎么表现那就是这样子表现

188
00:12:01,663 --> 00:12:03,967
这个小括号里面的

189
00:12:04,735 --> 00:12:06,527
发现现在有两个

190
00:12:07,039 --> 00:12:10,879
因此他实际设计的时候参数就有三个

191
00:12:12,415 --> 00:12:18,559
这句话什么意思啊刚刚这边讲了一定会有一个第1参数是这样另外的那就看看你这

192
00:12:18,815 --> 00:12:19,583
这里有几个

193
00:12:20,095 --> 00:12:22,655
这里有两个因是中国人

194
00:12:24,191 --> 00:12:29,055
至于这里的小括号里面的参数是什么要看有几个是什么类型

195
00:12:29,311 --> 00:12:30,591
那就是你的设计

196
00:12:31,871 --> 00:12:33,407
后头我会给一个

197
00:12:33,663 --> 00:12:34,431
标准库

198
00:12:35,199 --> 00:12:37,759
也许感觉会更好一些

199
00:12:40,575 --> 00:12:44,415
这个月之夜之下我写了一个

200
00:12:44,927 --> 00:12:47,231
范例程序那个就没有什么逻辑

201
00:12:47,487 --> 00:12:48,767
我只是在测

202
00:12:49,023 --> 00:12:51,327
任意的给任意的参数

203
00:12:51,839 --> 00:12:52,863
标准库的那个

204
00:12:53,119 --> 00:12:54,655
历史地位比较更好

205
00:12:58,495 --> 00:12:59,263
好

206
00:12:59,519 --> 00:13:01,823
这个就叫做placement

207
00:13:04,639 --> 00:13:07,199
有的人说这个这种这种

208
00:13:07,711 --> 00:13:13,855
Chris Monroe这种东西呀指的是特别的这里有一个指针

209
00:13:14,111 --> 00:13:17,695
作为参数那一种才叫placement

210
00:13:19,231 --> 00:13:23,583
这个公说公有理婆说婆有理

211
00:13:25,631 --> 00:13:28,447
公说公有理他是说这个

212
00:13:28,703 --> 00:13:34,847
如果这是一个指针的话那指针所以placement placement定位定在那里

213
00:13:35,103 --> 00:13:36,383
才叫placement

214
00:13:36,895 --> 00:13:38,687
这个名字还有意识

215
00:13:39,967 --> 00:13:41,503
好了不管这一些了

216
00:13:41,759 --> 00:13:45,087
反正这个通通都被归类为

217
00:13:45,599 --> 00:13:49,439
使用小括号所表现的额外的

218
00:13:49,951 --> 00:13:50,719
参数

219
00:13:55,583 --> 00:13:57,631
那么对应于这样

220
00:13:58,143 --> 00:14:02,239
像刚刚刚我要到下一页这里有四个版本啊

221
00:14:03,263 --> 00:14:06,335
我可不可以有四个operator呢

222
00:14:06,591 --> 00:14:08,895
好像觉得应该要有

223
00:14:11,455 --> 00:14:17,599
水回到上个月来这里就说了我们也可以他没有讲这里

224
00:14:57,279 --> 00:15:00,863
但是这里的特殊版本是不会引导他过来的

225
00:15:02,655 --> 00:15:08,799
只有当你所调用的构造函数抛出异常

226
00:15:09,311 --> 00:15:12,895
才会调用这一些版本

227
00:15:17,759 --> 00:15:19,551
也许你现在感受不到

228
00:15:20,319 --> 00:15:21,599
这些都是蚊子

229
00:15:22,623 --> 00:15:23,903
待会我给你看

230
00:15:24,159 --> 00:15:27,743
我的一个设计再来看这一段文字

231
00:15:28,255 --> 00:15:30,047
更清楚一些

232
00:15:33,119 --> 00:15:35,167
使用开始写代码

233
00:15:35,679 --> 00:15:36,959
四个八分写出来了

234
00:15:37,471 --> 00:15:39,519
你都做什么事情不管是不是我们

235
00:15:39,775 --> 00:15:40,287
重点

236
00:15:40,799 --> 00:15:43,103
我把接管过来重要是这样

237
00:15:44,895 --> 00:15:46,431
武汉写的第5个版本

238
00:15:47,711 --> 00:15:53,855
这我说这又是一个plasmon又但是故意写错的一参数的差

239
00:15:54,111 --> 00:15:57,951
第3是太婆刚刚上映的时候必须是这个

240
00:16:00,255 --> 00:16:02,815
你说必须我偏偏想试一下

241
00:16:03,327 --> 00:16:04,863
所以我在这音乐呢

242
00:16:05,631 --> 00:16:08,191
你看第1个参数设为龙

243
00:16:10,495 --> 00:16:11,775
结果报错了

244
00:16:12,543 --> 00:16:14,079
报错说什么

245
00:16:14,335 --> 00:16:19,455
Operator new必须接受这一个东西作为第1个参数

246
00:16:19,711 --> 00:16:21,759
这个报错信息相当清楚

247
00:16:23,039 --> 00:16:27,391
我们学着去看看一些报错信息信息是很

248
00:16:27,903 --> 00:16:30,207
我觉得是很好的学习过程

249
00:16:32,767 --> 00:16:38,655
所以五个版本第5个版本会编译不过他就把单反拿掉四个版本

250
00:16:42,495 --> 00:16:46,335
因此夏夜会出现四个对应的operator delete

251
00:16:48,639 --> 00:16:52,223
而那些accreditation所做的事情

252
00:16:53,247 --> 00:16:57,599
刚刚才这边这一段我说也许你们看不太懂现在我要来解释它

253
00:17:00,415 --> 00:17:00,927
武汉

254
00:17:01,951 --> 00:17:03,743
我刻意的安排了

255
00:17:04,511 --> 00:17:05,791
这里有一个

256
00:17:06,303 --> 00:17:08,863
构造函数会抛出异常

257
00:17:09,119 --> 00:17:11,167
我故意在这里抛出异常

258
00:17:13,471 --> 00:17:15,775
好然后我们就看看四个版本

259
00:17:20,895 --> 00:17:22,175
它的参数

260
00:17:23,455 --> 00:17:24,479
适合前面

261
00:17:24,735 --> 00:17:26,015
你的兄弟

262
00:17:26,271 --> 00:17:27,295
怎样的

263
00:17:30,111 --> 00:17:33,183
不是说一样是只有互相对应的

264
00:17:33,695 --> 00:17:34,463
你可以

265
00:17:34,719 --> 00:17:35,999
停下来慢慢体会

266
00:17:38,047 --> 00:17:39,839
这四个版本

267
00:17:40,351 --> 00:17:41,631
不管哪一个

268
00:17:42,911 --> 00:17:45,983
他们被调用的时机只有一个

269
00:17:47,519 --> 00:17:49,567
就是它对应的那个兄弟

270
00:17:50,591 --> 00:17:54,431
这是operator delete它对应的兄弟叫operator New

271
00:17:54,687 --> 00:17:56,479
Operational

272
00:17:56,991 --> 00:17:59,551
分配内存之后

273
00:18:00,831 --> 00:18:02,879
接下来会调用构造函数

274
00:18:05,951 --> 00:18:07,999
构造函数如果发出一场

275
00:18:09,279 --> 00:18:13,375
表示在一个对象的整个构造过程之中

276
00:18:14,399 --> 00:18:15,167
吃饭了

277
00:18:17,727 --> 00:18:23,871
我们抽身出来整理一下一个对象要构造的时候首先要分配内存然后调用

278
00:18:24,127 --> 00:18:24,895
用构造数

279
00:18:25,407 --> 00:18:27,199
分配内存呢

280
00:18:27,967 --> 00:18:30,015
好到这四个版本其中一个

281
00:18:31,551 --> 00:18:33,855
分配好了别的将构造函数

282
00:18:35,135 --> 00:18:37,439
万一调用构造函数的时候

283
00:18:37,695 --> 00:18:38,975
不是说话中一场

284
00:18:39,743 --> 00:18:42,559
表示整个构造的过程没有成功

285
00:18:44,607 --> 00:18:49,471
没有成功的话应该把刚刚分配的那个内存释放掉才好

286
00:18:50,751 --> 00:18:52,287
火车会发生内存泄漏

287
00:18:55,103 --> 00:19:00,735
就在这个时候当过造函数发出一场的时候

288
00:19:00,991 --> 00:19:04,575
对应的是四个字母对应的那个就会被叫起来

289
00:19:06,879 --> 00:19:08,927
给了你一个机会去

290
00:19:09,439 --> 00:19:10,207
翅膀

291
00:19:11,231 --> 00:19:12,511
先前分配的内存

292
00:19:16,607 --> 00:19:18,399
所以这四个我也写好了

293
00:19:18,655 --> 00:19:20,959
商业14个我也学好了

294
00:19:21,215 --> 00:19:24,799
而且我估计在这个地方抛出异常

295
00:19:26,335 --> 00:19:28,383
好我们看执行结果

296
00:19:30,175 --> 00:19:31,711
这是测试的代码

297
00:19:35,039 --> 00:19:39,135
这里11234调用到哪一个版本

298
00:19:40,415 --> 00:19:42,975
就是这样到这里的对应的1234

299
00:19:43,999 --> 00:19:48,607
你可以停课下来慢慢看怎么看呢看看陆后面的参数

300
00:19:50,399 --> 00:19:53,215
然后对应着四个吧

301
00:19:56,543 --> 00:19:57,311
第5个

302
00:19:57,567 --> 00:19:58,591
第5个动作

303
00:19:58,847 --> 00:20:00,639
我做这个妞

304
00:20:02,431 --> 00:20:05,503
一定要把最快圈起来这里

305
00:20:07,039 --> 00:20:09,599
我刻意的让他

306
00:20:09,855 --> 00:20:12,159
要用的不是吗

307
00:20:12,415 --> 00:20:13,695
构造函数

308
00:20:14,975 --> 00:20:17,023
前面的四个都是默认构造函数

309
00:20:19,583 --> 00:20:20,351
这个不是

310
00:20:21,887 --> 00:20:22,911
而这一个

311
00:20:24,959 --> 00:20:25,983
我要赏月

312
00:20:27,519 --> 00:20:31,615
儿子一个参数的构造函数会抛出异常

313
00:20:32,639 --> 00:20:34,431
我就是要观察这种情况

314
00:20:39,807 --> 00:20:41,087
返回来

315
00:20:42,623 --> 00:20:46,719
那么这里12345678 678我就没写了

316
00:20:47,743 --> 00:20:53,887
因为这里我已经抛出异常了大马鲜生这样但是在执行的时候到了我已经抛出一

317
00:20:54,143 --> 00:20:54,911
李长乐

318
00:20:57,215 --> 00:21:01,567
这时候我看看应该有一个对应的兄弟会被调用

319
00:21:05,151 --> 00:21:06,431
这是执行结果

320
00:21:07,967 --> 00:21:11,295
1234512345

321
00:21:12,319 --> 00:21:14,111
无数异常

322
00:21:16,416 --> 00:21:17,952
果然结束了程序

323
00:21:19,744 --> 00:21:24,864
产品exported after stroke in an instance of

324
00:21:25,120 --> 00:21:27,936
这个这个就是我设计的那一个一场

325
00:21:30,240 --> 00:21:31,264
Bad

326
00:21:31,520 --> 00:21:33,056
这个照片

327
00:21:34,336 --> 00:21:36,384
我的测试程序都是包夹在

328
00:21:36,640 --> 00:21:38,688
这次的命名空间中

329
00:21:38,944 --> 00:21:43,296
所以这个bat有一个命名空间纠结07

330
00:21:47,136 --> 00:21:48,416
可是

331
00:21:50,464 --> 00:21:55,840
为什么他就这么做这一行的呢这样不是我在我控制之中呢

332
00:21:58,912 --> 00:22:01,472
按理说这个舞

333
00:22:01,728 --> 00:22:07,872
应该跑来调用这里面的某一个是哪一个能为我也得仔细比对一下

334
00:22:08,128 --> 00:22:12,480
按理说它调用其中一个那就应该有这些输出啊

335
00:22:14,016 --> 00:22:16,832
这是我刻意的out的输出吗

336
00:22:17,856 --> 00:22:19,392
这里并没有

337
00:22:21,696 --> 00:22:25,536
至于最后面出现的这一行是因为

338
00:22:26,048 --> 00:22:29,376
一场如果作为一个比较

339
00:22:30,912 --> 00:22:37,056
今天不是太多的私家要程序员一般是还不会去碰触到异常exception

340
00:22:37,312 --> 00:22:39,616
我有另外一门课专门再讲一讲

341
00:22:40,384 --> 00:22:43,456
一场发出程序一定是

342
00:22:44,480 --> 00:22:46,272
如果没有人处理他就会结束掉

343
00:22:47,552 --> 00:22:51,904
没有人处理的话能异常会一直传的传的程序传递到最后

344
00:22:52,672 --> 00:22:54,464
有一个函数叫Translate

345
00:22:55,488 --> 00:22:57,536
最后还调到货

346
00:22:57,792 --> 00:23:03,424
是在那最后的阶段他们会打出这一串字出来

347
00:23:06,752 --> 00:23:09,312
可是我期待的是在这个之前

348
00:23:09,568 --> 00:23:11,872
这里应该有一个函数被调用

349
00:23:12,128 --> 00:23:13,152
怎么没有了

350
00:23:15,200 --> 00:23:18,016
哦好我这边有一段注解

351
00:23:19,040 --> 00:23:20,064
赞助价

352
00:23:20,576 --> 00:23:22,880
说不上函数抛出异常了

353
00:23:23,648 --> 00:23:24,672
但是很奇怪

354
00:23:25,184 --> 00:23:28,512
俄罗斯4.9我们的例子是4.9的

355
00:23:28,768 --> 00:23:31,072
没有调用左边的

356
00:23:31,840 --> 00:23:33,632
这个是蛮奇怪的

357
00:23:33,888 --> 00:23:39,008
不过以前在坟墓12.9那我测试过确实是调用

358
00:23:40,800 --> 00:23:42,848
也许这一部分就算是一个

359
00:23:43,104 --> 00:23:44,128
很

360
00:23:44,384 --> 00:23:46,432
狠狠

361
00:23:46,688 --> 00:23:47,968
运维的部分

362
00:23:48,736 --> 00:23:49,760
知道啊

363
00:23:51,040 --> 00:23:55,392
天气的这边说那个人手上的编译器可以测一下

364
00:24:02,048 --> 00:24:05,120
请看这一页的最后下面这里

365
00:24:07,168 --> 00:24:09,216
这一段的意思是说

366
00:24:09,984 --> 00:24:13,312
即使你所写的这一些你有四个版本

367
00:24:14,592 --> 00:24:18,176
我是要拿它来对应上一的四个兄弟

368
00:24:20,224 --> 00:24:26,368
深夜说即使没有一一对应商业写的四个这也什么都没写或者只是一个

369
00:24:27,904 --> 00:24:34,048
即使这样也不会出现任何的编译报错信息并没有打算为你

370
00:24:34,304 --> 00:24:36,096
一对一去检查

371
00:24:37,632 --> 00:24:42,496
因为你在这边写出来是要去政策有没有抛出异常

372
00:24:43,520 --> 00:24:46,336
你如果不写的话表示你不在乎

373
00:24:47,616 --> 00:24:51,200
这也是你的选择编译器并不会强制你

374
00:24:51,456 --> 00:24:52,736
并不会报错
