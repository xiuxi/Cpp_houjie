1
00:00:00,256 --> 00:00:06,400
在高的这个解释过程

2
00:00:06,656 --> 00:00:07,168
中

3
00:00:08,192 --> 00:00:13,824
指针落在哪个黑的黑的里面的哪一个group group里面的哪一个free list

4
00:00:15,616 --> 00:00:17,664
也许已经带给你了概念

5
00:00:19,456 --> 00:00:23,552
这整个月的系统好像是在做一个分段的管理

6
00:00:25,600 --> 00:00:31,232
他其实手上拥有海量的内存它可以用virtual allocate

7
00:00:31,488 --> 00:00:34,048
一次拿一大堆然后来

8
00:00:34,304 --> 00:00:38,400
来来来来一片馄饨的去管理它

9
00:00:39,424 --> 00:00:40,448
奥斯卡博士

10
00:00:40,960 --> 00:00:42,752
它是一次药也没敢

11
00:00:43,520 --> 00:00:47,616
而是因为格用完的在需要这就是一个分段呢

12
00:00:48,128 --> 00:00:53,248
这一段是以美感而是第1次要的是32k

13
00:00:53,760 --> 00:00:59,904
切成八大快跑切成八个配角那个32k好像分段又分的更细一些了

14
00:01:00,160 --> 00:01:01,952
而且32k

15
00:01:02,464 --> 00:01:04,000
4 32k前面

16
00:01:04,256 --> 00:01:09,376
提过是用virtual virtual allocate

17
00:01:09,888 --> 00:01:15,008
在操作系统要有指定是commit的真正要到的内存

18
00:01:15,520 --> 00:01:20,640
所以他所有的他这里的管理机制一个分段分段的管理

19
00:01:21,664 --> 00:01:25,504
一段是多少32k深圳十几的部分

20
00:01:25,760 --> 00:01:28,832
实际的食品的部分是32k

21
00:01:30,368 --> 00:01:35,232
正因为这样分段的管理所以变成需要很多的黑的

22
00:01:36,256 --> 00:01:38,048
那个黑的管理email

23
00:01:38,304 --> 00:01:44,448
而一个黑的里面又有32个不是每个group管理32k一支鱼座

24
00:01:44,704 --> 00:01:45,472
作者

25
00:01:47,264 --> 00:01:48,544
反复的东西出来

26
00:01:51,872 --> 00:01:53,408
为什么要这样子

27
00:01:55,200 --> 00:01:59,040
我们比较抽象的来讨论一下为什么要这样子

28
00:02:00,320 --> 00:02:01,856
为什么不能够

29
00:02:03,136 --> 00:02:04,928
说我只有一个歌

30
00:02:07,488 --> 00:02:13,376
我只有我在一个黑的里头只有一个group那也就是只有64条链表

31
00:02:14,400 --> 00:02:20,544
不要再分成32组64条链表那也就不需要这么一大堆一堆

32
00:02:23,104 --> 00:02:26,432
链表可以串的无现场

33
00:02:27,712 --> 00:02:33,088
所以好像我并不需要去做出32个部落不出来

34
00:02:35,136 --> 00:02:37,696
为什么SB HR手机的怎么复杂

35
00:02:40,000 --> 00:02:42,048
就是为了分段管理

36
00:02:43,072 --> 00:02:49,216
把海量的东西变成一枚感与美感与美感应那个里面有变成深水可以生存

37
00:02:49,472 --> 00:02:52,544
这个分段管理带来什么好处

38
00:02:54,080 --> 00:02:56,128
分段管理资料

39
00:02:58,432 --> 00:02:59,712
为了能够

40
00:03:00,224 --> 00:03:03,552
好的微黄给作业系统

41
00:03:06,368 --> 00:03:07,648
刚刚我们说

42
00:03:07,904 --> 00:03:08,928
我说

43
00:03:09,184 --> 00:03:13,024
如果这里只有一个group不是很干净漂亮吗

44
00:03:14,304 --> 00:03:20,448
没问题可以办这样的话这个group就是要来管一那个了

45
00:03:20,704 --> 00:03:21,984
就没有在气氛了

46
00:03:23,520 --> 00:03:29,664
说将来他要判断是不是能够用全部收回来这一没敢拿到之后他就是起来

47
00:03:29,920 --> 00:03:31,456
切去切的大大小小

48
00:03:31,712 --> 00:03:37,856
部分散出去最后要再收回来等它全部收回来之后他才能

49
00:03:38,112 --> 00:03:39,392
能够还给always

50
00:03:40,928 --> 00:03:42,976
这个时期就拉得很远

51
00:03:44,000 --> 00:03:49,376
你寄来一个单位是一没搞这么大的话什么时候才能够全回收不知道

52
00:03:50,656 --> 00:03:56,288
如果把单位切得越小那个那段全部回收的机会率就大多了

53
00:03:57,824 --> 00:04:01,408
这就是为什么他要把那个在分为30段

54
00:04:01,920 --> 00:04:03,456
30个proof

55
00:04:04,224 --> 00:04:08,576
这个叫group那这一块也叫group这就是为什么

56
00:04:10,624 --> 00:04:16,512
他为什么他会切了更细一点那不是他不要钱那么气会大一点的

57
00:04:17,024 --> 00:04:21,375
这都是团队的考量也许是一些经验这个

58
00:04:22,399 --> 00:04:27,263
也没了没有毕业也没有数学也没办法去之一

59
00:04:27,519 --> 00:04:33,663
假象我们在第2讲里面谈过的公司里面的那些标准库的那些团队他不是选什么20

60
00:04:33,919 --> 00:04:34,943
尺寸12

61
00:04:35,199 --> 00:04:37,759
这些都是经验值

62
00:04:40,319 --> 00:04:45,183
所以这个分段管理就是为了能够很一觉

63
00:04:45,439 --> 00:04:50,047
有机会判断某一段是全回收

64
00:04:50,303 --> 00:04:53,119
这样这一段就可以了还给他这些

65
00:04:55,679 --> 00:04:59,263
至于要如何判断全回收呢

66
00:05:00,799 --> 00:05:02,847
现在一段就是32k

67
00:05:03,871 --> 00:05:04,895
这个东西

68
00:05:06,175 --> 00:05:12,319
一个group 32k它将会被切成八大会在前面一再的出现对话在下头

69
00:05:14,111 --> 00:05:15,903
怎么样判断群回收

70
00:05:16,927 --> 00:05:18,719
你能不能去想象一下

71
00:05:19,999 --> 00:05:22,559
你现在心中应该有一张图

72
00:05:23,071 --> 00:05:25,887
喂喂是我们前面我们往前看

73
00:05:26,143 --> 00:05:27,679
前面这种运作

74
00:05:32,287 --> 00:05:36,895
运作到某一种情况某一个时刻表你拍一张快照的话

75
00:05:37,919 --> 00:05:39,455
应该去想象

76
00:05:39,967 --> 00:05:45,087
这些东西背起了大大小小了就背链在这个64条链表的头

77
00:05:45,343 --> 00:05:51,487
没他电表拉出去就挂三块也挂了1000块人挂了800块可能是

78
00:05:51,743 --> 00:05:52,511
是这种状态

79
00:05:54,815 --> 00:05:56,863
那如何判断全回收

80
00:05:59,167 --> 00:06:00,703
如果这些链表

81
00:06:01,215 --> 00:06:02,495
都变成0

82
00:06:02,751 --> 00:06:06,079
就表示全给出去了全部给出去了

83
00:06:07,103 --> 00:06:09,151
还是怎么样才是全回收呢

84
00:06:11,199 --> 00:06:12,991
似乎很难判断

85
00:06:14,527 --> 00:06:17,855
这个问题就好像在第2墙里面

86
00:06:18,367 --> 00:06:21,183
我们在谈到跟路的分配器

87
00:06:21,439 --> 00:06:23,231
还有16条链表

88
00:06:24,767 --> 00:06:26,303
当时我就提过了

89
00:06:26,815 --> 00:06:29,119
这个链表你也不知道多长

90
00:06:30,655 --> 00:06:33,727
所以你没有办法判断是不是全回收

91
00:06:37,055 --> 00:06:41,407
只要你用链表来是处理你就很难去判断这个事情

92
00:06:44,735 --> 00:06:46,015
幸好

93
00:06:46,271 --> 00:06:47,551
这个设计上面的

94
00:06:48,319 --> 00:06:49,855
他这里有一个counter

95
00:06:51,647 --> 00:06:56,767
只要没有那个就家家只要不一个简简化那这个太好了

96
00:06:58,047 --> 00:07:00,095
只要他回复变成0

97
00:07:00,863 --> 00:07:02,399
这块就是成为首

98
00:07:04,191 --> 00:07:05,471
是不是这样你想想看

99
00:07:09,567 --> 00:07:12,127
这个方法非常简单的就解决这个问题

100
00:07:13,407 --> 00:07:17,247
这不回到刚刚我们讲到哪里呢刚刚谈到

101
00:07:18,271 --> 00:07:23,135
如何判断全回收旧靠着一个康的现在这个都不见了

102
00:07:23,391 --> 00:07:24,415
Accountant

103
00:07:24,671 --> 00:07:25,695
就是这一个

104
00:07:26,463 --> 00:07:30,047
在64条链表上头有个整数

105
00:07:34,655 --> 00:07:36,447
这一种技巧

106
00:07:38,495 --> 00:07:41,055
出现在其他的

107
00:07:41,311 --> 00:07:42,335
分配器上面

108
00:07:43,103 --> 00:07:49,247
总内存管理的这个我们在被那个看到了一堆我们再分配机看到了一堆标准库的分

109
00:07:49,503 --> 00:07:55,647
陈佩奇看到一堆后面的第4讲我们在楼梯也要看到一堆其实都有共性

110
00:07:56,671 --> 00:07:59,231
阿东用自由链表来处理

111
00:07:59,487 --> 00:08:05,375
然后这个有counter等等等你可以整理出很多的共性出来

112
00:08:08,447 --> 00:08:11,519
这个做法也是在第4讲rowkey

113
00:08:11,775 --> 00:08:14,335
分配器也不用这种做法

114
00:08:14,847 --> 00:08:16,127
他的用counter

115
00:08:16,639 --> 00:08:19,199
或者这个变形做法去

116
00:08:19,455 --> 00:08:20,479
判断全回收

117
00:08:22,527 --> 00:08:25,599
判断全回收之后

118
00:08:26,367 --> 00:08:29,695
这一会你能不能想象这一块是什么状态

119
00:08:30,207 --> 00:08:34,815
在考验你对整个系统现在进行到这里的理解了

120
00:08:35,839 --> 00:08:41,983
你洗头想的是有64条链表也可能挂了大大小小但是我现在看到已经变成0了

121
00:08:44,287 --> 00:08:48,895
他老师你问我说他会是个什么状态它会有一个一定的状态吗

122
00:08:51,967 --> 00:08:57,343
会会有一个一定的状态为什么呢因为刚刚提过了他们会合并

123
00:08:59,135 --> 00:09:05,023
所以最后他变成0的时候看着变成临时候这些还回来都合并了

124
00:09:05,535 --> 00:09:06,559
东合并

125
00:09:09,631 --> 00:09:11,423
这时候应该按下挺河间

126
00:09:11,679 --> 00:09:12,703
去想一想

127
00:09:13,215 --> 00:09:15,519
高合并的是怎么情况

128
00:09:20,895 --> 00:09:21,919
什么情况吗

129
00:09:23,199 --> 00:09:25,247
回到了初始状态

130
00:09:26,527 --> 00:09:29,087
初始状态就是这种状态

131
00:09:32,415 --> 00:09:38,559
这里面的小小的东西它也许只真是风格到这个64条链表

132
00:09:38,815 --> 00:09:42,911
但是一旦合并合并合并到最后人要变成这种状态

133
00:09:45,471 --> 00:09:51,103
这种状态又变成就是所谓的八大会落到最后一个链表上

134
00:09:52,127 --> 00:09:53,919
这就是初始状态

135
00:09:54,431 --> 00:09:56,735
也就是全回收的状态

136
00:09:59,039 --> 00:10:01,343
那这8块能不能再合并了

137
00:10:01,599 --> 00:10:03,391
菏菏泽一个32可以了

138
00:10:04,159 --> 00:10:04,927
不行了

139
00:10:05,183 --> 00:10:07,487
因为这里刻意的放纵一

140
00:10:10,303 --> 00:10:12,607
刻意的把他们阻隔开来

141
00:10:16,703 --> 00:10:17,727
不是

142
00:10:18,239 --> 00:10:24,383
皇城的全回收之后就是这整个32k来看一下这个

143
00:10:24,639 --> 00:10:27,199
这8块就是这8块

144
00:10:28,479 --> 00:10:29,759
也就是这一个

145
00:10:31,039 --> 00:10:37,183
这一个是commit拿到真正有内存的人现在已经全回收了就还给操作系统

146
00:10:38,463 --> 00:10:41,023
要用播修复一句话

147
00:10:41,791 --> 00:10:43,839
既然要还

148
00:10:45,119 --> 00:10:47,935
又为什么不让他们合并在一起

149
00:10:50,239 --> 00:10:53,311
其实你要还是合不合并已经无所谓了

150
00:10:54,847 --> 00:10:58,431
那这个地方刻意的也不让他合并是因为

151
00:10:59,711 --> 00:11:01,759
他并不急着还

152
00:11:02,783 --> 00:11:04,063
你想想看啊

153
00:11:04,575 --> 00:11:06,111
如果这边

154
00:11:06,367 --> 00:11:08,671
在运作过程里面呢

155
00:11:08,927 --> 00:11:15,071
分配了1万次出去又释放了10000次回来然后这个系统马上就把这个机

156
00:11:15,327 --> 00:11:17,375
几乎乎的把这1块还给操作系统

157
00:11:18,911 --> 00:11:25,055
用程序它的的10001次调用了的10001次又要1块内存那不是

158
00:11:25,311 --> 00:11:28,383
IU重来一次把这个初始状态就是

159
00:11:30,687 --> 00:11:32,991
所以他不是那么的浮躁

160
00:11:35,039 --> 00:11:40,159
他是保留着下次再有一个群回收他才会还

161
00:11:41,695 --> 00:11:47,583
和他保留着说他不和病因为和病人最后不需要切开来又变成什么状态

162
00:11:51,935 --> 00:11:57,567
这段是一个很多的这个纯粹的逻辑上的描述

163
00:11:58,591 --> 00:12:01,151
可能你又需要听歌下来好好思考

164
00:12:02,943 --> 00:12:08,319
总之是要让清刚刚就是请你去吃想权回收是什么情况

165
00:12:08,831 --> 00:12:09,855
就是这个发大会

166
00:12:10,111 --> 00:12:11,135
把他最后一个

167
00:12:11,391 --> 00:12:12,415
电表上的

168
00:12:17,023 --> 00:12:17,791
所以

169
00:12:19,071 --> 00:12:20,095
我回到这边

170
00:12:22,399 --> 00:12:28,543
一个如何判断全回收已经知道了已经处很简单看了看第2个

171
00:12:28,799 --> 00:12:30,079
不要造句

172
00:12:32,127 --> 00:12:34,175
Sdh这个系统

173
00:12:34,687 --> 00:12:35,967
他不急着还

174
00:12:37,247 --> 00:12:41,087
他手上有两个群晖说他才缓一个永远如此

175
00:12:44,159 --> 00:12:47,487
那他该怎么去做这个不要照进了动作呢

176
00:12:48,511 --> 00:12:49,535
在

177
00:12:49,791 --> 00:12:55,935
源代码的设计的这个命名你投以及可能很少量注解你都能提到的这个字叫

178
00:12:56,191 --> 00:12:56,959
Embry

179
00:12:57,983 --> 00:13:00,031
Oxford就是延缓

180
00:13:00,543 --> 00:13:03,103
蔗糖延缓这个全回收的

181
00:13:03,615 --> 00:13:04,639
示范动作

182
00:13:05,151 --> 00:13:07,711
把我们看看我这边有一段文字的解释

183
00:13:08,991 --> 00:13:11,551
所谓的first是什么意思

184
00:13:14,367 --> 00:13:14,879
在

185
00:13:15,391 --> 00:13:16,415
一开始

186
00:13:16,927 --> 00:13:18,207
这边有一个变量

187
00:13:18,975 --> 00:13:19,999
这什么函数

188
00:13:20,255 --> 00:13:25,119
这就是整个crt 1开始那个session

189
00:13:25,375 --> 00:13:26,911
里头跑到这里来

190
00:13:27,423 --> 00:13:32,031
分配16个黑的这就是我们这1讲一开始做

191
00:13:33,567 --> 00:13:39,199
80分配完之后呢下面就是由这些特定的是先前没有提到

192
00:13:40,223 --> 00:13:45,855
在这些设定里面有一个全局变量叫这个叫黑豹

193
00:13:46,879 --> 00:13:47,647
反正

194
00:13:48,159 --> 00:13:54,303
在源代码当然了我想你也不会再去看源代码了我这个所有的新的都告诉你了他在这个源代码里

195
00:13:54,559 --> 00:13:59,935
还是出现了这种命名的就是跟现在要讨论的事情有关

196
00:14:01,215 --> 00:14:03,263
这个第4次回落

197
00:14:04,799 --> 00:14:10,943
现在就来解释这根指针这个黑saber它是一个指针指向

198
00:14:11,199 --> 00:14:12,991
全回收的

199
00:14:14,271 --> 00:14:15,551
所属的黑的

200
00:14:16,575 --> 00:14:18,623
黑的有32个group

201
00:14:18,879 --> 00:14:20,927
无一个故事和全回收了

202
00:14:21,695 --> 00:14:24,511
这时候这个指针就指向黑的

203
00:14:25,279 --> 00:14:26,303
对应的黑色

204
00:14:27,839 --> 00:14:33,983
我们继续往下看这个group就是一个全回收的不是本来应该被释放也就是还给操作系统

205
00:14:35,775 --> 00:14:38,335
我*尽了暂时给他留着

206
00:14:38,591 --> 00:14:39,359
延缓

207
00:14:40,639 --> 00:14:43,967
等到有第2个出现的时候

208
00:14:44,479 --> 00:14:48,575
Sph才释放掉目前登记的这一个

209
00:14:50,623 --> 00:14:54,719
释放掉之后他把那个现在的第2个就当成第1个了

210
00:14:54,975 --> 00:14:57,279
你是要用这根指针去只得他

211
00:15:00,607 --> 00:15:05,471
在他手上永远保留一个全回收如果有权回收的话

212
00:15:05,727 --> 00:15:06,751
永远保留一个

213
00:15:08,543 --> 00:15:10,591
这就是differ的动作

214
00:15:11,871 --> 00:15:14,687
这也是内存管理的共性

215
00:15:15,455 --> 00:15:21,343
我们后面看到的这个现在第3讲第4讲谈到loki那些很棒的东西

216
00:15:21,855 --> 00:15:25,951
也有这样的作案概念做法他们会有点

217
00:15:26,719 --> 00:15:29,023
月亮不同概念是一样的

218
00:15:30,303 --> 00:15:32,863
好我们继续往下看

219
00:15:34,143 --> 00:15:37,727
如果尚未出现第2个全回收

220
00:15:39,519 --> 00:15:40,799
手上已经有一个了

221
00:15:41,823 --> 00:15:45,151
这个没出现所以这个是保留在sdh的手上

222
00:15:46,431 --> 00:15:49,247
这时候的客户又要内存的

223
00:15:50,271 --> 00:15:52,063
于CSS pH

224
00:15:53,087 --> 00:15:59,231
他当初没有很不到的给出去玩出去这是好事现在终于派上用场了他保留着

225
00:15:59,487 --> 00:16:02,047
客户要好我就从这个给他

226
00:16:03,327 --> 00:16:06,143
这个一个去他就不是求回收了

227
00:16:06,399 --> 00:16:07,423
这就是下面的

228
00:16:08,959 --> 00:16:12,799
要给出去的话那你付指针又会被取消就是为了

229
00:16:14,847 --> 00:16:19,199
这本来都是很自然的人让你去想你也是想这个样子

230
00:16:19,711 --> 00:16:25,343
我试试有什么太大的学问就是很自然的你会认为不要急着还吗

231
00:16:26,879 --> 00:16:29,695
然后这个东西是候选人

232
00:16:29,951 --> 00:16:31,743
秭归还的候选人

233
00:16:31,999 --> 00:16:35,839
但是一旦他一起出去他又变得不是候选人了就这么搞

234
00:16:36,351 --> 00:16:38,143
形成的一种概念

235
00:16:40,703 --> 00:16:43,775
要注意这个这是非常细节的啊

236
00:16:44,031 --> 00:16:47,359
20这是一个内存分配的共性很多

237
00:16:47,871 --> 00:16:49,663
系统都是这么做的要注意

238
00:16:50,431 --> 00:16:51,967
这个指针

239
00:16:52,991 --> 00:16:55,039
将会指向这个16格

240
00:16:55,295 --> 00:16:59,135
这16个月是用光了就会有32个会有48个跑出来

241
00:17:00,159 --> 00:17:02,719
这个指针指向其中某一个

242
00:17:03,999 --> 00:17:08,095
而这么一个里面这个里头就是有30个

243
00:17:08,351 --> 00:17:11,167
到底哪一个group是全回收的呢

244
00:17:11,423 --> 00:17:13,727
会有另外一个音乐

245
00:17:15,007 --> 00:17:17,823
去只得他这个将是领到31

246
00:17:18,847 --> 00:17:20,127
贸易会

247
00:17:21,663 --> 00:17:26,527
整个系统里面在做10 G的内存的分段的管理是不容

248
00:17:27,295 --> 00:17:28,319
也就是这边

249
00:17:29,087 --> 00:17:30,367
这次可以在管理

250
00:17:33,183 --> 00:17:38,303
好这边怎么这里边我圈起来这里两行

251
00:17:39,839 --> 00:17:40,863
这两个

252
00:17:41,631 --> 00:17:45,727
从一个全回说的group里头要去拿内存

253
00:17:46,495 --> 00:17:48,031
细节在这边

254
00:17:50,335 --> 00:17:51,871
这边就很单纯了

255
00:17:52,383 --> 00:17:53,151
我想

256
00:17:53,663 --> 00:17:55,455
你看得懂这段文字

257
00:17:55,967 --> 00:17:56,735
就不讲了
