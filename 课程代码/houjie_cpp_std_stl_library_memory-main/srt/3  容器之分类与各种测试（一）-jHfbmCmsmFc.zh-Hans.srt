1
00:00:06,656 --> 00:00:12,032
好从这根可以们开始我们开始要引导大家来

2
00:00:12,288 --> 00:00:18,432
使用最重要的是使用这个容器那么你把元素放到容器

3
00:00:18,944 --> 00:00:25,088
之后有些操作他于是我们就会用到一些算法用到一些一些其他的东西

4
00:00:28,416 --> 00:00:34,560
这张图非常的丰富含的是容器里面的结构以及他的分

5
00:00:34,816 --> 00:00:35,584
分类

6
00:00:35,840 --> 00:00:41,984
最重要的是我们在使用一个容器的时候它在内存里面是长什么样子

7
00:00:42,240 --> 00:00:44,544
元素汉元素之间

8
00:00:44,800 --> 00:00:47,616
是什么的关系这个连续的关系吗

9
00:00:48,128 --> 00:00:49,920
还是用指针吗串起来的

10
00:00:50,176 --> 00:00:52,736
串起来是一个单纯的链表呢

11
00:00:52,992 --> 00:00:54,528
还是它是一棵树

12
00:00:54,784 --> 00:00:59,136
Tree的数这个数是红黑树吗2分数吗

13
00:00:59,392 --> 00:01:01,184
它是一个hashtable

14
00:01:01,952 --> 00:01:02,976
哈希表

15
00:01:03,232 --> 00:01:09,376
到底他是什么呢非常重要你要知道他到底代表什么结构

16
00:01:09,632 --> 00:01:14,496
你才能够去判断我做这个动作效率如何

17
00:01:15,264 --> 00:01:17,568
背后引发什么样的连锁反应

18
00:01:18,080 --> 00:01:20,384
等等等这个非常重要

19
00:01:20,640 --> 00:01:21,920
好

20
00:01:22,944 --> 00:01:29,088
首先有一些图示是在屏幕上哈卡比较

21
00:01:31,136 --> 00:01:35,744
截屏土豪包括后面我的程式码我看一下

22
00:01:36,768 --> 00:01:39,072
想这个东西直接截屏下来的

23
00:01:39,328 --> 00:01:44,448
为什么呢因为我要使用这一个开发环境底下的这一些又有行号

24
00:01:44,704 --> 00:01:50,848
而颜色更容易看似他截屏下来的效果就没有非常清楚

25
00:01:51,104 --> 00:01:55,456
不像每一张自己做的投影片那么清楚吧我想

26
00:01:55,712 --> 00:01:56,992
可谓你在

27
00:01:57,248 --> 00:02:00,832
目前看似还是OK的

28
00:02:01,088 --> 00:02:01,856
好

29
00:02:02,880 --> 00:02:09,024
现在我回来前面刚刚这一来我们先谈一谈分类容器的分类

30
00:02:09,280 --> 00:02:09,792
累

31
00:02:10,048 --> 00:02:12,096
大致上分为两种

32
00:02:12,352 --> 00:02:18,496
一个叫做sequence containers循序序列是sequence序列是

33
00:02:18,752 --> 00:02:21,312
一种叫做20天呢

34
00:02:21,824 --> 00:02:26,688
就是一种关联式容器什么叫关联式的容器呢

35
00:02:26,944 --> 00:02:29,248
它的元素是由器跟

36
00:02:30,272 --> 00:02:33,344
Gta3什么他就是他的代表关键词吧

37
00:02:33,600 --> 00:02:39,744
再用气来找编就就很好找所以这一种容器一定是非常

38
00:02:40,000 --> 00:02:41,024
非常适合作

39
00:02:41,280 --> 00:02:42,560
快速的

40
00:02:43,072 --> 00:02:43,840
查找

41
00:02:45,632 --> 00:02:48,448
那查找是很重要的事情啊就是电脑啊

42
00:02:49,984 --> 00:02:56,128
我记得早起我这次在很小时候然后电脑做什么用的呢人家都说

43
00:02:56,384 --> 00:02:58,176
电脑就是主要是

44
00:02:58,432 --> 00:03:02,016
放大量的资料以及很容易的去找东西

45
00:03:02,528 --> 00:03:07,136
排序排是为了查找方便当时我想说

46
00:03:07,392 --> 00:03:13,536
电脑这么尖端科技东西只是用来做这个吗这个好像是一个很简单的事情吗电脑好像

47
00:03:13,792 --> 00:03:19,936
是要拿来发射了太空船绕月球这种高深的技巧采用程序常要用电脑设计这门

48
00:03:20,192 --> 00:03:26,336
我用的吧后来发现还真不是啊比如说你看我们现在到机场到什么地方去做个社会上的格式

49
00:03:26,592 --> 00:03:29,408
确实就是一个排序按

50
00:03:29,664 --> 00:03:30,432
查找

51
00:03:31,456 --> 00:03:32,992
我要这里来说

52
00:03:34,784 --> 00:03:38,880
当提到分类有一种叫二手h containers

53
00:03:39,136 --> 00:03:43,488
他用气来找东西就非常快

54
00:03:44,512 --> 00:03:50,656
刚刚从找东西这件事情上谈到我过去的一些小孩子的时候一些不成熟的想法

55
00:03:50,912 --> 00:03:57,056
OK我现在另外呢这边还有一个分类这张图从哪里来自然数不是我画了这本书

56
00:03:57,568 --> 00:04:01,664
这个数就是前面提的那个16a library那么出

57
00:04:01,920 --> 00:04:03,968
抓出来的

58
00:04:04,224 --> 00:04:10,368
他把这个容器除了刚刚讲的这两种是吧还有第3种叫啊

59
00:04:10,624 --> 00:04:16,768
Containers这个是现在在这个红色框框起来是细节的

60
00:04:17,024 --> 00:04:23,167
Eleven财新出现的一种容器即使他被他之前已经有前生了就

61
00:04:23,423 --> 00:04:29,567
等一下再说清除线但是我认为在这个图里面

62
00:04:29,823 --> 00:04:35,967
以便制作者把这样分成三队不是一个好的分法其实这个安区的container就

63
00:04:36,223 --> 00:04:40,319
就是一种手机APP也就是一种观点是种气

64
00:04:43,135 --> 00:04:44,415
好吃吃

65
00:04:44,671 --> 00:04:50,815
这样吧我不知道这个出来讲但是个covid-19 tennis他的意思是这样

66
00:04:51,071 --> 00:04:53,375
Wizard大礼是什么意思呢

67
00:04:53,631 --> 00:04:59,007
我左思右想把他如果用中文把它称呼叫不定序

68
00:05:00,799 --> 00:05:01,823
元素

69
00:05:02,847 --> 00:05:08,991
走容器这个表现就蛮好了说不定不定旭

70
00:05:09,247 --> 00:05:15,391
他在元素放进来在这个容器里面没有一定的刺去一曲这一刻在这个的

71
00:05:15,647 --> 00:05:21,791
第3个位置上倒了一个小时之后来由于一些动作使它变成为什么掉了

72
00:05:22,047 --> 00:05:24,607
这叫不定去on over

73
00:05:26,911 --> 00:05:32,543
好先解释这个名字这样其实它就是一种hash table了用hash table做了

74
00:05:32,799 --> 00:05:35,103
容器底部就可以这么做

75
00:05:35,615 --> 00:05:41,759
好所以告诉我来分类呢我还是会分成Secrets container hospital

76
00:05:42,015 --> 00:05:43,551
就这两种

77
00:05:44,063 --> 00:05:46,879
好我们先看6com间的你都有什么

78
00:05:47,391 --> 00:05:49,695
一种就是锐就是数组

79
00:05:50,719 --> 00:05:56,863
Crc加语言本来就有数组这种东西它是语言的一部分

80
00:05:57,119 --> 00:05:58,399
现在的CC

81
00:05:58,655 --> 00:06:04,287
11c下Java这个时间开始把它也变成一个class

82
00:06:05,055 --> 00:06:11,199
在这个图里面红色圈起来的就是cplusplus说相增加了

83
00:06:11,455 --> 00:06:14,527
而我们现在谈到了这个位

84
00:06:15,807 --> 00:06:18,111
是把语言的数组

85
00:06:18,367 --> 00:06:18,879
变

86
00:06:19,647 --> 00:06:21,951
包装成一个class

87
00:06:22,975 --> 00:06:29,119
Norway大家都已经我猜想大家都用过了欧瑞士怎么样就是一个连续空

88
00:06:29,375 --> 00:06:35,519
空间你当初要多大他就多大比如说你要100000个元素时

89
00:06:35,775 --> 00:06:41,919
100000个整数那他就是那么大你只用了1000大还是100000你要是用到

90
00:06:42,175 --> 00:06:46,527
到的100000 01就不能用了因为他不够远不够内存

91
00:06:48,063 --> 00:06:50,879
只是简单把它包子一个可拉斯

92
00:06:51,135 --> 00:06:57,279
所以各位看这个图画的很好啊他前面跟后面是没有办法扩充的

93
00:07:23,647 --> 00:07:25,695
我就不够说它会自动增长

94
00:07:26,463 --> 00:07:28,255
这个自动增长谁来做呢

95
00:07:28,511 --> 00:07:33,375
我们前面讲过容器背后有个分配器在帮他处理内存的事情

96
00:07:33,631 --> 00:07:37,983
内存分配器会自动做这个事我们不要管他

97
00:07:38,239 --> 00:07:42,335
我们只要安心我们就是安心的把元素一个一个的放进去

98
00:07:42,591 --> 00:07:44,383
他会自动扩充

99
00:07:44,895 --> 00:07:46,175
这个箭头的意思

100
00:07:46,687 --> 00:07:47,711
自动扩充

101
00:07:49,759 --> 00:07:51,807
第3种叫做

102
00:07:52,063 --> 00:07:52,831
Sex

103
00:07:53,855 --> 00:07:55,135
这个呢

104
00:07:55,391 --> 00:08:01,535
你会习惯变成的Q因为q是你

105
00:08:01,791 --> 00:08:04,095
水果的名词吗就这个队列

106
00:08:04,863 --> 00:08:06,143
这就是双

107
00:08:06,655 --> 00:08:12,799
队列本来是什么先进先出先进先出排队吗谁先排

108
00:08:13,055 --> 00:08:16,383
谁就先上车先进先出吗

109
00:08:17,919 --> 00:08:18,431
而

110
00:08:18,687 --> 00:08:19,199
而

111
00:08:19,455 --> 00:08:24,831
你如果把内存的Q也没错啊一就是双就双向的队列

112
00:08:25,343 --> 00:08:27,135
两端可进可出

113
00:08:28,159 --> 00:08:33,791
两端可进可触及这个图画的也非常的形象非常好他的前头跟后头

114
00:08:34,047 --> 00:08:35,071
都是可以扩充的

115
00:08:37,119 --> 00:08:37,887
不过

116
00:08:38,143 --> 00:08:40,447
西方人面faq

117
00:08:40,959 --> 00:08:47,103
那我们也叫做好了就不念的Q1上他的Q

118
00:08:49,407 --> 00:08:50,687
这个非常好啊

119
00:08:51,199 --> 00:08:56,063
韩信这么大比例的另外一端还可以扩充但是如果你从

120
00:08:56,319 --> 00:08:59,647
技术的角度去想他的话你想不通

121
00:09:00,159 --> 00:09:05,279
怎么可能有一个内存它是后头也可以扩充钱退给我中呢

122
00:09:06,815 --> 00:09:08,095
你想不通为什么

123
00:09:08,607 --> 00:09:09,887
飞龙有到后面我们

124
00:09:10,399 --> 00:09:16,287
再继续使用它的时候有另外一张图告诉你它实际是怎么做的

125
00:09:19,615 --> 00:09:20,895
下面这个容器

126
00:09:21,919 --> 00:09:23,199
手机的人就多了

127
00:09:23,967 --> 00:09:25,759
叫做链表

128
00:09:26,783 --> 00:09:32,927
这里的每一个一个元素那他并没有连续的话在一起的画得非常好并没有联系

129
00:09:33,183 --> 00:09:33,695
去的话

130
00:09:33,951 --> 00:09:39,327
中间都是用指针串起来而且这个指针呢是双向

131
00:09:39,839 --> 00:09:41,119
所以这个list

132
00:09:41,631 --> 00:09:47,263
标准库提供给我们的链表这个容器它是一个双向链表

133
00:09:49,823 --> 00:09:52,383
事实上我去看过他的源代码

134
00:09:52,639 --> 00:09:55,455
它是一个双向环状链表

135
00:09:55,967 --> 00:10:02,111
不过这个环状只是为了制作上的一个便利性法在在使用上它的功能上

136
00:10:02,367 --> 00:10:04,415
你只要知道还是双向的

137
00:10:07,231 --> 00:10:09,023
下面这个是新增加的

138
00:10:09,279 --> 00:10:10,559
红色的

139
00:10:10,815 --> 00:10:11,839
C99

140
00:10:12,095 --> 00:10:16,447
现增加了这个叫单向链表丈夫earliest

141
00:10:17,471 --> 00:10:23,615
所以这个里头每一个元素的中间的这个指针只有单向只有一根指数

142
00:10:24,383 --> 00:10:27,199
你当然可以从这个图里就可以拖一下

143
00:10:27,967 --> 00:10:29,759
如果你选择的是list

144
00:10:31,807 --> 00:10:37,439
你所耗用的内存绝对比你选择玻璃子的要多

145
00:10:37,951 --> 00:10:44,095
因为它是两根子每一个元素带着两根指针下面这个每个元素只带一根指针

146
00:10:44,607 --> 00:10:45,631
一个指针

147
00:10:46,143 --> 00:10:48,447
善用四个拜四个字节

148
00:10:48,703 --> 00:10:51,775
在32位电脑上的占四个字节

149
00:10:52,799 --> 00:10:54,847
所以如果你有100万个元素

150
00:10:55,615 --> 00:10:58,943
它占用的就多出哪些东西可以算出来

151
00:11:00,735 --> 00:11:06,879
会从内存的角度来想你当然要去考虑如果我其实只需要单向转链表

152
00:11:07,135 --> 00:11:12,255
表的话我就选first就可以了那我可以放更多的元素进去

153
00:11:12,511 --> 00:11:14,303
直到直到宝宝电脑的

154
00:11:15,327 --> 00:11:21,471
计算机上面的内存用汪维持动态一个一个人放了一个分配

155
00:11:21,727 --> 00:11:23,007
一个空间来访

156
00:11:26,591 --> 00:11:28,639
好下面这个图

157
00:11:30,175 --> 00:11:33,759
其实就是表示分类似的这两个读意思是一样

158
00:11:34,015 --> 00:11:40,159
老子是下面这个图形象更好一些左手边有一个挡住的东西而不像

159
00:11:40,415 --> 00:11:42,719
像上面这个图好像不要从什么地方开始

160
00:11:43,487 --> 00:11:45,535
其实是表示一样的意思

161
00:11:46,559 --> 00:11:52,703
这一为从刚刚讲的味道that the bags of words

162
00:11:52,959 --> 00:11:56,031
呼叫做secretfolder循序是

163
00:11:56,543 --> 00:11:58,079
他们

164
00:11:58,335 --> 00:12:00,639
有一定的次序怎么次序就是

165
00:12:01,663 --> 00:12:04,223
就是按照你放进去的

166
00:12:04,735 --> 00:12:05,503
死去

167
00:12:05,759 --> 00:12:08,575
来排列

168
00:12:13,951 --> 00:12:14,463
好

169
00:12:14,975 --> 00:12:16,767
我们来看一看

170
00:12:17,023 --> 00:12:18,559
对于要大量

171
00:12:19,071 --> 00:12:20,095
查找

172
00:12:21,631 --> 00:12:23,167
把这种动作来讲

173
00:12:24,447 --> 00:12:28,287
最有价值的就是

174
00:12:29,567 --> 00:12:35,711
它的底部是用什么做的呢他表现在我们给我们在使用的时候有两种东西

175
00:12:35,967 --> 00:12:36,991
Except

176
00:12:39,295 --> 00:12:42,111
就是集和那个set

177
00:12:43,135 --> 00:12:47,999
但我们不要想像是集合数学那个集合反正这种东西叫什

178
00:12:48,255 --> 00:12:50,047
另外一种叫map

179
00:12:50,815 --> 00:12:56,959
Happy不是什么做的这个图告诉你看起来像是竖吹没错这是一个2

180
00:13:31,007 --> 00:13:35,615
他总是左右差不多平和他自己会做

181
00:13:35,871 --> 00:13:37,407
所以我再讲一次

182
00:13:38,431 --> 00:13:40,223
在标准库

183
00:13:40,991 --> 00:13:41,759
一头

184
00:13:42,783 --> 00:13:47,903
并没有规定SAT或者是Map应该用什么来

185
00:13:48,671 --> 00:13:49,951
实现

186
00:13:50,207 --> 00:13:50,975
办事

187
00:13:51,231 --> 00:13:53,279
由于红黑树非常好

188
00:13:53,535 --> 00:13:59,679
所以各家编译器所带的标准库都用红黑

189
00:13:59,935 --> 00:14:02,495
数来做site map

190
00:14:02,751 --> 00:14:04,799
就是你现在图上所看到的这个样子

191
00:14:06,591 --> 00:14:12,735
Sitemap的差别在哪里呢因为看到Map的每一个节点有两个

192
00:14:12,991 --> 00:14:15,039
东西就是T有什么样的

193
00:14:15,807 --> 00:14:20,671
将来要找东西的时候就用气来找别的每一个节点有几公里

194
00:14:21,439 --> 00:14:22,975
而sitema

195
00:14:23,487 --> 00:14:27,583
注意cited the key就是哪里来的就是

196
00:14:28,863 --> 00:14:31,423
这个没有是不分的

197
00:14:33,727 --> 00:14:37,823
另外还有叫做marcus martinez march

198
00:14:38,079 --> 00:14:44,223
西方人用什么面膜台查查查查这个这个这个音标的因为

199
00:14:44,479 --> 00:14:45,247
March

200
00:14:45,503 --> 00:14:49,855
太清楚我喜欢你妈trt set map

201
00:14:51,135 --> 00:14:52,159
发帖就是多

202
00:14:53,183 --> 00:14:53,695
所以

203
00:14:54,719 --> 00:14:56,255
这个如果你选的是

204
00:14:56,511 --> 00:14:59,839
Set表示你放的元素不能重复

205
00:15:00,863 --> 00:15:07,007
你如何选Map也是里面的元素的key不能重复

206
00:15:07,263 --> 00:15:11,359
但是如果你选multiset或者什么平面表示

207
00:15:11,615 --> 00:15:12,639
寄给中国

208
00:15:13,919 --> 00:15:18,527
比如说你现在要把全校3000个学生的

209
00:15:19,295 --> 00:15:21,087
资料都放到一个

210
00:15:22,111 --> 00:15:23,903
一个一个容器去

211
00:15:25,183 --> 00:15:25,951
那

212
00:15:26,719 --> 00:15:31,327
每个人应该有个独一无二的什么东西呢学号

213
00:15:31,583 --> 00:15:34,911
过敏什么要身份证是都是独一无二的

214
00:15:35,679 --> 00:15:39,263
你就可以去这时候你就可以选择set

215
00:15:43,103 --> 00:15:44,639
我认为你应该选面

216
00:15:45,151 --> 00:15:48,223
然后把身份证或者是雪号当成气

217
00:15:48,991 --> 00:15:51,039
然后这个学生的各种身份

218
00:15:51,295 --> 00:15:56,927
他的姓名和地址落成暨亚当成量程为零

219
00:16:01,791 --> 00:16:06,655
这次情况是因为这个学校的学生不可能学好重复

220
00:16:07,423 --> 00:16:12,287
所以你如果把重复东西放进去它会反弹回来这个容器会反弹回来

221
00:16:12,543 --> 00:16:13,823
不能放进去

222
00:16:14,847 --> 00:16:15,871
这是好事情

223
00:16:17,663 --> 00:16:18,943
但是如果

224
00:16:19,199 --> 00:16:25,343
你要放的东西他不是有定不是独一无二的它是可能重复的你就不能够

225
00:16:25,599 --> 00:16:30,719
你就要去

226
00:16:30,975 --> 00:16:32,767
怎么P的意义就在这里

227
00:16:33,279 --> 00:16:36,863
内容是元素的内容是可以重复

228
00:16:43,007 --> 00:16:44,031
宝宝老是自己种

229
00:16:45,055 --> 00:16:50,431
An alternate containers我刚提过它确实也是一种关联是的

230
00:16:50,687 --> 00:16:53,247
资料库关联式的容器

231
00:16:54,271 --> 00:16:56,063
这个图

232
00:16:57,599 --> 00:16:58,367
不够好

233
00:16:59,647 --> 00:17:03,743
他所表现出来的就是说这些元素是事

234
00:17:03,999 --> 00:17:05,279
吃饭饭的

235
00:17:05,535 --> 00:17:08,863
没有定性的排列

236
00:17:09,375 --> 00:17:12,703
只是这样而已可是没有办法告诉你到底是

237
00:17:13,471 --> 00:17:14,239
用什么

238
00:17:14,751 --> 00:17:17,055
只要结构数据结构做出来的

239
00:17:18,591 --> 00:17:21,151
正右边这个图才是对的还是更好的

240
00:17:22,175 --> 00:17:24,735
这个图表现出来我这边加了一些字啊

241
00:17:24,991 --> 00:17:26,783
其实这就是一个hashtable

242
00:17:28,831 --> 00:17:33,183
Hashtable是一个很有趣的东西

243
00:17:34,975 --> 00:17:39,583
如果你没有我这个基础没有关系很容易懂的

244
00:17:39,839 --> 00:17:40,863
你看这个图

245
00:17:42,143 --> 00:17:43,423
看起来就是

246
00:17:43,935 --> 00:17:44,447
有

247
00:17:44,703 --> 00:17:47,007
有一些在我们把这个篮子

248
00:17:47,519 --> 00:17:52,895
花姐一个一个篮子没然上面一个篮子里面有多少元素呢

249
00:17:53,663 --> 00:17:56,735
这是用指针在表现所以这是一个链表

250
00:17:57,247 --> 00:17:59,551
一个篮子代表一串电表

251
00:18:00,831 --> 00:18:05,183
电表上面有多少个元素既然是链表就可以无限多

252
00:18:06,207 --> 00:18:10,303
链表啊你要加几个就加了动态的那个巨贾

253
00:18:12,095 --> 00:18:16,959
一个黑黑豹这个数据结构的长相就是这样

254
00:18:17,471 --> 00:18:23,615
其实hashtable的有不同的做法但是现在被大家公

255
00:18:23,871 --> 00:18:25,151
乌镇最好的做法

256
00:18:25,663 --> 00:18:31,807
也是所有cplusplus标准库实坐上都采用了这种做法是什么做法呢

257
00:18:32,063 --> 00:18:35,391
Hash table里面的separately

258
00:18:35,647 --> 00:18:37,695
也就是现在画面上看这种做法

259
00:18:40,767 --> 00:18:43,583
我可以对这个世界不再多说

260
00:18:43,839 --> 00:18:45,887
鞋52

261
00:18:46,143 --> 00:18:49,727
Hashtable即使是你现在有

262
00:18:50,239 --> 00:18:51,775
不是有

263
00:18:52,031 --> 00:18:54,079
20块空间好了

264
00:18:54,591 --> 00:18:56,127
你放一些元素进去

265
00:18:56,895 --> 00:18:58,175
这个元素啊

266
00:18:58,943 --> 00:19:04,063
要根据一些计算决定他开放到20个里面的第几个

267
00:19:05,599 --> 00:19:06,367
如果

268
00:19:06,879 --> 00:19:09,439
元素a放到第3个位置去

269
00:19:10,463 --> 00:19:15,583
元素x的1元素一算一算也要放到第3个这不就碰撞了吗

270
00:19:16,351 --> 00:19:21,215
有两个元素都要放到第3个位置去这样做不可以就碰撞

271
00:19:21,983 --> 00:19:24,543
碰撞怎么办那就把它分开

272
00:19:26,847 --> 00:19:32,991
聪明的科学家就会算设计一些函数把它分开来的一个

273
00:19:33,247 --> 00:19:35,295
一个放大第3个

274
00:19:36,063 --> 00:19:41,951
Abcde一野方也应也放在第3个测试并把它分开来让它放到第7个去

275
00:19:42,463 --> 00:19:42,975
像这样

276
00:19:43,487 --> 00:19:45,279
这个就是hashtable的意思

277
00:19:47,327 --> 00:19:53,471
它是这个硬把它分开来放了总是最后大家归纳出来说不够理想最后才

278
00:19:53,727 --> 00:19:54,495
发展出

279
00:19:54,751 --> 00:19:56,799
图上所说的surprise US China

280
00:19:57,311 --> 00:20:03,199
既然碰撞是吗好那碰撞就大家都放在同一个篮子里都好了男子是一个链表

281
00:20:03,711 --> 00:20:07,551
碰上没关系你们都放在第3号313号是个链表

282
00:20:08,575 --> 00:20:11,391
这就是谁的权力的做法

283
00:20:13,439 --> 00:20:17,535
目前最好的最被大家采用的黑色的做法

284
00:20:20,863 --> 00:20:21,887
不过呢

285
00:20:22,399 --> 00:20:23,167
如果

286
00:20:23,935 --> 00:20:26,239
碰撞的次数太多

287
00:20:27,519 --> 00:20:33,663
Express这个Server training里面的一个8G的一个男子太长了个链表

288
00:20:33,919 --> 00:20:34,687
太差

289
00:20:35,711 --> 00:20:39,551
链表的查找是搜寻大查找他是

290
00:20:39,807 --> 00:20:40,831
速度慢

291
00:20:41,087 --> 00:20:42,367
他必须一个一个澡

292
00:20:43,391 --> 00:20:49,535
飞串如果有1000000的话你可以想象在最坏的情况下早想要找到最后一个的100万个才是你的目标

293
00:20:49,791 --> 00:20:51,583
这个速度不得了

294
00:20:52,351 --> 00:20:54,911
啊这这个世界不得了速度太慢

295
00:20:56,191 --> 00:20:56,959
所以

296
00:20:57,215 --> 00:20:57,983
一定

297
00:20:58,239 --> 00:20:58,751
这个

298
00:21:00,287 --> 00:21:01,055
每一个

299
00:21:01,311 --> 00:21:05,407
Pocket男子桶子链表不能太差

300
00:21:05,919 --> 00:21:11,807
这几天就会有一些他的一些法则如果太长的话就要再把它重新打散等等等

301
00:21:13,599 --> 00:21:17,184
这是我在利用这个时间多说一点微薄的事情

302
00:21:20,000 --> 00:21:22,048
好我们做一个整理啊

303
00:21:22,560 --> 00:21:24,608
所有的容器分为sequence

304
00:21:24,864 --> 00:21:27,424
Associative pla

305
00:21:29,216 --> 00:21:33,056
每种容器在内存里面的长相

306
00:21:33,312 --> 00:21:36,128
而元素之间是怎么排列怎么关联的

307
00:21:36,384 --> 00:21:37,408
这些图表现的

308
00:21:37,920 --> 00:21:39,200
算是相当好了

309
00:21:41,760 --> 00:21:44,320
这就是他的分类机构

310
00:21:49,696 --> 00:21:50,976
马上我们就要

311
00:21:51,488 --> 00:21:52,512
有一个城市

312
00:21:52,768 --> 00:21:53,280
来

313
00:21:54,304 --> 00:21:59,424
带大家去看看这一些容器的一些限制

314
00:21:59,936 --> 00:22:01,984
效率上的表现

315
00:22:09,408 --> 00:22:12,224
现在你所看到从这里下的每一夜

316
00:22:12,992 --> 00:22:16,576
这是我在最前面说回复给大家的那个叫test

317
00:22:16,832 --> 00:22:19,136
STL点cpp

318
00:22:20,416 --> 00:22:21,696
完整的程序

319
00:22:22,720 --> 00:22:25,024
我并没有把这个

320
00:22:25,280 --> 00:22:26,304
爱吗

321
00:22:27,072 --> 00:22:30,144
放到这个投影片上我是用copy

322
00:22:30,400 --> 00:22:32,192
屏幕截图的方式

323
00:22:32,448 --> 00:22:36,800
我刚刚我也提过了因为我这个在这个我的开发环境底下呢

324
00:22:37,824 --> 00:22:41,664
直接硬拷过来就可以有好好也有颜色比较好看

325
00:22:43,968 --> 00:22:44,480
好

326
00:22:47,040 --> 00:22:50,880
一开始我这边在这夜现在的的19页这个地方啊

327
00:22:51,136 --> 00:22:57,280
列了四个函数出来这是后面要用到都非常的简单我要

328
00:22:57,536 --> 00:22:58,816
我要先做个说明

329
00:23:00,864 --> 00:23:03,168
左上角的输入函数

330
00:23:03,936 --> 00:23:05,728
ITS Target long

331
00:23:06,496 --> 00:23:07,520
是要

332
00:23:07,776 --> 00:23:08,288
用

333
00:23:08,800 --> 00:23:13,920
交互式交谈的方式让我我是使用者输入一个

334
00:23:14,432 --> 00:23:16,224
要找的目标

335
00:23:16,736 --> 00:23:18,784
因为后面所有的容器

336
00:23:20,064 --> 00:23:26,208
我可以选择用哪一种东西我在做测试为了方便起见我可以用1234

337
00:23:26,464 --> 00:23:30,048
45678的外号让我选择用哪一种容器

338
00:23:30,560 --> 00:23:35,936
你会你也会看到这个程序你把它编译过之后呢你也可以这样子执行

339
00:23:36,192 --> 00:23:38,496
选择用哪一个容器

340
00:23:39,008 --> 00:23:40,544
然后他又会问你

341
00:23:41,312 --> 00:23:43,104
你要放多少个元素

342
00:23:43,360 --> 00:23:46,432
我都是放50万100万这种数量级

343
00:23:46,688 --> 00:23:47,456
机票

344
00:23:48,736 --> 00:23:51,296
然后他就用乱数的方式

345
00:23:52,576 --> 00:23:54,624
从0到32767

346
00:23:55,136 --> 00:24:00,256
乱扔的随机数据是一个数当成元素方面去

347
00:24:01,792 --> 00:24:03,328
浦东方地狱之后呢

348
00:24:04,352 --> 00:24:07,424
这个程序会告诉我他花了多少时间

349
00:24:07,936 --> 00:24:08,704
多少

350
00:24:08,960 --> 00:24:11,008
Mikrotik几维鸟

351
00:24:12,288 --> 00:24:15,360
叫我就可以对于这个效率有一些概念

352
00:24:16,384 --> 00:24:18,688
然后这个程序就会问我

353
00:24:19,200 --> 00:24:21,504
你想要找哪一个元素啊

354
00:24:21,760 --> 00:24:23,296
从零到三个767

355
00:24:25,088 --> 00:24:31,232
我就允许我打一个数字进去那现在你看的这一个15号这个数就是了

356
00:24:31,488 --> 00:24:33,024
Get along target

357
00:24:33,792 --> 00:24:34,560
他的问

358
00:24:35,328 --> 00:24:37,120
然后我把它输入进去

359
00:24:37,376 --> 00:24:39,680
这样就得到了一个我要找的目标

360
00:24:41,216 --> 00:24:46,080
下面这个函数呢24号开始这个get started trip

361
00:24:46,336 --> 00:24:51,712
我也要说一个目标但是这个目标不是一个long不是一个数值是一个数

362
00:24:52,736 --> 00:24:54,784
而这是因为我在

363
00:24:55,040 --> 00:24:56,320
这个例子里头

364
00:24:57,088 --> 00:25:01,952
放到元素放到容器里的元素其实不是数值

365
00:25:02,464 --> 00:25:04,512
我刚刚说他会用

366
00:25:05,024 --> 00:25:05,792
随机数

367
00:25:06,048 --> 00:25:11,424
得到一个数值放进去可是我把那个数值转换成一个字符串

368
00:25:12,960 --> 00:25:17,312
为什么要做这样的设计我要让你感受到我放的是一个Object

369
00:25:19,104 --> 00:25:21,408
咱这里都可能有波音响右指针

370
00:25:22,176 --> 00:25:28,320
是个比较复杂东西不只单纯的一个数字而已在你现实生活中你再用容器

371
00:25:28,576 --> 00:25:29,856
你可能不是

372
00:25:30,112 --> 00:25:31,904
我想你不会只是放数值

373
00:25:32,160 --> 00:25:32,928
Value

374
00:25:34,208 --> 00:25:37,536
你可能放上次我要摸你的情况给你看

375
00:25:39,584 --> 00:25:41,632
所以我放了都是自

376
00:25:41,888 --> 00:25:42,912
串

377
00:25:43,680 --> 00:25:49,824
所以从第2次行那我要取得一个搜寻目标的目标是一个子穿

378
00:25:50,592 --> 00:25:52,128
要是一个问答的方式

379
00:25:53,152 --> 00:25:59,296
这里面上一个函数差别在哪里你31 31 31

380
00:26:00,832 --> 00:26:01,344
华

381
00:26:01,600 --> 00:26:05,184
打进去的这一个数值转换为止

382
00:26:05,696 --> 00:26:08,512
选用的是SM printf这个数

383
00:26:09,536 --> 00:26:11,840
我就不解释他了先去

384
00:26:12,096 --> 00:26:13,888
查一下很容易找到

385
00:26:16,192 --> 00:26:19,264
C函数C标准库里的一本书

386
00:26:20,800 --> 00:26:26,944
他右手边这里这两个函数叫什么

387
00:26:27,200 --> 00:26:29,760
在比较两个弄

388
00:26:32,576 --> 00:26:34,624
两个字符串等不到

389
00:26:35,648 --> 00:26:36,928
这是为了

390
00:26:37,184 --> 00:26:40,256
后面在某些时候我要用到

391
00:26:40,512 --> 00:26:41,536
Quicksort

392
00:26:41,792 --> 00:26:43,072
快速排序法

393
00:26:43,840 --> 00:26:49,984
稀有一个方学校qsort就是快速排序把它要求我们

394
00:26:50,496 --> 00:26:51,520
告诉他

395
00:26:51,776 --> 00:26:53,568
给它一个函数

396
00:26:54,080 --> 00:26:55,360
下来比大小

397
00:26:56,640 --> 00:26:58,432
我就按照这个规格

398
00:26:59,200 --> 00:27:02,272
传禁区内跟B如果a

399
00:27:02,784 --> 00:27:03,808
如果

400
00:27:04,576 --> 00:27:06,368
这里有两个函数啊

401
00:27:06,880 --> 00:27:09,440
比较论是比较子串

402
00:27:10,464 --> 00:27:12,000
都传进a b

403
00:27:12,256 --> 00:27:13,024
两个

404
00:27:13,792 --> 00:27:14,304
参数

405
00:27:15,584 --> 00:27:16,608
A比较大

406
00:27:16,864 --> 00:27:17,888
叫*唯一

407
00:27:18,656 --> 00:27:20,448
你叫小舅船回复1

408
00:27:20,704 --> 00:27:24,032
香港就成为0这个只要你去查一下Siri

409
00:27:25,312 --> 00:27:31,456
标准库出售迪qx50 qsort这个函数

410
00:27:31,712 --> 00:27:32,736
你就会找到

411
00:27:33,248 --> 00:27:34,016
规定

412
00:27:34,272 --> 00:27:36,320
我就是找这个规定

413
00:27:36,832 --> 00:27:41,184
A跟B两个相比较好穿回政治和赋值或者是0

414
00:27:42,464 --> 00:27:43,232
好

415
00:27:47,840 --> 00:27:50,656
好上这门课你将会得到这个

416
00:27:51,168 --> 00:27:53,984
整个城市所以这个画面上如果不是

417
00:27:54,496 --> 00:27:56,288
太清楚时间

418
00:27:56,544 --> 00:27:57,312
下次过去

419
00:27:57,824 --> 00:28:00,384
你可以看你手上的东西

420
00:28:01,664 --> 00:28:02,432
慢慢的体会

421
00:28:02,688 --> 00:28:05,760
好我要去一讲下去了

422
00:28:07,040 --> 00:28:07,808
还是

423
00:28:08,832 --> 00:28:11,136
我使用容器这个就是执行结果

424
00:28:13,952 --> 00:28:14,464
这个

425
00:28:15,744 --> 00:28:17,024
看一开始他们问

426
00:28:17,280 --> 00:28:23,424
这是在主程序面里面他们问让我选择12345678不是那部分我就不打在

427
00:28:23,680 --> 00:28:24,448
这个

428
00:28:24,704 --> 00:28:25,728
会看上了

429
00:28:26,752 --> 00:28:28,288
他问我选的是一

430
00:28:28,544 --> 00:28:31,872
一人就会记录到现在画面上是一个函数来

431
00:28:33,152 --> 00:28:34,944
这个函数叫test

432
00:28:35,200 --> 00:28:37,504
喂

433
00:28:38,528 --> 00:28:44,416
刚刚的那个图那我也把结出了一小部分瑞士长什么样子

434
00:28:46,208 --> 00:28:48,512
我们做什么事情我做什么事情呢

435
00:28:49,536 --> 00:28:53,376
这就是我们要学习了我要示范给你看了61行

436
00:28:54,912 --> 00:28:57,472
我需要一个位置怎么写

437
00:28:58,240 --> 00:29:00,288
我让里面放的都是露

438
00:29:00,800 --> 00:29:02,848
尖括号里的第1个参数是多

439
00:29:03,360 --> 00:29:08,480
必须有第2个参数告诉他说我要说啊

440
00:29:08,736 --> 00:29:12,064
这就好像你在COC在家里面你声明一个

441
00:29:12,320 --> 00:29:13,088
数组

442
00:29:13,600 --> 00:29:17,696
一定要知道一定要告诉他多大而且这个大不能是个变数

443
00:29:18,720 --> 00:29:19,488
这必须是一个

444
00:29:20,256 --> 00:29:21,280
定下地址

445
00:29:21,792 --> 00:29:27,936
在我这边呢e61行a side就是我前面的一个定义多少呢500000

446
00:29:29,728 --> 00:29:30,496
500000

447
00:29:31,520 --> 00:29:32,544
葛隆

448
00:29:32,800 --> 00:29:35,616
这么大的一个速度就是这样

449
00:29:37,920 --> 00:29:39,456
接下来

450
00:29:40,224 --> 00:29:40,992
我就

451
00:29:41,504 --> 00:29:43,296
For over 50万次

452
00:29:43,552 --> 00:29:45,088
就是40万次

453
00:29:46,880 --> 00:29:48,672
放什么东西进去呢

454
00:29:49,184 --> 00:29:50,208
放了一个

455
00:29:51,232 --> 00:29:52,000
随机数

456
00:29:52,512 --> 00:29:55,584
65 AMD这是C

457
00:29:55,840 --> 00:29:57,120
所提供的一个函数

458
00:29:58,144 --> 00:30:00,448
这个函数但如果你去插规格的话

459
00:30:00,704 --> 00:30:01,472
他会告诉你

460
00:30:01,728 --> 00:30:04,032
前面下是一个种子

461
00:30:04,544 --> 00:30:10,688
这个种子没有打在这个地方你所上的程序你往前看就会看到

462
00:30:10,944 --> 00:30:16,576
种子的我就是说目前的时间不知道现在时间你有时间的时候是几点

463
00:30:17,088 --> 00:30:19,648
几点几分几秒就到了中午

464
00:30:20,928 --> 00:30:24,000
水的65行就得到一个乱出一个随机数

465
00:30:24,512 --> 00:30:26,560
放到第I个元素去

466
00:30:26,816 --> 00:30:27,840
加一个form

467
00:30:28,352 --> 00:30:29,632
把全部放进去了

468
00:30:35,008 --> 00:30:40,128
我想知道这个放50万个随机数进去这个动作

469
00:30:40,640 --> 00:30:43,712
好用多少时间消耗多少时间

470
00:30:46,016 --> 00:30:48,320
怎么做这个时间呢很简单

471
00:30:50,368 --> 00:30:51,392
你就是三号

472
00:30:52,160 --> 00:30:52,672
汉

473
00:31:02,656 --> 00:31:04,192
63

474
00:31:04,704 --> 00:31:06,240
Clock love看一下

475
00:31:12,128 --> 00:31:13,920
看样子我并没有

476
00:31:14,176 --> 00:31:17,504
对于这个50万次的输入

477
00:31:18,016 --> 00:31:19,296
去做

478
00:31:20,064 --> 00:31:25,952
这个时间的检测不小心被我拿掉好那我这个等下再讲因为后面还是会去检测时间的

479
00:31:26,208 --> 00:31:31,840
这是500000次做完之后呢从p67行道的71号

480
00:31:32,352 --> 00:31:35,424
我就是犯罪提供了哪些

481
00:31:35,680 --> 00:31:37,728
函数给我们用哪些操作函数

482
00:31:37,984 --> 00:31:40,288
我呼叫site

483
00:31:40,800 --> 00:31:44,896
它的大小应该是500000那他输出结果的右上角

484
00:31:45,152 --> 00:31:46,688
黑色的这个背景那个

485
00:31:47,200 --> 00:31:49,248
Raid5的确是500000

486
00:31:51,552 --> 00:31:57,696
后面那下面那我再呼叫Friends come back from顾名思义就是第1个码头吗

487
00:31:58,208 --> 00:31:59,744
备可是最后一个

488
00:32:00,256 --> 00:32:03,072
我就把第1个跟最后一个打印出来看看

489
00:32:04,352 --> 00:32:10,496
有上涨的结果是3557更23084这些数字无疑因为这是一个随机数

490
00:32:12,800 --> 00:32:18,944
好我在吃饭可以呼叫飞达的71号

491
00:32:19,200 --> 00:32:25,344
这是这个函数会返回什么呢传回这一个数组在

492
00:32:25,600 --> 00:32:29,184
内存里面的起点的位地址

493
00:32:31,488 --> 00:32:32,000
一次

494
00:32:32,256 --> 00:32:33,792
传回来的结果是在

495
00:32:34,304 --> 00:32:37,376
16进位的47 a 20这个位置上

496
00:32:41,984 --> 00:32:44,800
好吃饭的这些操作之后

497
00:32:45,568 --> 00:32:47,104
接下来我做什么动作

498
00:32:48,128 --> 00:32:49,408
我要排序

499
00:32:50,432 --> 00:32:53,248
这些都是乱数我要把它拍一遍

500
00:32:55,552 --> 00:32:57,344
我选的是

501
00:32:58,368 --> 00:33:01,184
Quicksort 76号74

502
00:33:01,952 --> 00:33:04,256
那就去查一查他的规格数了

503
00:33:04,512 --> 00:33:08,864
导航到上面的前面我介绍三个网站非常容易找不到

504
00:33:09,120 --> 00:33:10,144
Accusoft

505
00:33:10,656 --> 00:33:12,960
他说你要放什么东西

506
00:33:13,472 --> 00:33:14,240
你要法

507
00:33:14,496 --> 00:33:19,360
你要这个数组的起点一直告诉他所以刚刚那个

508
00:33:20,384 --> 00:33:22,432
调用非法得到的只有用了

509
00:33:23,456 --> 00:33:24,480
其实壁纸

510
00:33:25,504 --> 00:33:28,320
多少个元素要告诉他50万个

511
00:33:30,112 --> 00:33:35,744
每一个元素是多大才告诉他我们每个人都是个龙所以放置sizeof用

512
00:33:37,536 --> 00:33:39,328
最后一个参数要告诉他

513
00:33:40,864 --> 00:33:42,144
怎么比大小

514
00:33:43,168 --> 00:33:44,704
Compare wrong

515
00:33:45,472 --> 00:33:48,288
就是刚刚我给你看的那个辅助函数

516
00:33:50,336 --> 00:33:55,200
在我们不过去上夜还是上上夜看比大小

517
00:33:59,552 --> 00:34:00,064
好

518
00:34:00,576 --> 00:34:06,208
这是第76行quicksort我想知道这50万个元素的受的

519
00:34:06,464 --> 00:34:10,560
花了多少时间以每一次执行都会不一样

520
00:34:10,816 --> 00:34:12,864
现在这边吃饭

521
00:34:13,120 --> 00:34:16,704
怎么样只知道一个动作所花掉的时间

522
00:34:16,960 --> 00:34:19,520
刚刚我们的动作犯罪76号

523
00:34:20,288 --> 00:34:23,104
所以在他的上扬75呢

524
00:34:23,360 --> 00:34:25,152
我就先取出

525
00:34:25,920 --> 00:34:26,944
目前的时间

526
00:34:27,712 --> 00:34:32,832
Clock这边用的都不是自己写的都是标准库提供的函数啊

527
00:34:33,088 --> 00:34:35,392
克拉克得到的是什么呢

528
00:34:35,904 --> 00:34:36,928
就是

529
00:34:37,184 --> 00:34:40,768
这个程序从运行开始到现在

530
00:34:41,280 --> 00:34:44,864
E75呼叫克拉克不死后的为描述

531
00:34:46,656 --> 00:34:48,192
Mikrotik为秒

532
00:34:49,472 --> 00:34:50,752
不是好表啊我一秒

533
00:34:54,848 --> 00:34:56,128
等一下好像是

534
00:34:56,896 --> 00:34:57,408
喂

535
00:34:57,664 --> 00:35:00,992
明明是个好苗子

536
00:35:04,064 --> 00:35:06,624
所以75行在执行到这里的时候

537
00:35:06,880 --> 00:35:12,000
这程序到这里就假设是100 100 100 100毫秒好了

538
00:35:13,792 --> 00:35:17,888
经过76行受到之后呢再的77行

539
00:35:19,168 --> 00:35:20,960
78 77号是

540
00:35:21,472 --> 00:35:24,544
Underscores刚刚没讲的这个先放着

541
00:35:31,200 --> 00:35:32,736
看一下这个程序

542
00:35:33,760 --> 00:35:34,272
龙

543
00:35:37,088 --> 00:35:38,368
时间时间

544
00:35:42,208 --> 00:35:44,256
OK的78号

545
00:35:45,536 --> 00:35:47,584
78行的后面

546
00:35:48,096 --> 00:35:50,656
78行是为了输出多少秒

547
00:35:50,912 --> 00:35:53,472
后面呢在呼叫一次clock

548
00:35:54,752 --> 00:35:57,568
那就是现在程序从开始到现在

549
00:35:57,824 --> 00:36:01,152
又花掉了多少时间刚刚如果是100

550
00:36:01,664 --> 00:36:07,808
毫秒的话现在是103号秒OK那我把103减100中间这个三

551
00:36:08,064 --> 00:36:09,344
三毫秒就是

552
00:36:10,112 --> 00:36:13,696
这两个时间检测中间

553
00:36:13,952 --> 00:36:14,976
好长时间

554
00:36:15,744 --> 00:36:19,072
别再看一次在的75行

555
00:36:19,840 --> 00:36:21,120
抓住时间了

556
00:36:21,632 --> 00:36:25,472
你78行的后面又抓一次时间

557
00:36:25,728 --> 00:36:29,312
并且剪掉刚刚的那个时间得到的就是

558
00:36:29,824 --> 00:36:31,360
消耗了多少

559
00:36:32,384 --> 00:36:34,176
秒多少毫秒

560
00:36:34,944 --> 00:36:38,528
这部被这辆行夹住的是什么动作呢

561
00:36:38,784 --> 00:36:41,088
76行quicksort

562
00:36:42,112 --> 00:36:43,904
汉77行

563
00:36:44,160 --> 00:36:45,440
Binary search

564
00:36:47,488 --> 00:36:52,096
所以意思就是在这个我放了一大堆500000个乱数之后

565
00:36:53,376 --> 00:36:59,520
我先把他说了一遍然后我就可以用binary Search二分查找法去找

566
00:36:59,776 --> 00:37:01,056
找一个我要

567
00:37:01,568 --> 00:37:02,336
目标

568
00:37:02,592 --> 00:37:04,896
我看看这样花掉了多少时间

569
00:37:06,432 --> 00:37:07,456
看刺青结果

570
00:37:09,760 --> 00:37:10,784
这边有一个问答

571
00:37:11,040 --> 00:37:15,392
当执行到这个被打是这个地址

572
00:37:16,928 --> 00:37:18,976
然后他问我这谁去问我

573
00:37:19,232 --> 00:37:25,376
你想找什么啊领到三个767你要找多少那只是我输入的我要打我要找

574
00:37:25,632 --> 00:37:27,424
20000

575
00:37:30,240 --> 00:37:31,520
结果算出来了

576
00:37:31,776 --> 00:37:32,544
找到了

577
00:37:33,312 --> 00:37:33,824
找到了

578
00:37:34,592 --> 00:37:36,384
花掉了187的

579
00:37:39,456 --> 00:37:42,528
也就是0.18 700

580
00:37:42,784 --> 00:37:44,832
1270点187秒

581
00:37:45,088 --> 00:37:49,184
50万次先排序之后再去找

582
00:37:49,696 --> 00:37:55,840
必须有这样的一个基础就什么呢你用binary Search二分查找法

583
00:37:56,096 --> 00:37:57,120
之前

584
00:37:57,376 --> 00:37:59,168
这些数据一定要排序数

585
00:37:59,680 --> 00:38:05,824
如果是一个乱的没办法用翻回去只能用sequence Search就是器

586
00:38:06,080 --> 00:38:07,616
循序查找那个非常慢

587
00:38:11,200 --> 00:38:14,528
所以在187的毫秒里面的

588
00:38:14,784 --> 00:38:18,880
有相当多的时间花在quicksort上

589
00:38:19,392 --> 00:38:21,696
至于binary Search应该是

590
00:38:23,744 --> 00:38:27,584
华润四季之前一定要会说这边不了

591
00:38:32,448 --> 00:38:33,472
各位体会一下

592
00:38:33,728 --> 00:38:35,264
我们在这个例子里面

593
00:38:35,520 --> 00:38:36,288
引用

594
00:38:37,568 --> 00:38:41,920
喂放58个元素是的去找其中的一个目标

595
00:38:48,064 --> 00:38:48,576
对了

596
00:38:49,088 --> 00:38:54,464
你要使用任何一个元素当然必须引入他的头文件

597
00:38:55,744 --> 00:38:57,536
51行最上面这里

598
00:39:02,400 --> 00:39:08,032
刚刚用到的这些quicksort binary Search他文件就知道了

599
00:39:08,288 --> 00:39:09,568
查文档不知道

600
00:39:09,824 --> 00:39:12,640
你要include cst dlib

601
00:39:15,200 --> 00:39:18,272
这是我所介绍的第1个容器
