1
00:00:06,912 --> 00:00:13,056
现在我们前面准备工作做好了终于可以进入算法

2
00:00:14,592 --> 00:00:19,712
这算法它需要知道迭代器的分类category

3
00:00:22,272 --> 00:00:27,136
先取标题上说这个分类对算法的影响

4
00:00:28,928 --> 00:00:30,720
我就先拿这个

5
00:00:31,232 --> 00:00:36,608
算法做例子这个算法叫distance如果你场

6
00:00:36,864 --> 00:00:43,008
规格书那你不一定会看到会和书法这个方程算法

7
00:00:46,080 --> 00:00:51,200
因为它不是那么直接的一线的给一般使用使用不是

8
00:00:52,224 --> 00:00:55,552
它可能是给其它的容器它的算法用的

9
00:00:56,064 --> 00:00:58,624
为它作为一个基础它非常重要

10
00:00:58,880 --> 00:01:00,672
他的效率非常重要

11
00:01:00,928 --> 00:01:04,512
Distance就是要知道

12
00:01:04,768 --> 00:01:10,400
两根指针的距离esters发射距离吗举罪

13
00:01:10,656 --> 00:01:15,008
Instance接受两个参数一个叫first

14
00:01:16,544 --> 00:01:17,824
Assess

15
00:01:19,360 --> 00:01:22,944
这两个之间的距离是怎么样

16
00:01:23,200 --> 00:01:29,344
你的直观想象就是相减了比如说现在有个数组成员的值

17
00:01:29,600 --> 00:01:33,696
是真正有个指针让人距离那相减就好了

18
00:01:34,720 --> 00:01:37,280
但这是这是连续空间才能这样

19
00:01:37,792 --> 00:01:42,144
所以这个instance

20
00:01:42,656 --> 00:01:44,192
哈

21
00:01:44,448 --> 00:01:45,984
在这张图里面

22
00:01:46,240 --> 00:01:52,384
我们可以看到我这边画出来他会去调用上面两个函数一根儿

23
00:01:53,664 --> 00:01:57,248
其中的二人一切就是香蕉

24
00:01:59,040 --> 00:02:03,136
为什么能相减呢因为2这个版本

25
00:02:03,648 --> 00:02:06,208
他有去判断

26
00:02:06,720 --> 00:02:12,864
这个iterator是是不是random-access连续空间才能够认真的是

27
00:02:14,656 --> 00:02:16,448
如果是random access

28
00:02:16,704 --> 00:02:18,752
的确她就会发剪头就好了

29
00:02:22,336 --> 00:02:24,128
但如果不是呢

30
00:02:24,384 --> 00:02:30,528
那就要跑到第1版本来这个怎么会跑到第2或跑到第1关键在这里这个怎么下载来说

31
00:02:30,784 --> 00:02:32,576
所以上面这个版本呢

32
00:02:34,368 --> 00:02:35,136
这里的

33
00:02:35,648 --> 00:02:39,488
写的是internet

34
00:02:41,536 --> 00:02:43,840
如果是这一种的话

35
00:02:44,352 --> 00:02:50,496
那这个头跟尾的距离就没有办法用剪的那怎么办呢那只好从头一步一步的

36
00:02:50,752 --> 00:02:55,616
我的走到尾巴看走几步就是这里的violet

37
00:02:56,384 --> 00:02:58,176
侯根尾不相等

38
00:02:58,432 --> 00:03:02,016
不相等的话头就家家走一步

39
00:03:02,272 --> 00:03:06,368
并且这边有个计数器恩恩也加加恩一开始设定

40
00:03:06,624 --> 00:03:12,000
一直走一直走到头尾相同之后看看这个恩是多少要传回

41
00:03:13,280 --> 00:03:17,376
那这就是两根也在其中间的距离

42
00:03:19,680 --> 00:03:25,312
在我们看到了这里有两个版本做法不太一样大幅度的影响了

43
00:03:25,568 --> 00:03:27,360
算法的效率

44
00:03:30,432 --> 00:03:32,736
在我们就要写出这两个版本出来

45
00:03:34,016 --> 00:03:35,040
然后这个

46
00:03:35,552 --> 00:03:38,112
对外界开放了这个函数

47
00:03:39,648 --> 00:03:45,792
先仔细的看看有一些是刚刚有没有讨论到的这个函数的返回类型是什么

48
00:03:46,048 --> 00:03:46,816
Return type

49
00:03:47,328 --> 00:03:50,400
我的随便写不能写作是个整数

50
00:03:52,192 --> 00:03:58,336
你如果去正是标准库的源代码要假设你就是作者的话你写整数

51
00:03:58,592 --> 00:04:02,688
也许在某一个时刻他是能不能够运作

52
00:04:03,712 --> 00:04:06,528
也许在某些极端情况不行

53
00:04:07,296 --> 00:04:13,440
说要融入到这个标准库里面的要注意的一些方方面面的小事情包括

54
00:04:13,696 --> 00:04:15,232
这一个地方

55
00:04:16,000 --> 00:04:20,095
两根指针的距离到底要用什么态度来表现

56
00:04:21,887 --> 00:04:23,679
我们前面讲过

57
00:04:24,191 --> 00:04:29,823
别大气的五个相应类型其中有一种叫做OpenStack

58
00:04:30,079 --> 00:04:36,223
剧里的该用什么态度来表现他的first time所以这里不要随便

59
00:04:36,479 --> 00:04:42,623
放这里要怎么样这里要问问这个trace萃取基请问1

60
00:04:43,903 --> 00:04:49,279
我现在传进来的这一个迭代器它的Freestyle是什么

61
00:04:50,047 --> 00:04:51,071
写出最好

62
00:04:51,327 --> 00:04:54,911
最好是问如果编译通过那也就是答案

63
00:04:55,423 --> 00:05:01,311
这个盘就放在这里这一整行就是这个instance的

64
00:05:02,079 --> 00:05:03,103
返回类型

65
00:05:05,919 --> 00:05:12,063
你在要什么库里面就是到处看到这一种可能看起来又臭又长

66
00:05:12,319 --> 00:05:16,159
那其实是非常规律非常严重的写法

67
00:05:18,975 --> 00:05:22,303
好进来之后呢这一个函数

68
00:05:22,559 --> 00:05:26,655
由于刚刚的分析他要往上调用两个版本怎么写的

69
00:05:28,191 --> 00:05:33,055
那就要知道传进来的分类category是什么呢

70
00:05:33,823 --> 00:05:37,407
再问一次再把传进来的这一种

71
00:05:37,919 --> 00:05:40,479
迭代器的类型丢给Treat

72
00:05:40,991 --> 00:05:45,855
所以说我们在第2讲话了不少时间讲话吗有给出Yes

73
00:05:46,111 --> 00:05:47,647
问你的

74
00:05:47,903 --> 00:05:49,183
Category是什么

75
00:05:49,439 --> 00:05:51,231
刚刚问的是difference_type

76
00:05:52,511 --> 00:05:54,047
这里问的是category

77
00:05:55,583 --> 00:05:57,631
这一种是问

78
00:05:57,887 --> 00:05:59,167
同时也是回答

79
00:05:59,423 --> 00:06:03,007
回到结果这么场换一个名字

80
00:06:04,287 --> 00:06:05,311
红色的这一个

81
00:06:06,591 --> 00:06:07,871
然后

82
00:06:08,639 --> 00:06:14,783
为了调用上面两个版本我们把红色的这一个建立一个创建一个

83
00:06:15,039 --> 00:06:16,319
一个临时对象

84
00:06:17,087 --> 00:06:23,231
这个语法又出现了说我刚刚有成就这个语法非常重要在看源代码或者

85
00:06:23,487 --> 00:06:29,631
或者是将来你收集人自己写应用程序都会出现这种语法它的name后面直接加小宝

86
00:06:29,887 --> 00:06:32,191
这是这是一个对象

87
00:06:33,727 --> 00:06:39,871
所以在这一行那等于是他往上调用这个名字就这样子吗

88
00:06:40,639 --> 00:06:44,735
随着这个浅蓝色的网上调用这两个版本

89
00:06:46,271 --> 00:06:52,415
机器怎么做啊这样谁呢你也不必管你也不必写出来你只要写我全心全意

90
00:06:52,671 --> 00:06:58,815
第3参数这个东西并气就自然而然的会根据你的第3参数

91
00:06:59,071 --> 00:07:02,399
什么而决定要调用上面的水

92
00:07:09,055 --> 00:07:10,079
这也叫做

93
00:07:10,591 --> 00:07:15,967
分类也在气分类对算法的影响在这里呈现出来了

94
00:07:17,503 --> 00:07:20,319
如果这个

95
00:07:20,575 --> 00:07:22,879
Distance

96
00:07:23,135 --> 00:07:29,279
所处理的这两根指针一个叫first一个叫last距离1000000的话你可以

97
00:07:29,535 --> 00:07:30,559
可以想象

98
00:07:31,583 --> 00:07:34,911
这两个版本的效率差别有多大

99
00:07:36,447 --> 00:07:37,727
这个第2版本

100
00:07:37,983 --> 00:07:40,031
尾巴剪头剪这结束

101
00:07:40,287 --> 00:07:43,103
这一版本能要走100万次

102
00:07:44,639 --> 00:07:50,783
才能确定下来有100美元差别如此

103
00:07:57,695 --> 00:08:03,839
我们在很多的算法里头能够看到长得像这样的

104
00:08:04,095 --> 00:08:05,119
结构

105
00:08:05,375 --> 00:08:08,959
算法本身是一个主函数

106
00:08:09,215 --> 00:08:12,287
里头会根据分类

107
00:08:12,799 --> 00:08:14,335
迭代器的分类

108
00:08:14,591 --> 00:08:20,735
调用不同的是函数上面这个是主函数上面这个

109
00:08:20,991 --> 00:08:22,527
这个呢是

110
00:08:22,783 --> 00:08:25,599
砍树

111
00:08:26,111 --> 00:08:28,927
很多很多的算法都写成这个样子

112
00:08:35,583 --> 00:08:36,863
我们再举一个例子

113
00:08:41,215 --> 00:08:43,007
刚刚那个算法叫做

114
00:08:43,519 --> 00:08:44,287
Efforts

115
00:08:44,543 --> 00:08:49,151
距离现在这个算法叫XX

116
00:08:49,407 --> 00:08:51,199
前进

117
00:08:53,503 --> 00:08:59,647
这也是算法里面的算法就他可能是给很多算法调用的是他是一个很

118
00:08:59,903 --> 00:09:01,439
基础的东西

119
00:09:03,231 --> 00:09:05,791
当然因此它效率就很重要

120
00:09:06,047 --> 00:09:08,607
这个

121
00:09:09,631 --> 00:09:11,935
收到一个迭代器交易

122
00:09:12,959 --> 00:09:15,775
我要离开封

123
00:09:16,543 --> 00:09:21,919
这很可能是正的也说不定是富有富的就是往后走这就是往前走

124
00:09:22,175 --> 00:09:24,991
一个爱一个

125
00:09:26,527 --> 00:09:30,879
由于这个走的距离我是要一步一步走呢

126
00:09:31,391 --> 00:09:32,927
晚上漂着呢

127
00:09:33,439 --> 00:09:35,743
那就要问你大气

128
00:09:36,767 --> 00:09:41,119
问题在汽车请问好你的分类是什么

129
00:09:41,887 --> 00:09:46,239
然后才能决定这三条线上面有123三个版本

130
00:09:47,519 --> 00:09:51,615
晚上如果他是

131
00:09:51,871 --> 00:09:53,151
Randomaccess

132
00:09:54,687 --> 00:09:57,759
他是可以跳那么就挨家等人

133
00:09:58,015 --> 00:09:59,039
这个最快

134
00:10:00,319 --> 00:10:05,183
如果不是的话那就可能落在上面这两个了

135
00:10:05,695 --> 00:10:07,743
如果是双向的呢

136
00:10:09,023 --> 00:10:11,839
那就表示恩可正可负

137
00:10:12,607 --> 00:10:13,887
说这边可以

138
00:10:14,143 --> 00:10:15,679
可以往前走往后走

139
00:10:19,263 --> 00:10:21,055
如果也不是这一个

140
00:10:22,079 --> 00:10:23,359
那么可能是这个呢

141
00:10:25,919 --> 00:10:32,063
这样的话一定是往前走所以他只能够勇往直前他智能家家

142
00:10:32,319 --> 00:10:34,111
家有网之前

143
00:10:36,671 --> 00:10:39,743
我们看这样分成了三个版本非常合理

144
00:10:42,047 --> 00:10:48,191
至于这一行就这个地方就是一个一个好像向铁路的这个分配中心吗这个

145
00:10:48,447 --> 00:10:52,287
调整轨道的是怎么做的

146
00:10:54,079 --> 00:10:59,711
在这个iterator papakura启蓝色的这一个

147
00:11:00,735 --> 00:11:05,343
源代码在这里是一个辅助你可以想象这个辅助函数

148
00:11:06,111 --> 00:11:09,695
辅助函数刚刚在上一页

149
00:11:09,951 --> 00:11:12,767
现在这个结构这个布局都很像

150
00:11:13,023 --> 00:11:14,559
这是主函数

151
00:11:14,815 --> 00:11:20,703
刚刚在上月这里的是直接丢给说去问

152
00:11:24,287 --> 00:11:26,591
而在这一夜这里的

153
00:11:26,847 --> 00:11:31,967
要写成那样也可以但是换了一个写法所以这个都一样

154
00:11:32,735 --> 00:11:37,599
功能都一样的话那个写法是是这一个写成一个函数

155
00:11:38,879 --> 00:11:45,023
你能做什么事情也是把收到的迭代器的类型又给

156
00:11:45,279 --> 00:11:47,839
Grace去问不一样

157
00:11:48,351 --> 00:11:54,495
都一样把这个动作小小的动作能把我在这里这些都是标准库的源代码它有时候

158
00:11:54,751 --> 00:12:00,895
都是在直接问直接写出来有时候呢他写成一个小孩是有给小孩出去问答

159
00:12:02,175 --> 00:12:05,247
上也跟这一页的一个小小的不同

160
00:12:06,783 --> 00:12:08,319
我们看这句话

161
00:12:09,343 --> 00:12:14,207
所以这个函数会协助取出迭代器的分类

162
00:12:15,231 --> 00:12:21,375
分类是一个类型的态度并以此创建出一个临时对象

163
00:12:23,167 --> 00:12:25,471
创建出来哦船回来

164
00:12:25,727 --> 00:12:28,031
当然这边是调用他吗

165
00:12:28,287 --> 00:12:32,639
这个讨论出结果之后呢红色的这个是结果之后

166
00:12:32,895 --> 00:12:36,479
建立一个对对象传回来

167
00:12:36,735 --> 00:12:38,783
这个地方才能够

168
00:12:39,039 --> 00:12:45,183
在调用的时候编译器一看后传回了这个对象然后才决定到底是这三条的哪一条

169
00:12:46,719 --> 00:12:51,071
也就是这三条

170
00:12:57,215 --> 00:12:58,751
好

171
00:13:03,103 --> 00:13:06,687
这里出现三种分类

172
00:13:08,479 --> 00:13:11,295
可是不是真的有好几种有五种吗

173
00:13:11,807 --> 00:13:12,831
这里有三种

174
00:13:13,343 --> 00:13:15,135
再回到商业看看

175
00:13:15,647 --> 00:13:20,511
放音乐这里的主函数分派出去是分两种类型

176
00:13:21,023 --> 00:13:23,583
不是总共有50种吗

177
00:13:24,351 --> 00:13:30,495
就算其中一种富有的不含在这个继承关系你头哪里有四种啊有四种怎么治

178
00:13:30,751 --> 00:13:35,871
这里只写出两种出来那下一页纸写出三种出来的

179
00:13:40,479 --> 00:13:41,759
前面我们提到

180
00:13:43,807 --> 00:13:45,343
分类我说

181
00:13:45,855 --> 00:13:50,719
他不用123455来表现他用对象来表现

182
00:13:52,255 --> 00:13:56,095
我前面提过一个原因现在的题的第2个原因

183
00:13:58,399 --> 00:14:04,543
如果用对象来表现而且是有继承关系的话商业好了

184
00:14:04,799 --> 00:14:07,615
就比较好奇

185
00:14:08,383 --> 00:14:12,735
这里是分成两类但是其实可能有室内

186
00:14:14,527 --> 00:14:20,671
好如果这边问出来的结果你的分类category

187
00:14:20,927 --> 00:14:22,207
是

188
00:14:25,023 --> 00:14:27,327
Siri traded是这个

189
00:14:30,399 --> 00:14:35,263
在写代码代码里头并没有一个专属为他而设计的版本

190
00:14:35,519 --> 00:14:40,127
这里跟21跟二分别是这里的这一个案子一个

191
00:14:40,383 --> 00:14:41,407
这个这个

192
00:14:41,663 --> 00:14:44,735
但是现在问的结果是这一个服务

193
00:14:45,247 --> 00:14:47,039
那他会钓到谁

194
00:14:50,111 --> 00:14:56,255
那我们就得联想一下面向对象对于继承的这个观测这个概念是什么

195
00:14:56,511 --> 00:14:58,047
继承就是意思

196
00:14:58,303 --> 00:15:01,375
是一种

197
00:15:01,631 --> 00:15:07,263
最早是这个问出来的结果他是48v的

198
00:15:08,031 --> 00:15:14,175
虽然这里没有专属版本但是服务Internet is a

199
00:15:14,431 --> 00:15:15,711
Import iterator

200
00:15:16,479 --> 00:15:22,623
一定要同意这个话因为这个帖子写成这样啊他也是

201
00:15:22,879 --> 00:15:26,207
是一种应对对的就在这里的就会跑到

202
00:15:29,535 --> 00:15:34,399
所以虽然这里有四种这里只有两格

203
00:15:34,911 --> 00:15:38,751
但是不管真正问出来是哪一种

204
00:15:39,263 --> 00:15:42,591
总一定会落在某一个版本

205
00:15:44,383 --> 00:15:47,967
压倒李夏夜也是完全一样的道理

206
00:15:48,479 --> 00:15:54,623
这里有三个版本20计有四种分类也是总是

207
00:15:54,879 --> 00:15:58,719
一定会落到某一个版本去

208
00:16:02,559 --> 00:16:04,351
好我们谈的是

209
00:16:04,607 --> 00:16:09,727
两个很基础的算法它们

210
00:16:10,495 --> 00:16:11,775
汉分类

211
00:16:12,031 --> 00:16:15,871
迭代器的分类对他们效率的影响

212
00:16:20,223 --> 00:16:22,015
我们再看下一页

213
00:16:27,135 --> 00:16:29,439
我继续再举一些例子

214
00:16:29,695 --> 00:16:34,559
继续剧团到迭代器的分类对算法效率的影响

215
00:16:34,815 --> 00:16:40,959
你慢慢就可以感受到使用标准库是一件多么幸福的事情

216
00:16:41,471 --> 00:16:47,615
且标准库的人也许很痛苦因为要写得这么的这么的精准判

217
00:16:47,871 --> 00:16:50,175
判断复杂

218
00:16:50,431 --> 00:16:55,295
严谨但是写出来是这么的好用起来了

219
00:16:55,551 --> 00:16:57,343
一定要信任它的效率

220
00:16:57,599 --> 00:17:02,719
我刚才已经举两个例子了看这个copy

221
00:17:04,767 --> 00:17:07,071
喀比还不简单吗

222
00:17:08,095 --> 00:17:09,887
怎么有一小块

223
00:17:12,191 --> 00:17:18,335
这个屏幕上次比较小了我也没有打算带着你去看其实动作非常简单我可以比手画脚

224
00:17:18,591 --> 00:17:19,615
脚让你理解一下

225
00:17:20,383 --> 00:17:23,455
所谓cabochon来源端到目的端吗

226
00:17:23,711 --> 00:17:29,343
最copy这个函数一定是会有头更为两根指针指向来源端

227
00:17:29,855 --> 00:17:32,927
让尾巴那边呢那边只要有一个

228
00:17:33,183 --> 00:17:34,719
起点就好了

229
00:17:35,999 --> 00:17:39,071
来源端的这个头尾

230
00:17:39,327 --> 00:17:45,471
固定有比如说and the copy过去一定是恩的水幕的段那边只要奇

231
00:17:45,727 --> 00:17:46,239
几点

232
00:17:46,751 --> 00:17:52,895
而来源端这边要有7点跟中点所应该要三个参数为看copy

233
00:17:53,151 --> 00:17:59,295
还要有first last and not resolve就是目的端那边的起点

234
00:17:59,551 --> 00:18:05,439
不知道这三个变量你就一个一个的翻过去叫

235
00:18:05,695 --> 00:18:07,743
这个是copy的动作

236
00:18:07,999 --> 00:18:14,143
这么简单的一个动作里头的时间是那么的复杂

237
00:18:16,959 --> 00:18:19,007
刚刚你看的这一段

238
00:18:19,519 --> 00:18:23,615
它只是一个一个一个原始最直观的样子

239
00:18:24,895 --> 00:18:31,039
实际上不是这么写的这一段代码只能是一个表现一种逻辑的

240
00:18:31,295 --> 00:18:32,575
一项

241
00:18:34,623 --> 00:18:37,695
实际上是怎么样了这个copy

242
00:18:38,719 --> 00:18:44,863
啊你先看这图我的表现了你说这咖啡呢分成三部分成三个版本

243
00:18:45,119 --> 00:18:51,263
其中的这个版本在这里又分成三种情况他的这一个版本这种情况

244
00:18:51,519 --> 00:18:53,311
放了又分为

245
00:18:53,567 --> 00:18:59,711
我这个图太复杂这两种情况这一个又分为这两种情况

246
00:18:59,967 --> 00:19:04,575
能觉察当地最后才去引导你

247
00:19:04,831 --> 00:19:05,855
所以

248
00:19:07,391 --> 00:19:09,183
我现在要带你看的就是

249
00:19:09,695 --> 00:19:15,327
Copy里面不断的在做检查检查他所收到的迭代器

250
00:19:16,095 --> 00:19:19,679
是不是特别属于某一种类型

251
00:19:20,703 --> 00:19:26,847
而决定要不要copy要不要做一些很特别的动作来加快速度

252
00:19:27,871 --> 00:19:30,175
做了这么多的检查

253
00:19:32,479 --> 00:19:38,623
那里的源代码我就不拿给各位看了我就口语来叙述你应该是可以

254
00:19:38,879 --> 00:19:39,903
理解

255
00:19:40,415 --> 00:19:42,719
这个copy

256
00:19:43,231 --> 00:19:49,375
他先检查传进来的这一些指针first泛化的指针就是迭代

257
00:19:49,631 --> 00:19:55,775
First last visit他就检查他说看看

258
00:19:56,031 --> 00:19:57,055
他们是不是

259
00:19:57,567 --> 00:19:59,871
这一种类型的东西

260
00:20:39,807 --> 00:20:43,903
如果不是这两种不是他也不是他

261
00:20:44,159 --> 00:20:45,951
那就是这一种啊

262
00:20:46,975 --> 00:20:49,023
这一种的话

263
00:20:49,279 --> 00:20:51,071
就调用这一个函数

264
00:20:51,583 --> 00:20:56,703
我也不去念他了反正你在画面上看得很清楚你出来那么长

265
00:20:57,471 --> 00:21:01,567
好像这个函数在这一个函数里头

266
00:21:03,103 --> 00:21:04,383
又去检查

267
00:21:05,151 --> 00:21:07,711
传进来的是不是这一种样子

268
00:21:07,967 --> 00:21:10,527
或者是不是这一种

269
00:21:12,575 --> 00:21:15,903
这两种样子都表示穿进来的是指针

270
00:21:16,928 --> 00:21:22,304
他重新来的是迭代迭代器吗但是说特别它是指针

271
00:21:23,584 --> 00:21:29,216
那么就做这一个动作和这个动作其实这两个一样

272
00:21:32,288 --> 00:21:34,848
好如果不是指针的话

273
00:21:35,360 --> 00:21:36,896
那就走到这里来了

274
00:21:38,176 --> 00:21:39,456
再用这个

275
00:21:42,016 --> 00:21:46,880
这个版本这个函数里头又去检查

276
00:21:47,648 --> 00:21:51,488
是这一种迭代器吗renderpasses器吗

277
00:21:53,792 --> 00:21:55,328
如果

278
00:21:55,584 --> 00:21:56,352
不是

279
00:21:57,120 --> 00:21:58,400
到这里来

280
00:22:00,704 --> 00:22:06,848
那么就说了吧就是我刚刚最前面说这只能比手画脚讲的从来源端一个

281
00:22:07,104 --> 00:22:13,248
Float吗一个一个的copy到目的端这个copy的过程没回

282
00:22:13,504 --> 00:22:14,528
可引发

283
00:22:14,784 --> 00:22:15,808
拷贝构造

284
00:22:16,320 --> 00:22:18,880
北大这些动作这是弗洛姆

285
00:22:21,952 --> 00:22:24,512
但如果是randomaccess

286
00:22:26,048 --> 00:22:32,192
这张图是看了源代码之后分析出的话的图啊所以我们等于在看源代码了这个

287
00:22:32,448 --> 00:22:35,776
如果是randomaccess就座

288
00:22:36,544 --> 00:22:37,312
这个东西

289
00:22:40,640 --> 00:22:44,992
这一个动作跟刚刚有什么不一样吗刚是否root这个呢

290
00:22:46,528 --> 00:22:47,808
这个也是followed

291
00:22:49,344 --> 00:22:55,232
但是刚刚是first context这个来源段的头尾在这里呢

292
00:22:56,000 --> 00:23:01,632
这里是不用在那边一个一个比较头更为简要知道要copy一份

293
00:23:02,144 --> 00:23:05,984
仔细看黄色日2块是有一点点不同的

294
00:23:06,496 --> 00:23:07,776
下面这个比较快

295
00:23:13,152 --> 00:23:14,432
好说

296
00:23:14,688 --> 00:23:16,224
那其他的这些

297
00:23:19,296 --> 00:23:24,160
这个策划如果是这样的指针和这样的指针到这边来

298
00:23:24,416 --> 00:23:25,696
又会去问

299
00:23:27,488 --> 00:23:32,608
在copy过去的时候你咖啡这个东西本身

300
00:23:33,120 --> 00:23:35,680
有没有衰落

301
00:23:35,936 --> 00:23:42,080
Celebrate这个教区的就是很琐碎的不重要的

302
00:23:42,336 --> 00:23:45,408
这个是什么就是拷贝复制

303
00:23:46,432 --> 00:23:52,576
这个很有趣了它已经进行到了在检查

304
00:23:52,832 --> 00:23:55,392
在检查到这个传进来的是指针的

305
00:23:55,648 --> 00:23:58,720
所以他要一个一个的搬动

306
00:23:58,976 --> 00:24:01,536
班的过程我刚刚说引发

307
00:24:02,560 --> 00:24:08,704
我刚刚好像是讲拷贝构造是不是如果是我将考虑构造那是错的啊是靠

308
00:24:08,960 --> 00:24:09,984
拷贝赋值

309
00:24:10,496 --> 00:24:16,640
上过去考虑复制这个时候又问说你这个拷贝复制这个

310
00:24:16,896 --> 00:24:19,200
动作中不重要催了

311
00:24:20,736 --> 00:24:22,016
如果

312
00:24:24,832 --> 00:24:28,160
Trial trivial但是考试不重要了

313
00:24:28,416 --> 00:24:33,536
十月之不重要如果不重要的话那根本就不要调用它

314
00:24:33,792 --> 00:24:39,936
于是又一次呢这么一大串动作到这里来其实最后做的事

315
00:24:41,728 --> 00:24:43,264
跟前面一样

316
00:24:45,568 --> 00:24:51,712
但如果他是重要的那一个一个复制过去就

317
00:24:51,968 --> 00:24:54,784
每一个都要调用拷贝复制

318
00:24:55,296 --> 00:24:57,344
所以这个

319
00:24:57,600 --> 00:24:59,904
如果他是重要的

320
00:25:00,928 --> 00:25:01,696
你看这个

321
00:25:02,208 --> 00:25:04,512
不是不重要那就是重要的

322
00:25:04,768 --> 00:25:06,816
如果他是重要的

323
00:25:07,072 --> 00:25:09,376
那么往下坐就是这个工作

324
00:25:09,632 --> 00:25:15,776
你可以我刚才已经把这个过程讲过了你可以停下停下来的值

325
00:25:16,032 --> 00:25:22,176
仔细的去思考总之让你感受到它提示我无敌景

326
00:25:22,432 --> 00:25:22,944
游戏

327
00:25:23,200 --> 00:25:26,016
一层一层的判断

328
00:25:27,552 --> 00:25:30,112
来决定还要采用哪一种

329
00:25:31,392 --> 00:25:33,184
动作能够最快

330
00:25:37,792 --> 00:25:43,936
这是一个我们一直在讲的就是算迭代器里面的

331
00:25:44,192 --> 00:25:45,728
这个分类

332
00:25:46,496 --> 00:25:49,056
对于算法效率的影响

333
00:25:50,592 --> 00:25:53,920
在这边出现一个新东西

334
00:25:55,712 --> 00:25:58,016
我这边图上画的tetris

335
00:25:58,528 --> 00:26:04,672
这个header trace不太一样我们的第2家里面反正是以此为他吹

336
00:26:04,928 --> 00:26:10,304
这个萃取机你把迭代器放进去问他一些问题

337
00:26:11,584 --> 00:26:17,728
这里也是你把那行放进去要问他一些问题其中的两个问题

338
00:26:17,984 --> 00:26:24,128
就是其中的一个问题就是这个你的拷贝赋值到底重不重要

339
00:26:26,176 --> 00:26:27,456
这个事情

340
00:26:27,712 --> 00:26:31,040
我将留到第4讲就谈了

341
00:26:31,296 --> 00:26:32,576
Tetris

342
00:26:34,112 --> 00:26:35,904
很有趣的一个话题

343
00:26:38,208 --> 00:26:40,768
重不重要什么叫重不重要呢

344
00:26:41,024 --> 00:26:47,168
那我们来凭空想象一下好了你现在设计一个类要素

345
00:26:47,424 --> 00:26:47,936
负数

346
00:26:48,448 --> 00:26:51,520
国中数学里面的高初中数学里面那个负数

347
00:26:52,032 --> 00:26:53,312
有时不需不那个

348
00:26:54,848 --> 00:26:56,128
还有指针吗

349
00:26:56,384 --> 00:26:57,920
他没有指针吗

350
00:26:58,944 --> 00:27:02,016
最大的数据就是10部分需不

351
00:27:03,808 --> 00:27:07,648
像这样的类需要解析构函数吗

352
00:27:09,952 --> 00:27:12,256
需要写拷贝构造函数吗

353
00:27:12,768 --> 00:27:14,816
需要些拷贝赋值函数吗

354
00:27:17,376 --> 00:27:17,888
No

355
00:27:18,656 --> 00:27:19,680
都不需要

356
00:27:21,472 --> 00:27:27,616
所以是那些还是我刚刚讲的那些函数如果你不写的话编译器会给你一个

357
00:27:27,872 --> 00:27:32,992
默认的一个是默认的那个人是不重要的因为他什么事都没做

358
00:27:33,760 --> 00:27:37,856
这就是这里的不重要的动作

359
00:27:40,160 --> 00:27:46,304
最回到刚刚说我们假设设计一个负数的话你把服务数这种东西丢到这个

360
00:27:46,560 --> 00:27:47,584
Tetris去

361
00:27:47,840 --> 00:27:53,984
去问他那些问题就应该可以问出来说其实他的拷贝复制是不重要的成语

362
00:27:54,240 --> 00:27:55,264
总要

363
00:27:56,544 --> 00:28:01,408
就可以做这个动作所以这么复杂的这张图里面

364
00:28:01,920 --> 00:28:08,064
用到的两种36e成为的锤子这个我们在第2讲讲过他怎么做

365
00:28:08,320 --> 00:28:11,648
已经讲过了这个人我到第4讲回答

366
00:28:12,672 --> 00:28:14,208
它就不属于

367
00:28:15,232 --> 00:28:21,376
STL的一部分sta56大足部件它不属于STL但是它属于标准

368
00:28:21,632 --> 00:28:25,728
股份我们第4讲他就是St的意外的

369
00:28:26,240 --> 00:28:31,104
标准库以内的那些周边的东西

370
00:28:32,640 --> 00:28:38,784
好不论对于这里面刚刚所谈的这些细节还有些你还没掌握到

371
00:28:39,040 --> 00:28:45,184
怎么样但是你一定掌握到一这张图copy那无所不用其极的

372
00:28:45,440 --> 00:28:45,952
去

373
00:28:46,720 --> 00:28:47,488
侦测

374
00:28:47,744 --> 00:28:52,096
希望找出一条效率最高的路线

375
00:28:53,120 --> 00:28:54,912
回到我们的标题说什么

376
00:28:55,168 --> 00:29:01,056
分类对于算法影响别大气的分类对算法的影响

377
00:29:01,312 --> 00:29:06,432
这让他投影片的还加上他出差也有影响这个就是他

378
00:29:17,440 --> 00:29:18,208
太多了

379
00:29:22,560 --> 00:29:28,448
我们对这个算法的影响是从这一开始是从distance这个函数据一个例子

380
00:29:28,960 --> 00:29:33,824
算法提升算法取得这个例子是用

381
00:29:34,848 --> 00:29:36,640
Advanced作为历史

382
00:29:37,152 --> 00:29:40,480
到了深夜那只用copy作为历史

383
00:29:41,760 --> 00:29:44,576
下一页我又准备一个人

384
00:29:45,856 --> 00:29:47,904
我想这边就不用去细讲了

385
00:29:50,208 --> 00:29:56,352
你可以体会花点时间的停下来体会这张图其实说法跟前的

386
00:29:56,608 --> 00:29:57,632
我们都一样

387
00:29:58,912 --> 00:30:05,056
都是看这个箭头去分初传进来的迭代器可能是什么类型

388
00:30:05,312 --> 00:30:05,824
行吗

389
00:30:07,616 --> 00:30:10,944
而其中的某些类型做一些最快的动作

390
00:30:11,456 --> 00:30:12,992
另外一些类型吗

391
00:30:14,016 --> 00:30:17,344
就不断的这样去取去检测就区分

392
00:30:18,880 --> 00:30:20,928
向着一个list string

393
00:30:21,184 --> 00:30:22,976
他也会去看他的锤子

394
00:30:24,512 --> 00:30:29,376
因为destroy要杀一直是要杀掉要摧毁一个

395
00:30:30,656 --> 00:30:31,936
一个对象

396
00:30:32,192 --> 00:30:38,336
摧毁她的画应按照道理应该要调用这个对象的析构函数

397
00:30:39,872 --> 00:30:45,248
但是这里就会判断你的析构还是不错的

398
00:30:45,760 --> 00:30:47,040
是重要的吗

399
00:30:48,576 --> 00:30:54,720
还是不重要的这个是重要这个是不重要的随意表不重要

400
00:30:54,976 --> 00:30:57,024
长垂柳是重要的

401
00:30:58,560 --> 00:31:01,376
所以如果是不重要的

402
00:31:02,656 --> 00:31:04,192
No operation

403
00:31:04,448 --> 00:31:08,032
那就不用做事了你摧毁一个对象吗

404
00:31:11,104 --> 00:31:12,896
不用做事不用做什么事情

405
00:31:13,920 --> 00:31:16,224
车载玩不需要释放内存吗

406
00:31:16,736 --> 00:31:22,368
那个根据这个功能的区分就不贵这个函数

407
00:31:22,880 --> 00:31:29,024
这个还是做完以后才会去释放内存的这个函数

408
00:31:29,280 --> 00:31:34,912
要摧毁的元素如果他的析构函数不重要

409
00:31:35,168 --> 00:31:37,216
那就根本不要做事情

410
00:31:38,240 --> 00:31:39,776
如果重要呢

411
00:31:40,288 --> 00:31:42,848
那就要去调用析构函数

412
00:31:45,664 --> 00:31:51,808
这张图的分析跟上一张图上当图卡比这更复杂吗其实分析的方式都一样

413
00:31:52,064 --> 00:31:53,344
一样的

414
00:31:57,952 --> 00:31:59,232
下面这张图

415
00:31:59,744 --> 00:32:03,328
就是把刚刚讲的这一张A3

416
00:32:04,096 --> 00:32:05,120
现在

417
00:32:05,376 --> 00:32:07,936
这里呢我在一次放在这里

418
00:32:08,192 --> 00:32:10,752
并且把相关的

419
00:32:11,008 --> 00:32:12,032
源代码

420
00:32:12,288 --> 00:32:15,616
相关的源代码都超出来

421
00:32:15,872 --> 00:32:18,176
用这个浅蓝色的这个箭头

422
00:32:18,944 --> 00:32:22,016
来让你有兴趣的话自己看一看

423
00:32:22,528 --> 00:32:24,576
这个图片看比如说

424
00:32:24,832 --> 00:32:29,952
SUV这一个源代码这个浅蓝色这个出现的就是这块

425
00:32:31,744 --> 00:32:34,048
这一块里面有调用一个

426
00:32:34,304 --> 00:32:40,448
到目前为止对你是陌生的东西于是我就把它连代码超出来在这里

427
00:32:42,240 --> 00:32:47,104
那么往这边进行之后呢这边进行到了这一个

428
00:32:47,360 --> 00:32:49,408
Destroy这个函数

429
00:32:51,200 --> 00:32:54,016
要检查它的

430
00:32:54,784 --> 00:32:56,832
这个test

431
00:32:57,088 --> 00:33:00,416
你是他的源代码我就在这里bistro

432
00:33:00,672 --> 00:33:01,696
这里

433
00:33:01,952 --> 00:33:02,976
是这一个

434
00:33:06,048 --> 00:33:08,096
等等等这些东东的

435
00:33:08,352 --> 00:33:11,424
这次的源代码的我都拿出来

436
00:33:12,960 --> 00:33:19,104
有兴趣的话可以看如果你没有兴趣那么你只要抓到一个重点

437
00:33:19,360 --> 00:33:21,664
一直在强调算法

438
00:33:22,176 --> 00:33:23,200
效率

439
00:33:24,736 --> 00:33:29,344
看他能不能判断出也大器的分类

440
00:33:29,600 --> 00:33:31,136
有很重要的关系

441
00:33:32,416 --> 00:33:36,000
这是扛着几张脱一直在讨论的事情

442
00:33:38,560 --> 00:33:41,376
今夜又是题目都一样

443
00:33:44,448 --> 00:33:45,728
对算法的影响

444
00:33:46,496 --> 00:33:48,032
CC选的例子是什么

445
00:33:48,544 --> 00:33:50,592
Unix copy

446
00:33:52,896 --> 00:33:53,920
职业

447
00:33:54,176 --> 00:33:58,784
如果留下停下来让你看有可能你看不懂这也需要说一下

448
00:34:00,320 --> 00:34:06,464
Unique copy我们有兴趣的去茶规格书我这里也不去谈他那是顾名思义

449
00:34:06,720 --> 00:34:12,864
你可以知道uniq uniq是独一无二的是copy的过程里面应该可以想象

450
00:34:13,120 --> 00:34:13,632
那就是

451
00:34:14,400 --> 00:34:20,032
如果重复的东西他就不copy了copy那个独一无二的元素

452
00:34:23,104 --> 00:34:24,896
在copy的过程里头

453
00:34:28,992 --> 00:34:30,528
他收到了参数是

454
00:34:30,784 --> 00:34:33,344
这是一个参数是

455
00:34:33,856 --> 00:34:35,904
来源端的头跟尾

456
00:34:37,184 --> 00:34:38,464
这个是目的端

457
00:34:40,512 --> 00:34:44,864
已经尽到这里了这个函数是一个休讲个笑话现

458
00:34:45,120 --> 00:34:47,424
这可见他不是一个主函数

459
00:34:47,936 --> 00:34:50,240
使用者是不会直接面对他的

460
00:34:50,752 --> 00:34:55,104
一定是另外一个主函数一个主函数已经判断出

461
00:34:56,384 --> 00:34:57,152
这些

462
00:34:57,408 --> 00:34:58,432
迭代器呀

463
00:34:58,688 --> 00:35:00,480
C4d

464
00:35:01,504 --> 00:35:03,296
于是跑过来调用

465
00:35:03,808 --> 00:35:04,832
这个版本

466
00:35:06,880 --> 00:35:08,160
这好像前面

467
00:35:10,464 --> 00:35:12,000
这个主函数

468
00:35:12,256 --> 00:35:15,840
会议分别调用一些次要的版本一样

469
00:35:17,376 --> 00:35:18,144
到这里

470
00:35:20,448 --> 00:35:24,800
这已经进行到这个某一个版本

471
00:35:25,056 --> 00:35:29,920
好我们来检查一下在这个版本叫做服务iterator

472
00:35:31,200 --> 00:35:33,248
它里面的动作

473
00:35:34,272 --> 00:35:37,088
其中的这一个动作

474
00:35:37,856 --> 00:35:39,136
If这个动作

475
00:35:40,928 --> 00:35:41,696
仔细看看

476
00:35:45,792 --> 00:35:48,096
传进来的如LS

477
00:35:48,352 --> 00:35:50,400
是目的端的

478
00:35:51,168 --> 00:35:53,472
这一个动作显然是在

479
00:35:53,728 --> 00:35:59,872
对如要做一个读取的reference就是要去提两个读取内容这是一个

480
00:36:00,128 --> 00:36:01,664
动物的动作

481
00:36:05,760 --> 00:36:07,296
这个地方

482
00:36:09,600 --> 00:36:14,720
汉这一个版本是针对服务器的版本

483
00:36:14,976 --> 00:36:16,768
这两者相冲突

484
00:36:18,304 --> 00:36:19,584
可能冲突

485
00:36:21,120 --> 00:36:21,888
为什么呢

486
00:36:24,448 --> 00:36:27,264
如果传进来的

487
00:36:27,776 --> 00:36:29,568
是一个output

488
00:36:29,824 --> 00:36:30,592
Iterator

489
00:36:30,848 --> 00:36:33,152
前面在讲那个分类

490
00:36:33,408 --> 00:36:35,200
不是说有五种吗

491
00:36:38,272 --> 00:36:38,784
这个

492
00:36:39,040 --> 00:36:42,880
有种这个特别独特立独行的招牌

493
00:36:44,416 --> 00:36:50,048
如果传进来的是operator

494
00:36:56,448 --> 00:37:01,824
如果没有特别对office eternity一个版本没有

495
00:37:02,080 --> 00:37:03,872
那就会跑到这个版本

496
00:37:05,408 --> 00:37:08,480
这个版本进来这里却是做read

497
00:37:15,392 --> 00:37:16,160
不可以

498
00:37:17,184 --> 00:37:23,328
我刚刚讲的是说如果传进来的这个日落的是一个operator

499
00:37:23,584 --> 00:37:28,704
你要从来源端拷贝到目的端木地砖这边就是围绕

500
00:37:29,728 --> 00:37:30,752
如果他

501
00:37:31,264 --> 00:37:34,848
是一个operator

502
00:37:36,128 --> 00:37:39,200
也会跑到这个服务已成为这个版本

503
00:37:39,712 --> 00:37:43,296
但是跑进来之后这里是如意的动作

504
00:37:44,576 --> 00:37:48,928
而实际是一个operator那不可以

505
00:37:49,696 --> 00:37:50,976
那怎么办呢

506
00:37:51,744 --> 00:37:52,512
只好

507
00:37:53,280 --> 00:37:54,304
标准库

508
00:37:54,560 --> 00:37:57,632
知道有这么一个情况

509
00:37:57,888 --> 00:37:59,680
另外再写一个版本

510
00:38:00,192 --> 00:38:04,544
针对好results of the weather

511
00:38:06,080 --> 00:38:08,128
其实是上一个版本的这里了

512
00:38:11,968 --> 00:38:13,248
这个地方

513
00:38:13,504 --> 00:38:15,040
采取呼叫下面这里

514
00:38:16,064 --> 00:38:20,672
你一样可以听歌慢慢看其实是同一个函数但是把它切成两个

515
00:38:21,696 --> 00:38:27,840
这个函数往下调用它在这里呢其实就是在取代这一块

516
00:38:28,096 --> 00:38:31,168
但是要避免这个如意的东西

517
00:38:33,216 --> 00:38:35,776
因为现在这个是covid-19 Beta

518
00:38:36,544 --> 00:38:38,080
仔细区分左右啊

519
00:38:38,336 --> 00:38:43,712
右边results for左边results of

520
00:38:44,224 --> 00:38:45,248
他们的差别

521
00:38:47,808 --> 00:38:50,112
我特别圈起来这几块

522
00:38:50,624 --> 00:38:56,768
就是一个避免锐的动作这个位置动作现在不行在这里替换掉了

523
00:38:57,024 --> 00:38:59,072
体会

524
00:39:09,056 --> 00:39:11,872
前面已经谈到了所以

525
00:39:12,128 --> 00:39:18,272
这就是为什么要发展出容器的迭代器要能够回答我个问题

526
00:39:19,552 --> 00:39:25,696
为什么呢刚刚这么多张投影片的展示给大家看算法会去问这些问题

527
00:39:25,952 --> 00:39:28,256
这样的回答

528
00:39:28,512 --> 00:39:31,584
我们对这件事情现在非常清楚了

529
00:39:33,888 --> 00:39:36,448
算法的源码里面

530
00:39:36,960 --> 00:39:39,008
对于迭代器的

531
00:39:39,264 --> 00:39:40,032
分类

532
00:39:41,056 --> 00:39:43,616
有没有什么强制限制

533
00:39:45,664 --> 00:39:46,432
没有

534
00:39:46,688 --> 00:39:48,480
他只有暗示

535
00:39:49,760 --> 00:39:51,552
因为算法

536
00:39:51,808 --> 00:39:53,856
是一个模板函数

537
00:39:54,624 --> 00:39:58,976
模板的意思就是可以接受各式各样的类型

538
00:40:00,768 --> 00:40:06,912
当然刚刚已经看到了他针对不同类型迭代器的类型和大气的分类的类型

539
00:40:07,168 --> 00:40:09,984
他可能有丰盛一些

540
00:40:10,240 --> 00:40:12,288
四函数据做

541
00:40:13,312 --> 00:40:15,616
但是在他的主函数里头

542
00:40:16,640 --> 00:40:17,152
他

543
00:40:18,176 --> 00:40:23,808
没有任何的强制的儿子接受什么样的

544
00:40:24,832 --> 00:40:25,856
给大气

545
00:40:27,392 --> 00:40:29,440
比如说设置好了

546
00:40:29,952 --> 00:40:31,232
Sort

547
00:40:31,744 --> 00:40:37,888
其实它里面的运作因为这个数这是一个快速排序法会受它里面的

548
00:40:38,144 --> 00:40:43,776
在运作会需要用到对迭代器的直接跳要randomaccess

549
00:40:47,104 --> 00:40:50,432
那他能不能在他的接口的地方

550
00:40:50,688 --> 00:40:56,576
强制作你们传给我的必须是random access这种迭代器

551
00:40:57,344 --> 00:40:59,904
没有语言

552
00:41:00,672 --> 00:41:02,976
语法怎么有语法上的工具

553
00:41:03,232 --> 00:41:07,328
帮助我没有所以像这个source

554
00:41:08,352 --> 00:41:11,168
它接受投喂两根指针

555
00:41:11,680 --> 00:41:16,544
这是他是什么类型的任意类型都可以因为这是一个模板

556
00:41:16,800 --> 00:41:17,824
模板参数

557
00:41:18,336 --> 00:41:22,176
汤唯一能够做的是一个暗示

558
00:41:23,712 --> 00:41:29,856
就像你现在看到了他把这个迭代器的类型其实家

559
00:41:30,112 --> 00:41:33,184
也可以叫Angel题都可以通常要提吗

560
00:41:33,440 --> 00:41:34,720
小智太笨了

561
00:41:34,976 --> 00:41:39,328
但是他这里把它命名叫random-access的Twitter

562
00:41:40,096 --> 00:41:43,936
他把这个大号拜名称命的这么长

563
00:41:45,216 --> 00:41:51,360
这是给维护源代码的人或者给我们现在有能力看源代码的人看

564
00:41:51,616 --> 00:41:53,663
草原来说

565
00:41:53,919 --> 00:41:55,199
必须接受

566
00:41:55,455 --> 00:41:57,759
Windows iterator

567
00:41:58,015 --> 00:42:01,855
如果不接受如果他传进来的不是这一种呢

568
00:42:02,623 --> 00:42:08,767
在调用的第1行是会可以通过的我刚说他必须接受所有类型的

569
00:42:09,023 --> 00:42:10,559
这个浏览器

570
00:42:11,583 --> 00:42:17,727
船票用的第1行编译是通过的但是继续往下边边到那个真的要跳的动作

571
00:42:17,983 --> 00:42:18,751
就是呗

572
00:42:21,055 --> 00:42:25,663
最我再讲一次要提上这边讲这只是一个暗示

573
00:42:27,967 --> 00:42:30,783
我在这里那就选了五个例子

574
00:42:31,551 --> 00:42:36,415
把这种暗示都不一样的全部转给你看

575
00:42:37,439 --> 00:42:38,463
Distance

576
00:42:39,231 --> 00:42:42,303
刚刚其实有没看过他的比较完整的东西的

577
00:42:42,815 --> 00:42:43,839
Distance

578
00:42:44,095 --> 00:42:50,239
但是说他接受的迭代器只要是input radio可以

579
00:42:50,751 --> 00:42:54,847
那不是有一个那个分类它不是有继承关系吗

580
00:42:57,151 --> 00:43:01,759
再看一次那个很快的到前面去分类有一个这个

581
00:43:02,015 --> 00:43:06,367
这个继承关系刚刚那个案是说我接受这一种

582
00:43:07,647 --> 00:43:09,951
那如果你攒起来是这三种人

583
00:43:10,207 --> 00:43:15,839
当然也可以因为他们都应是一种这个东西

584
00:43:17,631 --> 00:43:19,935
好现在回到刚刚

585
00:43:20,191 --> 00:43:20,959
什么

586
00:43:26,335 --> 00:43:28,127
Distance

587
00:43:29,151 --> 00:43:34,015
说着他但是我要搜的是

588
00:43:34,271 --> 00:43:37,855
Windows Server可以是最高级的

589
00:43:38,111 --> 00:43:39,903
可以那个继承关系来讲

590
00:43:40,671 --> 00:43:42,207
那么翻译呢

591
00:43:42,975 --> 00:43:45,791
我要接受的是input

592
00:43:47,327 --> 00:43:49,887
Rotate旋转

593
00:43:50,399 --> 00:43:56,543
有这么一个算法它接受服务一层位的是一个那covid

594
00:43:56,799 --> 00:43:58,079
接受的是

595
00:43:59,103 --> 00:44:04,223
Bidirectional汉oppot15种我都找到了相关的例子

596
00:44:06,015 --> 00:44:07,295
跳出来给你看

597
00:44:09,087 --> 00:44:11,647
这是他的一个暗示

598
00:44:11,903 --> 00:44:18,047
当我们在看人在忙时会看到这些又臭又长的东西就是一点也不错啊香的他就用名称

599
00:44:18,303 --> 00:44:19,839
来告诉我们

600
00:44:20,863 --> 00:44:22,143
一些意图

601
00:44:25,727 --> 00:44:31,103
好在这个地方那就是接下来我们要谈的就是

602
00:44:31,871 --> 00:44:33,407
这个算法

603
00:44:33,663 --> 00:44:39,807
当然算法有其他四个我们不能都谈我们也不打算去谈那个算法的数字

604
00:44:40,063 --> 00:44:46,207
他要做的事情那太复杂了那个我们把他回给能给学校的老师去去去教授我们要

605
00:44:46,463 --> 00:44:46,975
韩的

606
00:44:47,231 --> 00:44:51,071
此算法里面的一些一些

607
00:44:52,351 --> 00:44:55,167
语言结构上的一些东西
