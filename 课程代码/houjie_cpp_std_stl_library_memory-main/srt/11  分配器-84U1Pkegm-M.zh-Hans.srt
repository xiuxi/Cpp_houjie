1
00:00:10,496 --> 00:00:14,336
刚才我们已经对于必要的基础的都做了一番理解

2
00:00:15,104 --> 00:00:16,384
现在我们这次来看

3
00:00:17,408 --> 00:00:23,040
标准库里面的最重要那个成分STL里头的六大部件

4
00:00:23,552 --> 00:00:29,696
我们要从数据库的源代码的角度去去深刻地去理解

5
00:00:30,976 --> 00:00:33,792
第1个分配器

6
00:00:34,560 --> 00:00:40,704
分配器应该是每个幕后英雄的角色我们一般是不会直接去用到他的也不建议就是

7
00:00:40,960 --> 00:00:47,104
经过了这个讲解之后你能够用他也不建议去用他因为没有

8
00:00:47,360 --> 00:00:53,504
没有需要怎么去用它它是给容器用的它的优劣非常重要因为

9
00:00:53,760 --> 00:00:58,368
为你在使用容器的也要不断放元素进去拿出来因此

10
00:00:58,624 --> 00:01:04,768
都会用到内存这个分配器的效率好不好就会影响到你这个容器的笑

11
00:01:05,024 --> 00:01:07,840
小了这个效率很包括是

12
00:01:08,096 --> 00:01:08,864
速度

13
00:01:09,120 --> 00:01:10,912
以及空间的运用率

14
00:01:11,680 --> 00:01:13,216
已经内置有限

15
00:01:14,240 --> 00:01:15,264
好

16
00:01:16,032 --> 00:01:16,800
首先

17
00:01:17,056 --> 00:01:23,200
在第1这个分配器的第1张图应该能让我们要先谈一谈operator new blog

18
00:01:23,968 --> 00:01:30,112
有个观念是这样这个确实的好就是所有的分配动作最终一层

19
00:01:30,368 --> 00:01:32,416
等一下去cplusplus

20
00:01:32,672 --> 00:01:37,024
往下调用总之最后都会跑到

21
00:01:37,280 --> 00:01:38,048
Block

22
00:01:38,304 --> 00:01:42,400
你这个label crtc runtime Library

23
00:01:42,656 --> 00:01:48,800
所提供的这个block这个这个函数在根据他是在Windows下或者他在lena

24
00:01:49,056 --> 00:01:54,176
Linux下或者他在Unix下去调用不同的操作系统

25
00:01:54,432 --> 00:01:55,200
里面的

26
00:01:55,456 --> 00:01:59,552
API API查询达到真正的内存

27
00:02:00,320 --> 00:02:02,368
最在标准层面上

28
00:02:02,880 --> 00:02:05,696
最终大家都是跑到malloc去

29
00:02:06,720 --> 00:02:07,488
悲伤

30
00:02:08,000 --> 00:02:11,328
我们就来先谈一谈operator New

31
00:02:14,144 --> 00:02:19,008
Deciduous +的这个层次我们会学到

32
00:02:19,264 --> 00:02:22,336
也许你从来没听过好朋友你只听过你

33
00:02:22,592 --> 00:02:26,432
好好OK总之最后的会跑到

34
00:02:27,200 --> 00:02:31,808
但是你就这么去接受他有这么一个函数叫好不会的

35
00:02:33,088 --> 00:02:38,720
Operator new会调用没了这句话有证据吗证据在这里鱼

36
00:02:39,232 --> 00:02:40,768
这个是VC

37
00:02:41,792 --> 00:02:42,304
版本

38
00:02:42,816 --> 00:02:45,888
里面的crt就所负的C的这个label

39
00:02:46,656 --> 00:02:50,496
Operator new的它的源代码这个是可以看到的

40
00:02:51,008 --> 00:02:52,032
调用malloc

41
00:02:54,336 --> 00:02:58,176
在不认识里头那也是也可以找到这一部分

42
00:02:58,688 --> 00:02:59,712
Operator New

43
00:03:00,224 --> 00:03:01,504
里面调用malloc

44
00:03:02,528 --> 00:03:05,344
那么在所有的几家家平台

45
00:03:05,600 --> 00:03:09,440
上面其实都是这样的我也不能全部裂给你看

46
00:03:09,696 --> 00:03:11,488
这是玻璃的

47
00:03:14,304 --> 00:03:20,448
Thermedic Memory location mail.ru扮演他扮演什么角色呢

48
00:03:20,704 --> 00:03:23,264
他分配的内存

49
00:03:23,520 --> 00:03:25,824
会是长什么样子呢

50
00:03:26,336 --> 00:03:27,104
这个样子

51
00:03:30,176 --> 00:03:34,272
你所要求的大小是这个钱是最快

52
00:03:34,784 --> 00:03:35,296
Site

53
00:03:37,088 --> 00:03:42,208
Malloc会搭配的放更多的东西最后再一次报给你

54
00:03:43,744 --> 00:03:47,328
10分有浅色是在第8个目的下会加的

55
00:03:48,096 --> 00:03:54,240
加完之后的还要调整还要加上上下这个橘子的砖红色这个架空

56
00:03:55,264 --> 00:04:00,384
装上去之后再调整到某一个边界就是这个绿色的部分

57
00:04:02,432 --> 00:04:08,576
这些细节我们会在另外一门课程内存管理财会很详细的具体到他们的一个的意义

58
00:04:09,344 --> 00:04:12,672
但是这边要告诉你就是你从这张图可以看得出来

59
00:04:12,928 --> 00:04:19,071
Redlock给你的人比你不能讲人比亚就比你所要的

60
00:04:19,327 --> 00:04:21,887
大小还要播不少东西

61
00:04:22,655 --> 00:04:26,239
至于他占的比例的就要看你要的这个大小多大

62
00:04:26,751 --> 00:04:29,823
因为附加的这些东西是基本固定的

63
00:04:31,103 --> 00:04:32,127
所以你要的

64
00:04:32,383 --> 00:04:34,431
你要的无疑会越大

65
00:04:34,943 --> 00:04:37,759
那么他所附加的东西的比例就越小

66
00:04:38,783 --> 00:04:41,087
你在意你要的越小

67
00:04:41,343 --> 00:04:44,159
附加的东西的比例就越大

68
00:04:45,695 --> 00:04:46,463
所以

69
00:04:47,487 --> 00:04:52,351
如果把这个附加上去的东西叫做叫做一个overhead

70
00:04:52,607 --> 00:04:54,143
额外的开销

71
00:04:54,655 --> 00:04:56,191
如果你这么称呼他的话

72
00:04:57,215 --> 00:04:57,727
那么

73
00:04:59,519 --> 00:05:01,567
面对小块内存

74
00:05:02,591 --> 00:05:04,127
Covid-19吧

75
00:05:05,663 --> 00:05:07,967
比例上就大小块的内存

76
00:05:09,503 --> 00:05:12,575
好这是我们要先对于没有一个基本了解

77
00:05:12,831 --> 00:05:17,183
至于为什么要加上这些overhead它有它的必要性

78
00:05:17,439 --> 00:05:19,743
另外的可承载具体他

79
00:05:21,791 --> 00:05:23,839
了解的这个东西之后

80
00:05:24,607 --> 00:05:25,631
我来看看

81
00:05:28,959 --> 00:05:35,103
在不同版本不同平台VC balenciga Lucy笔下的支线分配器

82
00:05:36,383 --> 00:05:39,199
他们能变出什么花样他们是

83
00:05:39,711 --> 00:05:41,247
这使用的闹钟吗

84
00:05:41,503 --> 00:05:43,807
还是他们有一些很独特的做法

85
00:05:45,599 --> 00:05:48,159
尿液这个是vc6

86
00:05:49,183 --> 00:05:49,951
笔下的

87
00:05:50,207 --> 00:05:51,999
标准库的

88
00:05:52,255 --> 00:05:53,535
我找到了

89
00:05:54,303 --> 00:05:55,327
四个容器

90
00:05:55,583 --> 00:06:00,447
其他容器也都一样啊我也是不能全部列出来吗我就挑了四个给你看

91
00:06:01,727 --> 00:06:03,775
Vector abstract concept

92
00:06:04,543 --> 00:06:05,823
他们

93
00:06:06,335 --> 00:06:08,639
默认使用的分配器

94
00:06:09,663 --> 00:06:12,223
都是OK的紫色的这个

95
00:06:14,015 --> 00:06:17,087
因此这次我们就找到我们要去观察的目标了

96
00:06:17,343 --> 00:06:20,159
这是叫做Kate这个class

97
00:06:20,927 --> 00:06:22,207
那么他想必是个模板

98
00:06:23,231 --> 00:06:24,255
Vc6

99
00:06:25,279 --> 00:06:28,863
到了vc2013 vc2015区一样

100
00:06:29,375 --> 00:06:30,911
只是形式可能

101
00:06:31,935 --> 00:06:33,727
他的Class的写法人

102
00:06:34,495 --> 00:06:35,775
形似不太

103
00:06:36,031 --> 00:06:38,335
一致不太像这个让投影片

104
00:06:38,847 --> 00:06:40,639
其实结论都是一样的

105
00:06:42,431 --> 00:06:48,063
所以我们现在要去观察在vc6底下的这个Locate是怎么做的

106
00:06:48,831 --> 00:06:54,975
它的实现如下你可以在这边我都要写出来了你也可以在自己找到这个头文件

107
00:06:55,231 --> 00:07:01,375
前面已经告诉过你这些头文件分布在什么地方了你也可以找到家exbury可以找到

108
00:07:04,447 --> 00:07:09,567
我这16的比如果是vc2015当你找到这个代码其他会跟这个有一点点不同

109
00:07:10,847 --> 00:07:12,895
好我们看到这个OK的

110
00:07:14,431 --> 00:07:18,527
每一个分配器标准库规格初打开来告诉你

111
00:07:18,783 --> 00:07:22,623
分配器最重要的两个函数一个就是二楼梯

112
00:07:23,135 --> 00:07:24,927
一个就是OK的

113
00:07:25,695 --> 00:07:27,487
那我们这就是我们观察的目标

114
00:07:27,743 --> 00:07:28,511
找到了

115
00:07:29,535 --> 00:07:31,839
Allocate做什么事情呢

116
00:07:32,095 --> 00:07:35,423
他调用了这个函数而这个函数定义在下头

117
00:07:35,679 --> 00:07:36,191
所以

118
00:07:36,447 --> 00:07:37,471
往下看

119
00:07:37,983 --> 00:07:44,127
发现他就是调用operator new真正要分配内存的时候他是调用这个

120
00:07:45,919 --> 00:07:50,271
而operator你刚刚一开始我已经告诉过你他里面都有没了

121
00:07:51,807 --> 00:07:52,831
结论出来了

122
00:07:54,367 --> 00:08:00,511
在VC底下的VC所提供的分配器当他要分

123
00:08:00,767 --> 00:08:06,911
分配内存的时候他是调用了一层一层下去最后结论是要用

124
00:08:07,167 --> 00:08:07,679
Block

125
00:08:09,215 --> 00:08:13,823
America会得到死队是什么情况啊然后已经告诉你了

126
00:08:14,591 --> 00:08:16,895
会有一些overhead跑出来

127
00:08:19,455 --> 00:08:21,759
好再回来

128
00:08:22,015 --> 00:08:24,319
再回到这个VC的分配器

129
00:08:24,575 --> 00:08:28,927
那他的clk的那就在回收内存的时候他家用的是什么

130
00:08:29,439 --> 00:08:31,999
好像要用的是operator delete

131
00:08:32,767 --> 00:08:35,327
Operator delete掉用

132
00:08:35,839 --> 00:08:37,375
这是CT的辐射

133
00:08:39,423 --> 00:08:40,447
尼罗河对应浮力吗

134
00:08:43,519 --> 00:08:44,031
所以

135
00:08:45,823 --> 00:08:47,103
我这边做了一个整理

136
00:08:47,615 --> 00:08:53,759
在VC里的malloc只是以afternoon of weight

137
00:08:54,015 --> 00:08:58,879
去完成了OK OK

138
00:09:00,159 --> 00:09:02,719
没有任何特殊设计

139
00:09:05,535 --> 00:09:07,071
没有任何突出设计

140
00:09:08,351 --> 00:09:09,887
所以如果

141
00:09:11,679 --> 00:09:14,239
你放的叫我在第1讲一遍

142
00:09:14,751 --> 00:09:17,567
我的每个容器我都放100万个元素

143
00:09:18,847 --> 00:09:21,919
子元素是小小的一个一个东西呀我记得我的地址是

144
00:09:22,175 --> 00:09:23,455
我说我放了

145
00:09:24,223 --> 00:09:25,759
有时候我放肆吃

146
00:09:26,783 --> 00:09:30,111
虽然其实它的大小只有四个自己

147
00:09:30,367 --> 00:09:35,743
他可能后面带着一长串的字符串但是它本身只是一个指针而已

148
00:09:37,791 --> 00:09:38,815
所以

149
00:09:39,071 --> 00:09:41,631
我们通常放的元素都是小小

150
00:09:43,167 --> 00:09:47,519
元素小小的表示o为head哦那开销较大把的

151
00:09:48,287 --> 00:09:49,567
等我讲过这个概念

152
00:09:50,335 --> 00:09:56,479
因此你放100万个元素进去的时候你消耗额外消耗的内存的

153
00:09:56,991 --> 00:09:59,295
可能比你的100万个元素还要多

154
00:10:00,319 --> 00:10:01,599
这个太可怕了

155
00:10:03,135 --> 00:10:05,951
NBC情况就是这样的重新加载

156
00:10:06,463 --> 00:10:07,743
分配器就是这样

157
00:10:12,607 --> 00:10:15,679
好了吗在这一页的右下角

158
00:10:16,959 --> 00:10:19,775
我试着去现在我们已经看到它的源代码了

159
00:10:20,287 --> 00:10:26,431
所以我们有能力直接用它虽然我不鼓励大家这么用好也没有必要怎么用但是我们来试试看

160
00:10:26,687 --> 00:10:27,967
现在我要分配

161
00:10:28,223 --> 00:10:30,271
512个

162
00:10:32,831 --> 00:10:36,159
这么做的话那我已经知道这个分别叫这个名字了

163
00:10:36,927 --> 00:10:37,951
所以我就这么写

164
00:10:38,207 --> 00:10:42,047
Hellokitty间挂号int因为我现在要分配的是整数

165
00:10:43,839 --> 00:10:44,351
好

166
00:10:45,119 --> 00:10:47,423
怎这样就是一个态度的名称

167
00:10:47,679 --> 00:10:48,959
他本来是一个模板

168
00:10:49,215 --> 00:10:49,983
类模板

169
00:10:50,239 --> 00:10:53,823
加上的参数之后他就真的变成一个类的名称了

170
00:10:54,591 --> 00:11:00,735
直接加小括号也许你不熟悉这种语法那你现在马上要去做其他因为这个在后

171
00:11:00,991 --> 00:11:05,087
后面的一站式出现这种特殊语法什么特殊语法

172
00:11:05,343 --> 00:11:09,183
一个MM后面直接加空小括号

173
00:11:10,207 --> 00:11:11,231
圆括号

174
00:11:11,999 --> 00:11:13,791
这样就形成了一个

175
00:11:14,047 --> 00:11:14,815
WhatsApp

176
00:11:15,839 --> 00:11:17,375
对临时对象

177
00:11:17,887 --> 00:11:18,655
没有名称

178
00:11:20,191 --> 00:11:23,007
那我在这个例子里面主要是饭所以我不打算

179
00:11:23,263 --> 00:11:28,639
做出一个有名称的分配器出来说我不要名称这样就是一个option

180
00:11:30,175 --> 00:11:34,527
我通过offer就可以来调用这里的树

181
00:11:35,551 --> 00:11:41,695
我观察因为我们就看到源代码了我观察那我就用它的话那我要指明要多少

182
00:11:43,487 --> 00:11:44,511
后面呢

183
00:11:45,279 --> 00:11:46,303
这个很有意思

184
00:11:47,583 --> 00:11:50,399
他这边设计出一个参数

185
00:11:51,679 --> 00:11:53,471
却没有参数名称

186
00:11:53,983 --> 00:11:55,775
你随便给他什么都可以

187
00:11:56,799 --> 00:11:59,103
他其实要的是他想知道

188
00:11:59,359 --> 00:12:01,151
借由这一部分的知道

189
00:12:01,407 --> 00:12:03,967
你要512个

190
00:12:04,223 --> 00:12:08,575
好我把四个什么呢他要家有第2个参数一个

191
00:12:09,599 --> 00:12:12,671
一个一个小技巧来知道这个

192
00:12:13,695 --> 00:12:15,231
510个什么

193
00:12:17,535 --> 00:12:20,095
在这部分的小技巧跟我们现在

194
00:12:20,351 --> 00:12:23,423
分配主题无关我就不讲下去

195
00:12:24,447 --> 00:12:25,727
那么既然他

196
00:12:27,263 --> 00:12:30,335
不在乎你穿什么东西给他那我们就穿一个零好了

197
00:12:32,383 --> 00:12:33,663
好这就是我

198
00:12:33,919 --> 00:12:34,943
直接使用

199
00:12:35,199 --> 00:12:36,735
分配器必须这么写

200
00:12:38,015 --> 00:12:39,551
写出种东西

201
00:12:40,063 --> 00:12:44,159
我太难了为什么不多必须看过源代码才能够写出来

202
00:12:44,927 --> 00:12:46,975
所以他们就不鼓励大家

203
00:12:47,231 --> 00:12:48,511
直接用分配器

204
00:12:50,559 --> 00:12:53,119
这样就分配得到的一个屁

205
00:12:53,631 --> 00:12:56,191
指针刚刚我已经告诉过你了

206
00:12:56,447 --> 00:13:02,079
看了源代码能发现其实这个分配就是分配512个整数就是由malloc分配

207
00:13:03,103 --> 00:13:04,127
Malloc分配

208
00:13:04,639 --> 00:13:05,919
不要规划呢

209
00:13:06,175 --> 00:13:06,943
样的

210
00:13:07,199 --> 00:13:08,991
我们通过这个分配器

211
00:13:10,015 --> 00:13:12,063
建立一个临时对象

212
00:13:12,319 --> 00:13:15,135
有了对象才能够调用里面的成员函数

213
00:13:16,415 --> 00:13:18,719
那我调用这个OK

214
00:13:19,999 --> 00:13:21,535
不但要把指针归还

215
00:13:22,559 --> 00:13:23,583
还要告诉他

216
00:13:24,351 --> 00:13:26,911
我当初拿的是510个

217
00:13:28,191 --> 00:13:30,239
这件事情就是致命伤

218
00:13:31,007 --> 00:13:37,151
没有人能够去记住当初我要了一块内存它到底多大

219
00:13:39,199 --> 00:13:43,039
没有人有有有有心思去记这些东西

220
00:13:43,295 --> 00:13:45,343
我们只会记得指针

221
00:13:45,855 --> 00:13:51,999
当初分配得到了一个指针还说就是还这跟自己可是他却要

222
00:13:52,255 --> 00:13:53,023
要求我们

223
00:13:53,535 --> 00:13:56,095
要告诉他当初要510

224
00:13:57,887 --> 00:13:59,935
这就是他很难用的地方

225
00:14:01,215 --> 00:14:02,239
打开蓝牙

226
00:14:04,543 --> 00:14:08,383
但是如果容器需用它如容器就没有这种困扰

227
00:14:09,151 --> 00:14:12,991
在国外现在先不深入下去慢慢体会

228
00:14:13,247 --> 00:14:15,807
我后面还会提交请你会有感受

229
00:14:17,087 --> 00:14:18,111
所以

230
00:14:18,367 --> 00:14:19,391
做一个结论

231
00:14:19,903 --> 00:14:26,047
VC的分配器没有任何独特设计它就是调用C的malloc

232
00:14:26,303 --> 00:14:29,631
Free来分配和释放内存

233
00:14:30,399 --> 00:14:32,447
而且它的接口设计呢

234
00:14:32,703 --> 00:14:35,263
不太好使了我们不太好直接用

235
00:14:35,519 --> 00:14:37,567
但是如果是容器去用

236
00:14:37,823 --> 00:14:38,847
就没问题

237
00:14:42,687 --> 00:14:44,223
这是VC的版本

238
00:14:48,063 --> 00:14:49,599
Analysis这个样子

239
00:14:50,111 --> 00:14:56,255
我手上的15.0这也是比较早的版本了

240
00:14:57,279 --> 00:15:01,375
我找到他这里地方我列出三个容器

241
00:15:02,655 --> 00:15:08,543
它的源代码它在声明的时候第2个模板参数

242
00:15:09,055 --> 00:15:11,615
这样我这个没有人看得懂

243
00:15:13,151 --> 00:15:18,527
必须去查这个它独特的这些子弹是什么意思我认识一家独特的

244
00:15:18,783 --> 00:15:20,319
查出来的结果

245
00:15:20,831 --> 00:15:23,135
最后转换过来是下面这样

246
00:15:23,647 --> 00:15:24,415
我知道了

247
00:15:24,927 --> 00:15:26,719
所有的容器

248
00:15:27,231 --> 00:15:29,535
第2个模板参数

249
00:15:30,815 --> 00:15:34,399
默认都是a locator紫色的这个

250
00:15:34,911 --> 00:15:36,703
于是我们要去看

251
00:15:37,727 --> 00:15:41,311
我认识一家家里面的这个这一个class

252
00:15:41,823 --> 00:15:43,359
看看他有没有什么

253
00:15:43,615 --> 00:15:44,639
福特的设计

254
00:15:49,503 --> 00:15:51,039
找到了源代码在这里

255
00:15:52,063 --> 00:15:54,111
Oranssi 5.0

256
00:15:55,391 --> 00:15:56,671
他的头文件

257
00:15:56,927 --> 00:15:58,975
小Memory的STL

258
00:15:59,231 --> 00:16:01,279
竟然有这个人生

259
00:16:01,791 --> 00:16:04,095
文件名参加点STL

260
00:16:05,375 --> 00:16:06,143
很特点

261
00:16:07,423 --> 00:16:13,567
好这一个locator我们就根据刚刚的思维我们在BCD下

262
00:16:13,823 --> 00:16:19,967
怎么做我们现在不认识一下我们也去找找看这一个最重要的两

263
00:16:20,223 --> 00:16:22,015
好的数字Locate an

264
00:16:22,271 --> 00:16:23,039
OK

265
00:16:24,831 --> 00:16:30,207
Allocate这个函数里头做什么事呢让他要分配内存的时候

266
00:16:30,463 --> 00:16:31,999
它调用operator New

267
00:16:33,279 --> 00:16:34,047
也就是

268
00:16:34,303 --> 00:16:35,839
往下调用malloc

269
00:16:37,887 --> 00:16:38,911
Relocate

270
00:16:39,423 --> 00:16:41,727
他分配的他后面要

271
00:16:41,983 --> 00:16:44,799
要释放内存也要回收

272
00:16:45,055 --> 00:16:46,079
为什么时候

273
00:16:46,335 --> 00:16:48,383
它是调用operator delete

274
00:16:49,407 --> 00:16:50,943
更往下就是福利

275
00:16:51,455 --> 00:16:52,479
Siri

276
00:16:54,271 --> 00:16:54,783
所以

277
00:16:56,831 --> 00:17:01,951
看起来跟VC差不多么写法适当然各家写法不太一样

278
00:17:02,207 --> 00:17:06,047
在做的事情都一样做一个结论是什么呢

279
00:17:07,583 --> 00:17:09,887
播联系家家的Locate

280
00:17:10,655 --> 00:17:15,007
只是以一

281
00:17:15,263 --> 00:17:17,055
也就是没到可用服务

282
00:17:17,567 --> 00:17:19,871
来完成两个重要的函数

283
00:17:20,383 --> 00:17:22,687
没有任何特殊设计

284
00:17:24,479 --> 00:17:25,503
没事相同

285
00:17:27,295 --> 00:17:30,623
他又再一次让我们想到一个事情了

286
00:17:31,135 --> 00:17:32,159
我的荣幸

287
00:17:32,415 --> 00:17:34,207
如果放100万个元素

288
00:17:34,463 --> 00:17:36,255
而且这个每个元素是小小的

289
00:17:38,047 --> 00:17:39,583
由于这些元素

290
00:17:40,095 --> 00:17:43,935
为什么分配的时候都是用malloc得到刚刚告诉你了

291
00:17:45,471 --> 00:17:47,775
所以他的overhead额外开销

292
00:17:49,311 --> 00:17:52,383
由于你的区块小小的醉鹅还下着大大的

293
00:17:53,663 --> 00:17:55,967
这可能是一个非常困扰的事情

294
00:18:03,391 --> 00:18:04,159
这边

295
00:18:04,415 --> 00:18:06,975
示范一次直接使用

296
00:18:07,487 --> 00:18:09,023
后联系的分配器

297
00:18:10,815 --> 00:18:13,887
用法案刚刚的VC完全一样

298
00:18:15,935 --> 00:18:17,471
但是这个玻璃c

299
00:18:17,983 --> 00:18:20,799
稍稍稍稍的贴心一点

300
00:18:21,823 --> 00:18:26,943
他在这个allocate的第2参数有一个默认值是0

301
00:18:29,503 --> 00:18:31,295
回顾一下刚刚的VC

302
00:18:33,599 --> 00:18:36,159
VC也需要第2参数

303
00:18:37,183 --> 00:18:37,951
Hello Kitty

304
00:18:38,463 --> 00:18:39,743
1234567

305
00:18:39,999 --> 00:18:41,279
他没有默认值

306
00:18:43,583 --> 00:18:47,423
他是不在乎你成什么给他但是他没有默认值

307
00:18:47,935 --> 00:18:53,311
所以在VC我们只好自己给一个订那个50个100都一样无所谓

308
00:18:56,639 --> 00:19:02,783
老毛这是比较贴心啊有一个默认那你就不用给了

309
00:19:03,039 --> 00:19:04,319
感觉就好多了

310
00:19:09,695 --> 00:19:11,743
好子是VC根博Nancy

311
00:19:12,767 --> 00:19:14,303
到不了台糖肯定是

312
00:19:19,679 --> 00:19:20,703
任牧师

313
00:19:21,215 --> 00:19:26,591
2.9版二年九一我成人奖也就是我们后面要讲的这个

314
00:19:27,359 --> 00:19:31,199
源代码的主要供应者和这个版本

315
00:19:31,455 --> 00:19:37,087
我提过这是我非常欣赏的一个版本因为它的可读性非常高

316
00:19:39,391 --> 00:19:43,743
这个Lucy 2.9版舒服的标准和他的额头开的实现是这样

317
00:19:44,255 --> 00:19:45,279
我们找到了

318
00:19:45,535 --> 00:19:46,815
也是叫做OK的

319
00:19:47,071 --> 00:19:50,399
因为标准库规格搜索就是要叫做

320
00:19:50,655 --> 00:19:52,959
Locator这个名称

321
00:19:54,239 --> 00:19:56,287
两个重要的还是塑造了

322
00:19:58,079 --> 00:19:59,871
他们所做的事情呢

323
00:20:02,431 --> 00:20:03,967
我看看

324
00:20:07,807 --> 00:20:08,831
Allocate

325
00:20:10,367 --> 00:20:11,903
为什么我把他让我跑到

326
00:20:12,415 --> 00:20:12,927
想看

327
00:20:13,439 --> 00:20:13,951
哦

328
00:20:14,207 --> 00:20:18,559
非条线化的没有非常的理想啊这一个函数

329
00:20:19,071 --> 00:20:22,399
调用了这一个浅蓝色的这一个函数

330
00:20:22,655 --> 00:20:26,751
这一个函数才是上面这个说这个起点画的不太好

331
00:20:28,031 --> 00:20:29,055
厦门这里

332
00:20:31,103 --> 00:20:34,175
我在整理一次这一个分配器

333
00:20:34,687 --> 00:20:40,831
重要的这个函数l o o k的所做的事情发出调用显然是这个这一个的定义

334
00:20:41,087 --> 00:20:41,855
上海

335
00:20:43,135 --> 00:20:47,999
在我们要看到了他也是调用好不会在陆跟刚刚的VC

336
00:20:48,255 --> 00:20:50,815
DC都一样的Lucy也是这样

337
00:20:52,863 --> 00:20:54,655
另外一个函数叫b o o k

338
00:20:56,447 --> 00:20:59,775
他所做的事情那么这条线已画的不太好也画错了

339
00:21:00,031 --> 00:21:03,871
起点应该在这里这个函数要用着它

340
00:21:04,127 --> 00:21:05,919
它的定义在上面

341
00:21:06,175 --> 00:21:07,711
上面这个定义看到

342
00:21:08,223 --> 00:21:08,991
也是调用

343
00:21:09,503 --> 00:21:10,783
Operator delete

344
00:21:12,063 --> 00:21:13,855
那你头就是天赋异了

345
00:21:15,391 --> 00:21:16,672
所以

346
00:21:16,928 --> 00:21:17,696
结论是什么

347
00:21:18,464 --> 00:21:21,280
Bcbc knuth 1391样

348
00:21:21,792 --> 00:21:25,376
他们的分配器最终就是使用

349
00:21:25,888 --> 00:21:30,496
基本工具没walking服力来分配和释放内存

350
00:21:30,752 --> 00:21:33,312
因此会带来的巨大量的

351
00:21:33,568 --> 00:21:34,848
额外开销

352
00:21:38,432 --> 00:21:44,064
这些额外开销所占的比例我们只是关心的是比例的问题而不是真正大小的问题

353
00:21:45,344 --> 00:21:47,648
如果你的机会小

354
00:21:48,416 --> 00:21:50,208
开销的比例就大

355
00:21:50,464 --> 00:21:52,000
我们就不能忍受

356
00:21:53,792 --> 00:21:55,328
如果你的区块大

357
00:21:56,096 --> 00:21:58,400
开销所占的比例就小

358
00:21:58,912 --> 00:22:00,192
就可以接受

359
00:22:02,240 --> 00:22:07,616
在现实生活中到底这个区块通常是大一小的

360
00:22:08,128 --> 00:22:09,408
通常小

361
00:22:10,688 --> 00:22:12,480
那就开销大

362
00:22:12,736 --> 00:22:14,784
那就不太能接受

363
00:22:15,040 --> 00:22:17,088
华南这是一个致命伤

364
00:22:17,600 --> 00:22:19,904
Vcn3000

365
00:22:20,928 --> 00:22:21,952
不太理想

366
00:22:25,536 --> 00:22:27,840
Lucy

367
00:22:29,376 --> 00:22:32,192
在定义这个分配器的时候

368
00:22:34,496 --> 00:22:40,384
他在他的头文件里头说明的这么一段说明我把他直接掏出来给他俩看

369
00:22:42,688 --> 00:22:43,456
他说

370
00:22:43,712 --> 00:22:48,576
You not use this file不要使用这一个法

371
00:22:51,648 --> 00:22:52,160
他说

372
00:22:53,440 --> 00:22:54,976
他这个STL

373
00:22:56,000 --> 00:23:02,144
各路cas9帮助是sgi这家公司发展所以这边说

374
00:23:02,400 --> 00:23:03,680
S60L

375
00:23:03,936 --> 00:23:06,752
所使用的是另一个OK的

376
00:23:07,264 --> 00:23:11,104
原来还有另一个OK的相比较精巧的设计了

377
00:23:13,408 --> 00:23:14,176
他又说

378
00:23:14,432 --> 00:23:20,576
这一个发了这个头文件没有被韩入被引入到任何其

379
00:23:20,832 --> 00:23:21,600
其他的

380
00:23:22,368 --> 00:23:22,880
地方去

381
00:23:23,904 --> 00:23:24,928
也就是说

382
00:23:26,720 --> 00:23:27,744
他在这边告诉你

383
00:23:28,000 --> 00:23:30,048
他虽然做出了这一个

384
00:23:30,304 --> 00:23:34,400
符合标准规格书的这一个分配器

385
00:23:34,912 --> 00:23:38,240
但是他自己的容器从来不去用它

386
00:23:41,056 --> 00:23:46,176
那想必这个这些容器用了一个可能应该

387
00:23:46,432 --> 00:23:48,992
是比较好的另外一个分配器了

388
00:23:50,016 --> 00:23:52,064
我们去看看

389
00:23:59,232 --> 00:24:01,792
Nownews 2.9

390
00:24:03,840 --> 00:24:05,120
这么多的容器

391
00:24:06,912 --> 00:24:09,472
Best best best best

392
00:24:11,008 --> 00:24:13,824
他们所使用的分配器

393
00:24:14,080 --> 00:24:15,616
模板的23数这边

394
00:24:16,384 --> 00:24:19,712
默认值都是AC

395
00:24:23,040 --> 00:24:29,184
而刚刚看的那一个叫allocation2不一样

396
00:24:30,464 --> 00:24:32,000
这就呼应这边所说的

397
00:24:33,536 --> 00:24:36,352
他虽然给了这一个其实他都没有在用他

398
00:24:36,608 --> 00:24:37,888
有的是另一个

399
00:24:40,448 --> 00:24:42,752
终于让我们感觉到一点曙光

400
00:24:45,312 --> 00:24:46,592
现在就是分配器

401
00:24:46,848 --> 00:24:48,128
看起来都蛮烂的

402
00:24:49,664 --> 00:24:50,944
只是改头换面

403
00:24:51,456 --> 00:24:53,760
把妹那个跟服务器的包装包装

404
00:24:54,272 --> 00:25:00,416
由于这些包装反应速度还变慢了执行的时候速度反而变慢了1.17只

405
00:25:00,672 --> 00:25:01,952
直接调用任何抗辐射

406
00:25:02,464 --> 00:25:04,512
更多的包装就更慢

407
00:25:06,304 --> 00:25:11,424
而我们终于看到啊是不是有原来的路是因为他有一个

408
00:25:11,680 --> 00:25:16,288
放应该联想和想象是很棒的一个分类器

409
00:25:18,592 --> 00:25:24,736
好所以这个所有的容器在跟我说底下用的这一个叫a l l

410
00:25:24,992 --> 00:25:27,808
Oc的这个分配器长什么样子呢

411
00:25:28,576 --> 00:25:29,088
这样

412
00:25:30,880 --> 00:25:32,928
它的源代码

413
00:25:33,696 --> 00:25:39,840
很有价值说说呈现出来的行为模式最后就是这个样子

414
00:25:40,608 --> 00:25:42,656
但是那个源代码的分析呢

415
00:25:42,912 --> 00:25:44,960
获得更多的讨论我要在

416
00:25:45,216 --> 00:25:47,520
内存管理这种可在具体

417
00:25:47,776 --> 00:25:49,824
现在这边直接画出

418
00:25:51,360 --> 00:25:57,504
他的这个怎么运行的一个某一个阶段的一个情况让大家来理解

419
00:25:58,528 --> 00:26:01,088
运行的模式

420
00:26:02,368 --> 00:26:05,184
是一个特殊的分配器

421
00:26:07,232 --> 00:26:09,024
它的主要诉求

422
00:26:10,304 --> 00:26:12,352
我们提过我们前面提过

423
00:26:12,608 --> 00:26:16,704
所有分配内存的最后的动作一定是malloc

424
00:26:19,008 --> 00:26:20,800
最主要的诉求是

425
00:26:21,056 --> 00:26:24,384
还要尽量减少malloc次数

426
00:26:26,176 --> 00:26:28,992
因为没了口就会带着iPad和外开销

427
00:26:29,248 --> 00:26:31,040
我不想要那个额外开销

428
00:26:31,808 --> 00:26:34,368
可不可以不要额外开销呢

429
00:26:34,624 --> 00:26:35,904
我们要想一想

430
00:26:37,952 --> 00:26:40,000
这些额外开销到底在做什么

431
00:26:40,256 --> 00:26:41,536
再回来前面这个图来

432
00:26:47,936 --> 00:26:49,984
这些额外开销理念

433
00:26:51,264 --> 00:26:54,336
最重要的这个值得讲的就是这个

434
00:26:54,592 --> 00:26:57,664
上下两个我们习惯叫哭泣

435
00:26:58,944 --> 00:27:02,528
Cookie记录的这个整块的大小

436
00:27:04,064 --> 00:27:05,088
这是必要的

437
00:27:05,856 --> 00:27:08,672
因为你用malloc去拿内存的时候

438
00:27:10,976 --> 00:27:13,024
你累了可是他一个指针

439
00:27:14,560 --> 00:27:18,912
还的时候只有还这个指针不需要告诉他大小

440
00:27:19,168 --> 00:27:21,472
这个大小就是记录在cookie里

441
00:27:21,728 --> 00:27:23,008
已经记起来了

442
00:27:23,776 --> 00:27:26,848
Free free这个函数它能够救找到股票

443
00:27:27,104 --> 00:27:28,640
要知道他要回收

444
00:27:29,664 --> 00:27:30,944
拨打一会连锁

445
00:27:34,528 --> 00:27:40,672
由于malloc是给各式各样的人在不同的需求使用了要的大小有大有小有大游戏

446
00:27:40,928 --> 00:27:43,232
所以需要cookie来记录

447
00:27:45,792 --> 00:27:48,096
但是我们来想一想容器

448
00:27:51,680 --> 00:27:55,776
容器的元素大小是一样的

449
00:27:57,824 --> 00:28:01,664
不管容器有几个元素元素的大小是一样的

450
00:28:03,200 --> 00:28:03,968
所以

451
00:28:04,736 --> 00:28:09,600
似乎可以不必把这个大小在每个元素都附带的记者

452
00:28:10,624 --> 00:28:14,720
比如说亚100万个元素每个元素18个字节

453
00:28:15,744 --> 00:28:21,120
前头却带着一小块东西还要去记录我这一块18个自己

454
00:28:22,912 --> 00:28:26,240
100万个都这样记录没有必要没有必要

455
00:28:27,776 --> 00:28:29,824
所以似乎在

456
00:28:30,592 --> 00:28:34,688
容器的这个应用情况之下的可以不需要估计

457
00:28:37,760 --> 00:28:38,272
好

458
00:28:38,784 --> 00:28:39,552
现在

459
00:28:39,808 --> 00:28:41,600
石墨烯的这个分配器

460
00:28:41,856 --> 00:28:43,392
就从这个地方左手

461
00:28:44,672 --> 00:28:45,696
不要哭泣

462
00:28:46,464 --> 00:28:49,280
还要尽量减少没有那次数

463
00:28:49,792 --> 00:28:50,816
怎么做呢

464
00:28:53,376 --> 00:28:55,424
他设计的16条链表

465
00:28:57,216 --> 00:29:02,336
每一条链表负责的某一种特定大小的区块用链表串起来

466
00:29:06,176 --> 00:29:07,456
那么他们的责任

467
00:29:07,968 --> 00:29:13,856
分数是怎么样的10条链表负责的是八个字节这种大小

468
00:29:14,880 --> 00:29:16,928
17号量表

469
00:29:17,184 --> 00:29:21,792
高雄苓算起了17号链表那就是其实是第8条

470
00:29:22,304 --> 00:29:24,864
零到70这个七是第8条

471
00:29:25,888 --> 00:29:30,240
他负责的是756 56个自己这种大小

472
00:29:32,032 --> 00:29:33,056
依此类推

473
00:29:34,080 --> 00:29:39,200
最后一个是15号零到15岁这是第16条

474
00:29:39,712 --> 00:29:43,040
第16条呢负责的每一个区块是

475
00:29:44,832 --> 00:29:47,136
16乘以828

476
00:29:49,952 --> 00:29:53,792
这个这些数字突然跑出来可能让你有点头昏脑胀

477
00:29:54,816 --> 00:29:56,096
我整理一下就是

478
00:29:56,864 --> 00:29:59,168
这条链表负责八个白的

479
00:29:59,936 --> 00:30:04,544
Cz条链表负责16 24 32

480
00:30:05,824 --> 00:30:07,360
一八的倍数成长

481
00:30:10,944 --> 00:30:12,480
所有的容器

482
00:30:12,992 --> 00:30:17,344
刚刚需要内存的时候后来跟这个分配器要内存

483
00:30:20,928 --> 00:30:23,232
容器的元素大小

484
00:30:23,744 --> 00:30:26,304
会被调整到八的倍数

485
00:30:27,328 --> 00:30:28,352
比如说50

486
00:30:29,120 --> 00:30:30,656
有个调整到56

487
00:30:31,424 --> 00:30:33,472
调整到56之后

488
00:30:34,240 --> 00:30:39,872
这个分配器就会看看56应该是某一个链表来不得了

489
00:30:40,640 --> 00:30:44,736
这个链表有没有里头有没有关内存那为什么会呢

490
00:30:45,248 --> 00:30:47,552
如果没有

491
00:30:48,320 --> 00:30:49,344
他才具根

492
00:30:51,136 --> 00:30:51,904
操作系统

493
00:30:52,416 --> 00:30:53,696
也就是用malloc

494
00:30:54,464 --> 00:30:55,488
要一大块

495
00:30:56,000 --> 00:30:58,304
要一把会来之后做切割

496
00:31:00,608 --> 00:31:05,472
然后给出一块切出来东西用链表存起来单向链表存起来

497
00:31:08,032 --> 00:31:11,616
非这个贴出来的每一块就不大

498
00:31:13,920 --> 00:31:15,712
我们前面提到

499
00:31:16,480 --> 00:31:18,528
让我们受不了了就是这个

500
00:31:19,808 --> 00:31:20,576
额外开销

501
00:31:21,344 --> 00:31:23,392
主要就是表现在固体上面

502
00:31:24,416 --> 00:31:25,184
Cookie

503
00:31:26,464 --> 00:31:29,792
在很多的平台上面

504
00:31:31,072 --> 00:31:34,912
在很多的新下家平台上面空气是上下都有

505
00:31:36,960 --> 00:31:38,752
为什么要上下都有呢

506
00:31:39,264 --> 00:31:41,568
一般人可能会想上面有就好了

507
00:31:41,824 --> 00:31:43,872
上下的只是完全一样的

508
00:31:44,384 --> 00:31:49,248
这些这些细节都我们到内存管理的课程再去给他

509
00:31:50,016 --> 00:31:51,552
这1边的告诉你

510
00:31:52,064 --> 00:31:54,368
内存cookie是上下都有

511
00:31:54,624 --> 00:31:55,648
因此

512
00:31:56,672 --> 00:31:58,976
消耗的是自己

513
00:32:01,024 --> 00:32:02,048
所以

514
00:32:02,304 --> 00:32:03,328
如果

515
00:32:05,888 --> 00:32:06,912
后来长出来

516
00:32:08,960 --> 00:32:11,264
我选择一个容器

517
00:32:12,544 --> 00:32:14,848
我的元素放100万个

518
00:32:16,896 --> 00:32:20,224
我可以省掉多少外开销呢

519
00:32:20,480 --> 00:32:23,808
由于这100万个元素都不大

520
00:32:24,064 --> 00:32:24,576
OK

521
00:32:25,856 --> 00:32:27,136
我可以省

522
00:32:27,392 --> 00:32:29,184
800万个字节怎么走

523
00:32:30,720 --> 00:32:32,000
这可不是小数目

524
00:32:34,304 --> 00:32:34,816
这是

525
00:32:35,072 --> 00:32:36,096
16c的

526
00:32:36,608 --> 00:32:40,192
特别叫做a l l a c的这一个分配器

527
00:32:41,216 --> 00:32:45,056
所展现的行为模式以及它所带来的好处

528
00:32:46,080 --> 00:32:47,360
16条

529
00:32:53,504 --> 00:32:59,648
其实我刚刚的那个是那个分析说100万个元素可以省掉800万个

530
00:33:00,672 --> 00:33:01,440
字节

531
00:33:02,208 --> 00:33:03,744
帮助cookie用得着

532
00:33:04,256 --> 00:33:06,048
这些东西可以省掉

533
00:33:06,304 --> 00:33:08,096
这个是只是一个

534
00:33:08,352 --> 00:33:08,864
一个

535
00:33:09,120 --> 00:33:11,680
直观的一个表达

536
00:33:12,960 --> 00:33:16,544
因为他这里终究还是要用malloc去哪内存

537
00:33:18,336 --> 00:33:21,408
所以每次去拿还是会带着一个

538
00:33:22,688 --> 00:33:28,064
我这个图的表现是这样比如说这个第3号令13号链表这一串

539
00:33:29,088 --> 00:33:34,208
这一串的这么一大块当初就是由malloc一次拿到的

540
00:33:34,464 --> 00:33:36,512
所以他的上头有一个cookie

541
00:33:36,768 --> 00:33:38,304
下图有一个股票

542
00:33:39,072 --> 00:33:41,120
Cookie还是少不了费用

543
00:33:41,888 --> 00:33:47,008
只是数量会少很多因为这个要一大块就可以切成很多个小块

544
00:33:47,264 --> 00:33:48,288
这些小块

545
00:33:48,544 --> 00:33:49,568
就不太熟悉了

546
00:33:51,616 --> 00:33:52,640
杠杠的

547
00:33:52,896 --> 00:33:54,688
800万只是一个

548
00:33:55,200 --> 00:33:56,992
一个给你的一个一个

549
00:33:57,248 --> 00:33:59,040
概念有一种印象

550
00:34:02,880 --> 00:34:04,928
我们感觉这一个分配给非常好

551
00:34:05,952 --> 00:34:12,096
当然它也有缺点了这个缺点是必须看了源代码才能够分析出来的而我们非现在

552
00:34:14,144 --> 00:34:15,936
只讲这个运作的

553
00:34:16,192 --> 00:34:18,752
请问我是他的源代码

554
00:34:19,008 --> 00:34:24,896
你这个是一个很独特的一个主题所以要放到内存管理去讲他有他的一个缺陷

555
00:34:28,480 --> 00:34:30,784
那个缺陷的也不会带来太

556
00:34:32,064 --> 00:34:35,392
总是有那么一个缺陷可是不会带来太大的影响

557
00:34:36,160 --> 00:34:37,440
暂时就这样

558
00:34:39,232 --> 00:34:40,000
所以

559
00:34:41,024 --> 00:34:46,656
那当然经过了这些比较我们比较能为细胞Nancy更细的

560
00:34:46,912 --> 00:34:47,936
Hello Kitty

561
00:34:48,448 --> 00:34:54,592
先前的那三个以及个Lucy独特的这一个这是个比比当然现在这个是最好的

562
00:34:55,616 --> 00:34:56,128
最好的

563
00:35:07,648 --> 00:35:08,672
那么

564
00:35:08,928 --> 00:35:11,744
最好的东西就应该继续沿用下去了

565
00:35:12,512 --> 00:35:14,048
事实是这样吗

566
00:35:15,840 --> 00:35:21,472
刚刚你看的这一部分我给你看的这些是一个牧师2.91吧

567
00:35:24,288 --> 00:35:27,872
我们前面看到图片的这里吗这是个中心酒吧

568
00:35:29,920 --> 00:35:30,944
新版本呢

569
00:35:31,712 --> 00:35:32,992
4.9版

570
00:35:34,272 --> 00:35:35,296
你真狠心啊

571
00:35:36,064 --> 00:35:41,440
世上不是也许从4.5我没有每一个他们都去看4.5了

572
00:35:41,696 --> 00:35:42,976
3点几了

573
00:35:43,744 --> 00:35:47,584
自4.5以后就就都是现在我要讲这个样子

574
00:35:49,120 --> 00:35:49,888
这样子

575
00:35:50,144 --> 00:35:52,192
我们看到什么我想带你看是

576
00:35:53,728 --> 00:35:54,240
他的

577
00:35:55,008 --> 00:35:56,032
分配器

578
00:35:58,592 --> 00:35:59,360
有变化吗

579
00:36:00,640 --> 00:36:02,176
我们在第1讲里面

580
00:36:03,200 --> 00:36:07,040
使用了对这个Lucy比下用了五六种分配器

581
00:36:08,832 --> 00:36:10,112
刚刚看的

582
00:36:10,624 --> 00:36:14,208
2.9版很棒的那个分配器还在吗

583
00:36:14,720 --> 00:36:16,256
您是有换吗

584
00:36:16,512 --> 00:36:19,072
他仍然被容器所使用吗

585
00:36:19,584 --> 00:36:21,888
我们的一些困惑

586
00:36:22,656 --> 00:36:23,424
好

587
00:36:23,680 --> 00:36:24,448
看看

588
00:36:25,216 --> 00:36:28,544
在4.9版所附的标准库

589
00:36:28,800 --> 00:36:31,616
他的分配器是怎么做的

590
00:36:33,664 --> 00:36:34,944
但是我我想先跳

591
00:36:35,968 --> 00:36:37,248
我想先跳

592
00:36:39,552 --> 00:36:44,160
能跟我在这个托运配的切换的有点混乱我们现在先回到这里来

593
00:36:44,416 --> 00:36:45,952
这是刚刚你看着这张图

594
00:36:48,256 --> 00:36:49,280
小叶说什么

595
00:36:49,536 --> 00:36:52,096
在4.9板底下

596
00:36:53,888 --> 00:36:55,168
容器

597
00:36:55,424 --> 00:36:59,264
所使用的分配器却不再是

598
00:36:59,520 --> 00:37:02,336
很棒的那个A

599
00:37:04,640 --> 00:37:05,664
怎么会这样呢

600
00:37:06,176 --> 00:37:07,712
那这一个是什么呢

601
00:37:07,968 --> 00:37:09,504
好吧你去看看这个

602
00:37:10,784 --> 00:37:14,112
颈Lucy 4.9版笔下的这一个

603
00:37:17,696 --> 00:37:18,464
这一

604
00:37:18,720 --> 00:37:19,232
热

605
00:37:20,000 --> 00:37:21,024
设计

606
00:37:22,048 --> 00:37:23,584
他有一个

607
00:37:24,096 --> 00:37:24,864
服务类别

608
00:37:25,376 --> 00:37:25,888
腹内

609
00:37:27,936 --> 00:37:29,728
而这个父类是什么呢

610
00:37:31,264 --> 00:37:33,056
再去看源代码

611
00:37:33,824 --> 00:37:36,640
发现请看这边画了一条线

612
00:37:37,920 --> 00:37:39,456
这边有一个地方

613
00:37:40,224 --> 00:37:42,016
所以这个名称

614
00:37:42,272 --> 00:37:44,576
其实被替换为

615
00:37:45,344 --> 00:37:46,624
这个名称

616
00:37:48,672 --> 00:37:49,696
也就是说

617
00:37:49,952 --> 00:37:53,024
这个分配器有一个父类

618
00:37:54,304 --> 00:37:59,680
小智这个名字而这个名字就是这个名字这个名字叫妞

619
00:38:00,192 --> 00:38:00,960
Hello Kitty

620
00:38:01,216 --> 00:38:03,776
定义在这里头

621
00:38:05,824 --> 00:38:09,408
于是我们去看看这个妞allocate

622
00:38:09,920 --> 00:38:10,944
做什么事情

623
00:38:12,992 --> 00:38:14,528
They communicate

624
00:38:15,040 --> 00:38:18,624
一定有两个重要的函数在大家现在很熟悉了

625
00:38:18,880 --> 00:38:19,904
Hello K的汉子

626
00:38:20,160 --> 00:38:20,928
Allocate

627
00:38:22,208 --> 00:38:28,096
哈里头做的事情呢他却分配然后他去释放内存

628
00:38:28,352 --> 00:38:29,120
什么事情

629
00:38:29,376 --> 00:38:32,192
Operator new Pen operator delete

630
00:38:33,728 --> 00:38:36,032
Operator new是调用malloc

631
00:38:36,544 --> 00:38:38,592
Operative diseases2003

632
00:38:41,408 --> 00:38:42,688
我们做一个结论出来

633
00:38:43,712 --> 00:38:48,064
本来在给moussy 2.91版的分配器非常好

634
00:38:49,344 --> 00:38:50,880
好的4点9的

635
00:38:52,672 --> 00:38:54,208
这些容器却又

636
00:38:54,464 --> 00:38:57,280
改用另外一个分配给现在这一个

637
00:38:57,792 --> 00:38:59,328
而现在这一个的

638
00:39:00,352 --> 00:39:02,400
为什么分配跟释放的动作

639
00:39:02,656 --> 00:39:03,680
又回到了

640
00:39:05,472 --> 00:39:07,008
Bcbc的那种情况

641
00:39:07,776 --> 00:39:09,824
没有任何特殊设计

642
00:39:10,336 --> 00:39:11,616
梅露可物语

643
00:39:12,896 --> 00:39:15,712
怎么会这样呢怎么把好东西点除了呢

644
00:39:19,552 --> 00:39:20,320
不知道

645
00:39:21,856 --> 00:39:24,160
我没有办法去听他想理由

646
00:39:24,928 --> 00:39:26,720
为什么他不用

647
00:39:27,744 --> 00:39:30,304
他自己已经设计好的那个好东西

648
00:39:33,120 --> 00:39:38,240
我前面讲过那个好东西有一个小缺陷那个要看那个代码才能够知道的

649
00:39:38,496 --> 00:39:42,336
会不会是因为这样这个反正这个团队没有做任何的解释

650
00:39:47,456 --> 00:39:53,600
那我们有另外一个疑惑所以是这样啊首先这个现在4.9班底下变成这样了

651
00:39:54,624 --> 00:39:56,160
那我们还有另外一个疑惑

652
00:39:56,416 --> 00:40:02,304
那个设计的好的在2.9把那个叫a c那个很棒的还在吗

653
00:40:03,072 --> 00:40:06,912
吃了他就把它拿掉了一句他根本也不能用还在吗

654
00:40:08,704 --> 00:40:09,984
其实还在的

655
00:40:11,008 --> 00:40:11,776
名字变

656
00:40:13,056 --> 00:40:14,080
随便写作什么

657
00:40:14,336 --> 00:40:19,968
4.9版鼠妇的标准库里面有很多或充行的楼梯

658
00:40:20,736 --> 00:40:21,248
我们在

659
00:40:21,504 --> 00:40:22,528
你讲一遍

660
00:40:23,040 --> 00:40:24,832
吃饭用了五六个

661
00:40:25,088 --> 00:40:27,136
怎么屏LED allocated

662
00:40:27,392 --> 00:40:29,440
Aerial catalyst

663
00:40:29,696 --> 00:40:31,232
Debug allocator

664
00:40:31,488 --> 00:40:33,792
什么

665
00:40:34,304 --> 00:40:36,352
Rt-thread allocator

666
00:40:37,120 --> 00:40:38,400
Hurricane

667
00:40:39,424 --> 00:40:41,984
记忆中的有这么多个

668
00:40:42,752 --> 00:40:46,080
这边想啊其中的歌

669
00:40:46,336 --> 00:40:51,712
就是刚刚看了2.9把那个很棒的那个名字换

670
00:40:54,528 --> 00:40:57,856
我怎么知道这个就是那个那名字都不一样了

671
00:40:58,624 --> 00:41:00,160
因为我看了源代码

672
00:41:01,184 --> 00:41:07,328
里面几个很重要的关键的都一样事实上我整个都看过这个就是哪一个

673
00:41:09,376 --> 00:41:12,448
我把几个关键点抓出来给你看

674
00:41:12,704 --> 00:41:14,496
虽然这个不足以代表

675
00:41:14,752 --> 00:41:16,544
整个的全貌啊

676
00:41:16,800 --> 00:41:17,568
你看

677
00:41:17,824 --> 00:41:19,872
他这边呢有一个常量吧

678
00:41:20,640 --> 00:41:26,784
我们刚有16条链表每一条是以八为被树灾区隔

679
00:41:28,576 --> 00:41:31,648
是没有一个常量叫maxmarx 128

680
00:41:32,160 --> 00:41:38,304
刚刚有说16条链表的最后那条链表他负责的是每一块是128

681
00:41:38,560 --> 00:41:40,096
仍然存在

682
00:41:40,864 --> 00:41:42,400
这边还有一个竖直说

683
00:41:42,656 --> 00:41:45,984
3DS Max 16条链表就叫3DS

684
00:41:47,008 --> 00:41:49,568
到底有多少呢这个衣橱都是使用

685
00:41:50,080 --> 00:41:51,872
这些数字都在刚刚

686
00:41:52,128 --> 00:41:54,175
在2.91版的完全一样

687
00:41:58,015 --> 00:41:58,783
所以

688
00:42:02,111 --> 00:42:07,999
在新版不管你是用4.54点9.15点二人都已经是这个样子了

689
00:42:09,023 --> 00:42:10,303
你用的是那个

690
00:42:10,559 --> 00:42:14,399
我太没有什么特殊设计的分配器

691
00:42:15,167 --> 00:42:16,703
但这个好的人仍在

692
00:42:17,471 --> 00:42:19,007
如果你要用它

693
00:42:19,263 --> 00:42:22,335
你也可以用我在第一讲我就吃饭过了吗

694
00:42:23,359 --> 00:42:24,639
我现在在吃饭你吃

695
00:42:25,663 --> 00:42:26,687
黑色的最好

696
00:42:28,735 --> 00:42:32,831
我在4.9 5.0 5.1里面那我就可以这么用啊

697
00:42:33,855 --> 00:42:34,623
Weather

698
00:42:35,135 --> 00:42:36,159
尖括号

699
00:42:36,415 --> 00:42:39,231
第2个模板参数就要指定

700
00:42:40,255 --> 00:42:41,791
我要的

701
00:42:42,047 --> 00:42:43,583
我现在要改用这一个

702
00:42:45,119 --> 00:42:46,399
虎

703
00:42:49,727 --> 00:42:53,567
20比较头痛比较头痛的事

704
00:42:54,079 --> 00:42:55,103
他不是

705
00:42:55,615 --> 00:42:57,407
Std这个命名空间里头

706
00:42:58,175 --> 00:43:00,735
哈斯被放在这一个命名空间

707
00:43:03,039 --> 00:43:05,855
我们必须知道这个事情这个全名写出来

708
00:43:08,159 --> 00:43:09,695
我怎么会知道这个事情呢

709
00:43:11,231 --> 00:43:13,023
没有任何文档告诉我

710
00:43:13,535 --> 00:43:14,815
我是看源代码之道

711
00:43:16,095 --> 00:43:18,399
不过你现在也知道了反正就这么写

712
00:43:20,191 --> 00:43:21,983
你就可以用上这一个

713
00:43:22,751 --> 00:43:23,775
很好的

714
00:43:25,567 --> 00:43:30,431
至于为什么发育色默认不用这一个

715
00:43:35,295 --> 00:43:38,111
好这个是分配器
