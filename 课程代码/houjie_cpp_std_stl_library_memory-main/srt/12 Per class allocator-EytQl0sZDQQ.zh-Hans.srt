1
00:00:11,520 --> 00:00:12,544
现在我们

2
00:00:12,800 --> 00:00:13,568
终于把

3
00:00:13,824 --> 00:00:16,384
基本元素的这些

4
00:00:16,640 --> 00:00:17,408
行为

5
00:00:18,432 --> 00:00:20,480
汉他的重载的方式

6
00:00:20,992 --> 00:00:22,272
全部都讲过一遍

7
00:00:24,064 --> 00:00:30,208
这个基本元素是什么呢你有好朋友placement还有对应的

8
00:00:30,464 --> 00:00:31,232
喂牛等等

9
00:00:32,256 --> 00:00:33,280
终于

10
00:00:33,536 --> 00:00:34,816
万事俱备

11
00:00:35,072 --> 00:00:36,608
我们现在可以开始

12
00:00:36,864 --> 00:00:38,912
针对一个class

13
00:00:39,168 --> 00:00:40,960
来写出他的

14
00:00:41,984 --> 00:00:42,752
为什么管理

15
00:00:44,032 --> 00:00:46,080
我们要的是什么事情

16
00:00:47,872 --> 00:00:51,712
刚刚在前面我找出一个适当的演出来

17
00:00:56,576 --> 00:00:59,904
我曾经以这一张画面引导你

18
00:01:01,696 --> 00:01:05,792
当使用者表示我现在是类的Class的设计者

19
00:01:06,304 --> 00:01:08,096
使用者是这么用的

20
00:01:09,632 --> 00:01:10,144
那么

21
00:01:12,448 --> 00:01:14,496
你这个写好了这个代码这样看来

22
00:01:15,008 --> 00:01:16,544
他最终是调用没了

23
00:01:17,312 --> 00:01:21,408
大家对面那个人估计会觉得这个大概很慢

24
00:01:23,456 --> 00:01:28,064
其实他一点都不慢我们将在第3讲里面谈到没落可的行为

25
00:01:29,344 --> 00:01:30,880
好吧无论如何

26
00:01:31,136 --> 00:01:36,768
就算他确实比较慢其实他不慢就算他很慢的话呢

27
00:01:38,304 --> 00:01:40,096
霍夫曼不论如何

28
00:01:40,352 --> 00:01:43,680
减少调用malloc的次数总是很好的

29
00:01:46,240 --> 00:01:47,776
所以我们会想要

30
00:01:48,800 --> 00:01:52,128
使用的这里如果有很多次很多次的命

31
00:01:52,640 --> 00:01:55,456
我们作为负的设计者能不能够

32
00:01:55,968 --> 00:01:58,528
鲜花一大块来做准备

33
00:01:58,784 --> 00:02:00,832
自己去切小块

34
00:02:01,600 --> 00:02:04,416
好哦比如说我现在一次玩1000个

35
00:02:04,672 --> 00:02:10,816
那么即使用者那你可不断的15个八个100个300

36
00:02:11,072 --> 00:02:13,376
300个500个我手上有1000个

37
00:02:14,400 --> 00:02:19,520
你要的时候我总是很快就给你了我再1000个是有没有可能的

38
00:02:20,032 --> 00:02:20,800
一次而已

39
00:02:21,568 --> 00:02:23,616
拿到之后切成小块

40
00:02:23,872 --> 00:02:30,016
所以我在公映的时候我做维护我在供应使用什么时候就很快的不要每次都要

41
00:02:30,272 --> 00:02:31,040
调用没了

42
00:02:32,832 --> 00:02:33,856
这是第1个考量

43
00:02:34,880 --> 00:02:41,024
所以我必须接管这条这张图这个到这个地方来我要载入里面去

44
00:02:41,280 --> 00:02:43,072
是重返这个函数

45
00:02:43,328 --> 00:02:44,352
来结果

46
00:02:45,376 --> 00:02:46,656
做什么事呢

47
00:02:47,424 --> 00:02:49,216
这个图可以很好形象

48
00:02:50,752 --> 00:02:52,544
给你一个一个亿的感觉

49
00:02:53,312 --> 00:02:54,848
我就是挖一大块

50
00:02:55,360 --> 00:02:58,944
切成一个一个用串联把它串起来

51
00:03:00,480 --> 00:03:03,040
这样就是一个小型的内存管理

52
00:03:04,832 --> 00:03:08,160
那么除了强的那道可调用次数是y

53
00:03:09,696 --> 00:03:12,512
我还想强的裤子的用量

54
00:03:14,560 --> 00:03:18,912
因为如果我没有特殊设计划按照这一个流程看来

55
00:03:19,424 --> 00:03:24,032
一次的附就调用一次malloc一次malloc

56
00:03:24,288 --> 00:03:25,568
我刚才已经看过了

57
00:03:26,848 --> 00:03:28,896
一次malloc就得到了

58
00:03:29,152 --> 00:03:30,432
两个故事

59
00:03:30,688 --> 00:03:33,504
下一组八个字节

60
00:03:37,088 --> 00:03:38,880
我想象的那个次数

61
00:03:39,904 --> 00:03:40,672
读数

62
00:03:42,208 --> 00:03:48,352
所以说回到刚刚我的例子如果我手上有1000一次要1000个的大小

63
00:03:48,608 --> 00:03:52,704
这1000个切下来那他们都是不带骨的

64
00:03:53,216 --> 00:03:57,312
只有这1000个的这一整包的上下载的工具

65
00:03:59,616 --> 00:04:04,992
所以内存池的设计就是一大块一个池塘一个池子

66
00:04:05,248 --> 00:04:09,344
这一大会设计了不但是要提升速度

67
00:04:09,600 --> 00:04:11,904
并且要将的浪费率

68
00:04:12,928 --> 00:04:16,256
世上为什么管理目标就是这两件事情一个字

69
00:04:16,512 --> 00:04:18,815
速度一个是空间

70
00:04:21,887 --> 00:04:25,471
所以刚回到我刚刚我们从打算从

71
00:04:28,287 --> 00:04:29,311
正开始

72
00:04:30,591 --> 00:04:32,127
我们手上的工具都有了

73
00:04:32,639 --> 00:04:36,991
终于我们要为这一个Class现在这个叫Spring

74
00:04:37,247 --> 00:04:38,527
来写

75
00:04:39,295 --> 00:04:43,903
小雄的为什么管理这是我们迈向分配器的第1步

76
00:04:44,159 --> 00:04:46,719
在整个设计里头的我有第1部

77
00:04:47,231 --> 00:04:48,255
然后第2步

78
00:04:49,279 --> 00:04:50,559
会做得更精巧一些

79
00:04:50,815 --> 00:04:52,095
他的第3步

80
00:04:52,351 --> 00:04:54,399
就终于趋近于

81
00:04:54,655 --> 00:04:56,447
标准库的分配器

82
00:04:57,727 --> 00:04:58,751
我马上来看看

83
00:04:59,007 --> 00:05:01,311
马上来看看这个例子

84
00:05:01,567 --> 00:05:07,711
这个例子来自这一本书里面的第765页

85
00:05:09,247 --> 00:05:13,343
我并不打算去把这些变量做一些改变

86
00:05:14,111 --> 00:05:16,159
然后当成是我自己设计的例子

87
00:05:16,671 --> 00:05:18,207
我觉得这样也意义不大

88
00:05:19,231 --> 00:05:25,375
我们宁愿保存它的完整面貌一个小东西现在很流行一句话叫相互相

89
00:05:25,631 --> 00:05:26,399
致敬

90
00:05:26,911 --> 00:05:28,959
像这位非常优秀的

91
00:05:29,215 --> 00:05:29,983
作者

92
00:05:30,495 --> 00:05:33,311
世界而且的6Plus Viber

93
00:05:33,567 --> 00:05:35,615
分析认输给好几个版本

94
00:05:36,639 --> 00:05:38,431
这个地址是这样

95
00:05:39,455 --> 00:05:41,759
好在做script

96
00:05:43,295 --> 00:05:44,575
先看一下他被打

97
00:05:45,855 --> 00:05:46,879
在

98
00:05:48,159 --> 00:05:48,671
这里

99
00:05:48,927 --> 00:05:49,951
一个总数

100
00:05:50,975 --> 00:05:51,743
一个总数

101
00:05:55,071 --> 00:05:56,095
鱿鱼

102
00:05:56,607 --> 00:06:00,191
刚刚分析我们希望挖一大会

103
00:06:00,703 --> 00:06:04,287
而挖一大块的时候需要指针把它串起来

104
00:06:05,055 --> 00:06:06,847
基于这个考量

105
00:06:07,871 --> 00:06:10,943
我们在的草原有的非常

106
00:06:11,199 --> 00:06:12,223
之外

107
00:06:12,991 --> 00:06:14,783
在设计一根指针

108
00:06:15,551 --> 00:06:16,319
Next

109
00:06:16,831 --> 00:06:19,391
这个指针将指向string

110
00:06:19,903 --> 00:06:20,415
自己

111
00:06:21,183 --> 00:06:22,207
这种东西

112
00:06:22,463 --> 00:06:24,511
所以将来就可以做出这个图

113
00:06:28,095 --> 00:06:28,607
不过

114
00:06:29,631 --> 00:06:31,935
听到这里你可能就一个疑惑了

115
00:06:32,447 --> 00:06:33,983
这个数据是这样

116
00:06:34,239 --> 00:06:35,519
四个字节

117
00:06:36,287 --> 00:06:40,383
为了将来后投的这个内存管理

118
00:06:42,175 --> 00:06:44,479
耳朵设计一个指针

119
00:06:45,247 --> 00:06:47,807
这样膨胀率是100%

120
00:06:48,319 --> 00:06:51,135
子孙也是四个自觉原来也是这个字节

121
00:06:51,647 --> 00:06:52,671
4.8

122
00:06:53,439 --> 00:06:54,975
两臂100%

123
00:06:55,999 --> 00:07:00,351
而得到的成果是什么呢到了成果是

124
00:07:00,607 --> 00:07:01,631
这里面

125
00:07:01,887 --> 00:07:03,679
一个强的没唠嗑的

126
00:07:03,935 --> 00:07:04,703
45

127
00:07:05,215 --> 00:07:08,799
帮我刚才已经告诉过你了没了个其实蛮快的

128
00:07:09,055 --> 00:07:10,335
13讲会提到

129
00:07:10,591 --> 00:07:14,943
所以这个强的没落可调用次数就是影响不太大

130
00:07:16,223 --> 00:07:17,759
列的诉求是

131
00:07:18,015 --> 00:07:20,319
没有cookie cookie可以去

132
00:07:21,599 --> 00:07:27,743
你在这边去除估计而这里却为了这件事情而膨胀100%这是一个

133
00:07:27,999 --> 00:07:29,535
什么情况呢

134
00:07:29,791 --> 00:07:35,935
当然了膨胀100%的天价很可怕是因为现在原本的数据只有四个自己也许这个

135
00:07:36,191 --> 00:07:42,335
是原本的数据是还蛮大的有时候原本的数据量是100个字节的膨胀率当然就变的

136
00:07:44,639 --> 00:07:45,663
无论如何

137
00:07:46,175 --> 00:07:48,479
总之感觉好像有一个遗憾

138
00:07:48,991 --> 00:07:52,063
为了去除cookie这边增加了支撑

139
00:07:52,831 --> 00:07:57,439
你说话东墙补西墙的你还是你到底有没有得到真正的效益

140
00:07:57,951 --> 00:08:01,791
这个事情其实到了第2版本这个指针是可以不要的

141
00:08:02,559 --> 00:08:06,143
现在是第1版本我们先让大家感觉一下

142
00:08:07,167 --> 00:08:10,495
所以这边有句话这种设计会引发一个疑虑

143
00:08:10,751 --> 00:08:15,359
什么疑虑那多好用了一个next下一页的设计会更好

144
00:08:15,615 --> 00:08:16,895
Dr版本

145
00:08:19,199 --> 00:08:25,343
好说的这样的设计之后我现在重返这两个函数这个前面都提过了

146
00:08:25,599 --> 00:08:26,111
这个

147
00:08:26,623 --> 00:08:29,439
他们应该是静态的但是写不写都无所谓

148
00:08:31,231 --> 00:08:32,255
这两个函数

149
00:08:33,023 --> 00:08:33,791
设计

150
00:08:34,303 --> 00:08:35,583
这里右手边

151
00:08:38,143 --> 00:08:44,287
使用者群陆一个Spring的时候就被接管那个分配内存的动作就被机

152
00:08:44,543 --> 00:08:47,871
管道这个函数来这个里头

153
00:08:48,127 --> 00:08:52,991
就去挖一大块多大块呢这个设计这里是24

154
00:08:53,759 --> 00:08:55,039
这是一个常量

155
00:08:55,295 --> 00:08:56,831
在这里我*这个常量

156
00:08:57,599 --> 00:08:58,367
24

157
00:08:59,135 --> 00:09:02,207
这边是陆的动作就这里是真身其实就是valak

158
00:09:02,719 --> 00:09:03,999
分配内存的动作

159
00:09:04,255 --> 00:09:05,279
Apple Pay多大

160
00:09:06,559 --> 00:09:07,327
这是一个

161
00:09:07,839 --> 00:09:10,143
自古所形成的数组

162
00:09:10,655 --> 00:09:12,959
也就是以字节形成的速度

163
00:09:13,215 --> 00:09:14,751
我发了这个唱歌

164
00:09:15,007 --> 00:09:17,311
上课的计算在上面这里

165
00:09:17,567 --> 00:09:19,615
这就是24个

166
00:09:19,871 --> 00:09:20,895
这里是24

167
00:09:21,407 --> 00:09:22,943
二人四个元素

168
00:09:23,967 --> 00:09:27,807
每一个元素的大小是这样传进来了引起会成进来

169
00:09:29,087 --> 00:09:30,367
这里就24个

170
00:09:31,647 --> 00:09:34,719
算好之后一次性的把它拿到

171
00:09:35,231 --> 00:09:37,279
这边有一些指针的转型

172
00:09:39,327 --> 00:09:45,215
然后把这一大块分割片片方做链表串接起来

173
00:09:46,239 --> 00:09:47,775
这里的风格动作

174
00:09:48,031 --> 00:09:52,383
我就不带大家去去看了就是指针的操作根转型

175
00:09:53,151 --> 00:09:53,663
再会

176
00:09:55,967 --> 00:09:58,271
最后都切割好之后

177
00:09:59,039 --> 00:10:01,855
把第1个传回去这里有一个return

178
00:10:03,903 --> 00:10:05,183
把这个传回去

179
00:10:05,695 --> 00:10:06,463
剩下

180
00:10:06,719 --> 00:10:09,023
234了售价23块

181
00:10:10,303 --> 00:10:15,167
那么这是一个单向链表所以永远有一根指针指的头

182
00:10:15,935 --> 00:10:17,215
就是这一

183
00:10:17,471 --> 00:10:19,007
Restore

184
00:10:20,031 --> 00:10:21,055
一开始

185
00:10:21,567 --> 00:10:23,359
经过这个动作之后

186
00:10:23,615 --> 00:10:26,175
这个Freestyle就此像头了

187
00:10:26,943 --> 00:10:31,807
第1个给出去之后就会指向下一个在给自己就再下一个

188
00:10:32,319 --> 00:10:34,367
这是非常单纯的

189
00:10:34,879 --> 00:10:35,903
石像

190
00:10:36,159 --> 00:10:37,439
链表的操作

191
00:10:38,975 --> 00:10:40,255
我们就不必须给他了

192
00:10:44,095 --> 00:10:45,375
现在看回收的动作

193
00:10:47,167 --> 00:10:50,751
当使用者去的第1个Spring

194
00:10:52,543 --> 00:10:54,847
这辈子会先调用析构函数

195
00:10:55,359 --> 00:10:56,639
然后调用

196
00:10:58,431 --> 00:11:00,479
在释放内存的函数

197
00:11:00,735 --> 00:11:03,551
这时候释放内存就跑到这个出来

198
00:11:04,575 --> 00:11:05,599
也就是这里

199
00:11:07,391 --> 00:11:09,183
这里会收到一个指针

200
00:11:10,207 --> 00:11:15,071
就把这个指针回收到单向链表之中

201
00:11:16,863 --> 00:11:18,911
下面的操作就不是我们的

202
00:11:19,679 --> 00:11:22,495
重点这个应该是各位要具备的一个基础

203
00:11:24,287 --> 00:11:27,359
单向链表一定有一个指针指向同

204
00:11:27,871 --> 00:11:32,991
所以现在回收一个元素该放到哪里好呢当然是放到头最快

205
00:11:34,015 --> 00:11:35,807
那个只在换电话你就好了

206
00:11:36,319 --> 00:11:37,599
这就是这里的动作

207
00:11:42,463 --> 00:11:44,255
这就是一个小型的

208
00:11:44,511 --> 00:11:45,279
为什么吃

209
00:11:46,559 --> 00:11:52,703
这个词那只针对这一个可拉出来操作因为是写在这个Class里

210
00:11:52,959 --> 00:11:55,007
里头写在这两个函数里头

211
00:11:56,031 --> 00:11:57,567
所以我们把这种

212
00:11:58,847 --> 00:11:59,871
为什么此

213
00:12:00,127 --> 00:12:04,735
这个这个小型的分配器叫做perplex allocate

214
00:12:07,807 --> 00:12:08,831
版本

215
00:12:10,367 --> 00:12:11,391
因为拿到的

216
00:12:12,159 --> 00:12:12,927
程序

217
00:12:13,695 --> 00:12:15,231
我会包括这些东西

218
00:12:15,999 --> 00:12:17,279
我给你的程序

219
00:12:18,815 --> 00:12:20,095
我们看怎么使用

220
00:12:21,119 --> 00:12:23,167
设计好刚刚的那个东西之后

221
00:12:24,703 --> 00:12:25,471
这是我的

222
00:12:25,727 --> 00:12:26,239
测试

223
00:12:27,007 --> 00:12:27,775
我先

224
00:12:28,031 --> 00:12:30,591
测一下这个车有多大

225
00:12:30,847 --> 00:12:34,431
我刚去看代码已经知道了一个整数根一个支撑

226
00:12:34,687 --> 00:12:35,967
所以是大小事吧

227
00:12:36,223 --> 00:12:37,503
这里有输出是吧

228
00:12:39,295 --> 00:12:40,063
然后

229
00:12:40,319 --> 00:12:42,879
我准备一大堆指针100个

230
00:12:43,903 --> 00:12:44,671
100分

231
00:12:46,463 --> 00:12:47,231
我

232
00:12:47,487 --> 00:12:50,559
是不是100次对100次的全牛他

233
00:12:54,143 --> 00:12:55,679
输出前十个

234
00:12:56,703 --> 00:12:58,495
比较期间隔

235
00:12:59,263 --> 00:13:00,799
我想确认什么事情

236
00:13:01,567 --> 00:13:05,407
我想带你去看看他们确实没有

237
00:13:07,967 --> 00:13:10,015
刚刚你听得到100分子生的

238
00:13:10,271 --> 00:13:13,343
我只打印出钱10根指针出来

239
00:13:14,623 --> 00:13:15,391
结果在嘴

240
00:13:18,207 --> 00:13:19,487
最后把姐姐的调

241
00:13:20,511 --> 00:13:24,863
所以我们的重点是看看这群十分子真的相差距离

242
00:13:26,143 --> 00:13:27,423
这里是剑阁吧

243
00:13:29,727 --> 00:13:31,775
右边这个执行结果是什么

244
00:13:32,287 --> 00:13:33,311
左边是

245
00:13:33,567 --> 00:13:37,151
向上也那样写了一个商业那样

246
00:13:37,407 --> 00:13:40,735
得到的结果右边是没写的结果

247
00:13:42,527 --> 00:13:48,671
文写的话没有写这两个还是住那么分配或者是示范

248
00:13:48,927 --> 00:13:50,207
这都不会经过他

249
00:13:50,463 --> 00:13:53,023
那就是一般正常的情况就会大的空气

250
00:13:55,583 --> 00:13:58,911
我靠在左边间隔把右边间隔16

251
00:13:59,935 --> 00:14:02,495
这表示右边确实大了

252
00:14:02,751 --> 00:14:05,055
而且cookie是多少呢

253
00:14:06,591 --> 00:14:12,735
Wc6那个出来做例子上下有我有空每个空瓶四个字

254
00:14:12,991 --> 00:14:14,271
自己说这八个

255
00:14:14,527 --> 00:14:17,343
你看右边的一起左边

256
00:14:17,599 --> 00:14:19,135
每一块都多

257
00:14:19,647 --> 00:14:20,415
八个字节

258
00:14:22,975 --> 00:14:23,999
我们前面

259
00:14:24,511 --> 00:14:25,535
这个很全面的

260
00:14:25,791 --> 00:14:26,815
很快的翻过去

261
00:14:27,327 --> 00:14:28,095
谈到

262
00:14:28,863 --> 00:14:31,167
曾经看到vc6

263
00:14:31,679 --> 00:14:32,703
他的区块是这样

264
00:14:32,959 --> 00:14:35,007
但我这个例子不是危机六

265
00:14:35,263 --> 00:14:37,311
是在各路吃一编译器底下

266
00:14:37,567 --> 00:14:38,335
去做

267
00:14:38,591 --> 00:14:40,127
也是波八个自己

268
00:14:41,151 --> 00:14:41,919
的确

269
00:14:42,431 --> 00:14:43,711
我钱都已经告诉你了

270
00:14:44,479 --> 00:14:46,271
Cookie这种东西吃

271
00:14:46,527 --> 00:14:48,575
这种设计方法是

272
00:14:49,087 --> 00:14:50,367
到处都存在的

273
00:14:50,879 --> 00:14:52,671
所有平台都是这么设计

274
00:14:55,487 --> 00:14:57,279
好回到刚刚的例子来

275
00:14:59,839 --> 00:15:00,863
我们再看一次

276
00:15:01,631 --> 00:15:02,655
执行结果

277
00:15:07,263 --> 00:15:11,359
其实这样的输出是有一点

278
00:15:14,431 --> 00:15:15,199
有点

279
00:15:15,711 --> 00:15:21,855
要说冒险么也不太对我的意思是说如果他间隔不是吧其实也不

280
00:15:22,111 --> 00:15:26,463
不能够证明什么事情不过很幸运的他间隔是吧那太好了

281
00:15:27,743 --> 00:15:33,631
因为在这里的系统里面已连续的分配一块一块的内存他们贵

282
00:15:33,887 --> 00:15:36,191
他们并不一定会联系在一起

283
00:15:37,471 --> 00:15:38,495
他们到底

284
00:15:39,007 --> 00:15:44,383
当时会在什么地方取决于你的电脑在运作你的电脑是一个

285
00:15:44,639 --> 00:15:46,175
不过任务系统

286
00:15:46,431 --> 00:15:47,455
Multitasking

287
00:15:48,223 --> 00:15:49,759
我想我现在

288
00:15:50,271 --> 00:15:55,391
最近事情一分配一块做完之后呢也许其他的事情或者别的进程

289
00:15:55,647 --> 00:15:56,671
插进来

290
00:15:57,183 --> 00:15:59,999
把内存用的有点子支离破碎

291
00:16:01,023 --> 00:16:04,863
以至于40个没有连在一起这也是有可能

292
00:16:06,655 --> 00:16:11,519
不过很幸运的这是一个试点现在只是连在一起的那就证明了

293
00:16:12,543 --> 00:16:13,311
他们确实

294
00:16:13,567 --> 00:16:14,335
不再哭泣

295
00:16:15,615 --> 00:16:16,383
左根右

296
00:16:21,247 --> 00:16:26,879
这个例子已经点出了所谓的内存分配内存管理的机制

297
00:16:27,135 --> 00:16:32,767
这是一个池塘一大块这一大块的多半就是用链表来管理

298
00:16:33,279 --> 00:16:34,815
非常经典的例子

299
00:16:35,839 --> 00:16:38,399
差别比较唯一的缺点

300
00:16:38,655 --> 00:16:39,423
就是

301
00:16:39,935 --> 00:16:41,215
阿波罗

302
00:16:43,519 --> 00:16:44,799
谁在下一个例子

303
00:16:45,311 --> 00:16:50,431
我马上要在第2个例子就把这个指针去除掉了
