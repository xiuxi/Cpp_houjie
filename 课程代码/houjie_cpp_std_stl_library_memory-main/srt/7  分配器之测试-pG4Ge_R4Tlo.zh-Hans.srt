1
00:00:08,448 --> 00:00:10,496
前面我们介绍的都是容器

2
00:00:11,776 --> 00:00:14,336
全部介绍完了

3
00:00:16,896 --> 00:00:19,200
容器的背后需要

4
00:00:19,968 --> 00:00:24,064
一个东西来支持他对内存的使用

5
00:00:24,320 --> 00:00:27,136
这个东西就是分配器locator

6
00:00:28,160 --> 00:00:30,720
在理想的情况之下我们是

7
00:00:30,976 --> 00:00:31,488
最好是

8
00:00:32,768 --> 00:00:33,792
不知道这个东西

9
00:00:34,816 --> 00:00:40,960
一定会存在这个东西但是我们最好不知道那是首先是你不用写出来容器

10
00:00:41,216 --> 00:00:43,264
汽车有一个默认的分配器

11
00:00:44,800 --> 00:00:48,384
确实在使用界面上是这样接口上的这样

12
00:00:49,152 --> 00:00:53,248
这个条件就是这个默认的分配器要够好

13
00:00:55,808 --> 00:00:58,112
货到再也就衍生说

14
00:00:58,368 --> 00:01:00,160
是不是还有其他的分配器

15
00:01:00,416 --> 00:01:06,048
当然你可以自己洗一个比一个拿出来我们在前面的那个领导那么368呢

16
00:01:06,304 --> 00:01:08,352
可以扩充标准库

17
00:01:09,888 --> 00:01:10,912
那就

18
00:01:12,192 --> 00:01:14,240
就有能力气个

19
00:01:15,776 --> 00:01:17,056
那除了

20
00:01:17,568 --> 00:01:20,128
默认的那个你自己写的

21
00:01:21,152 --> 00:01:27,296
你自己要怎么写都还要再讨论的标准库有没有提供其他的分配气质

22
00:01:27,552 --> 00:01:29,088
这是我们现在要讨论的重点

23
00:01:30,368 --> 00:01:36,512
在这个之前讲的那些容器都是标准库里面规定的

24
00:01:37,536 --> 00:01:40,608
该有哪些容器该有那些复杂度

25
00:01:42,144 --> 00:01:46,752
除了那些非标准的以外我们前面介绍过一些非标准的开头的吗

26
00:01:47,264 --> 00:01:52,896
Sdcc标准其它都是标准也就是说你在各个编译器都

27
00:01:53,152 --> 00:01:54,944
那个城市都可以运行过

28
00:01:55,712 --> 00:01:57,248
但是现在接下来讲的

29
00:01:57,504 --> 00:01:59,552
我只讲个故事一下

30
00:02:00,576 --> 00:02:01,344
首付的

31
00:02:03,392 --> 00:02:04,416
其他的

32
00:02:04,928 --> 00:02:07,744
这就很难说在BCD下

33
00:02:08,256 --> 00:02:12,352
肯定是没有这些东西或者有这些东西都是名字不一样

34
00:02:13,376 --> 00:02:13,888
好

35
00:02:14,400 --> 00:02:17,984
分配器首先这段投影片让大家知道

36
00:02:18,496 --> 00:02:19,520
到底你

37
00:02:19,776 --> 00:02:22,592
使用的容器用的是什么分配器

38
00:02:23,104 --> 00:02:26,432
这里列出来的master list set map

39
00:02:27,456 --> 00:02:30,272
Undefeated map

40
00:02:31,296 --> 00:02:32,064
代表性

41
00:02:34,368 --> 00:02:37,440
每一个容器它的声明

42
00:02:37,952 --> 00:02:39,744
各位看他都是模板

43
00:02:41,536 --> 00:02:42,560
模板

44
00:02:42,816 --> 00:02:45,888
一定有第2层数就是鲜红色的这一个

45
00:02:46,656 --> 00:02:48,448
这是有默认值

46
00:02:49,216 --> 00:02:49,984
这里

47
00:02:50,240 --> 00:02:51,264
你只要讲

48
00:02:51,520 --> 00:02:52,032
人数

49
00:02:52,288 --> 00:02:53,568
是什么类型就好了

50
00:02:54,336 --> 00:02:57,664
第2个参数的默认值是红色的全部都一样

51
00:02:58,176 --> 00:03:00,480
他们都默认使用的是

52
00:03:00,736 --> 00:03:03,296
St的帽好吧Hello Kitty

53
00:03:03,552 --> 00:03:09,696
表示一定有这么一个分配器这么一个Class名称叫做

54
00:03:11,744 --> 00:03:12,256
好

55
00:03:12,512 --> 00:03:14,560
这是默认的现在我们看

56
00:03:16,608 --> 00:03:19,168
到底有哪些分配器呢

57
00:03:19,680 --> 00:03:24,800
我现在写的这个字还是在给各位会拿到的这个完整的测试程序

58
00:03:28,640 --> 00:03:29,920
不过可能需要

59
00:03:30,432 --> 00:03:31,456
我去改一改

60
00:03:31,712 --> 00:03:32,992
用一个

61
00:03:33,504 --> 00:03:39,648
定义选项去圈入数只有在各路线以下才能够运作在VC底下这些就必须要

62
00:03:39,904 --> 00:03:40,672
前臂甲

63
00:03:40,928 --> 00:03:42,976
不然你在必须底下都会编译过不了

64
00:03:44,000 --> 00:03:44,768
好

65
00:03:45,536 --> 00:03:46,304
我们来看看

66
00:03:47,584 --> 00:03:50,144
这个地方绿色的部分是边

67
00:03:51,936 --> 00:03:52,960
就是

68
00:03:53,216 --> 00:03:56,288
石墨烯底下有这么多的分配器

69
00:03:56,544 --> 00:03:59,360
有什么分配器的arraylist

70
00:03:59,616 --> 00:04:02,944
Nltk TNT就是multi-strategy

71
00:04:03,200 --> 00:04:04,736
多线程multithreading

72
00:04:05,504 --> 00:04:07,552
Ibaka locator看电视要

73
00:04:07,808 --> 00:04:10,368
调试用的professor

74
00:04:10,624 --> 00:04:14,208
好像是内存池很有名的一种东西

75
00:04:14,976 --> 00:04:16,512
Allocate

76
00:04:17,536 --> 00:04:23,679
Venrock allocator neoregelia这么多种他们放的位置特点都放在ES

77
00:04:23,935 --> 00:04:26,239
这都是扩充性

78
00:04:26,751 --> 00:04:28,799
非标准非标准

79
00:04:29,055 --> 00:04:31,359
标准备告诉没有说出他们

80
00:04:32,383 --> 00:04:34,431
好我把他引入进来之后呢

81
00:04:34,687 --> 00:04:40,831
下面我就要测一点给你看我又没变给你看因为也许你也可能想换一个

82
00:04:41,087 --> 00:04:45,183
那但是你不知道怎么做就像我这样用我在下面

83
00:04:46,207 --> 00:04:47,231
我决定写

84
00:04:47,487 --> 00:04:48,255
List

85
00:04:48,511 --> 00:04:53,631
双向链表作容器然后搭配一个我选择的

86
00:04:53,887 --> 00:04:54,655
分配器

87
00:04:55,167 --> 00:04:56,447
所以下面有

88
00:04:57,215 --> 00:04:59,007
这么多好这些全部都是历史

89
00:04:59,263 --> 00:05:03,359
第2个参数我就把它明确的写出来我写的是什么呢

90
00:05:03,615 --> 00:05:06,175
就是上面对我影空间的这一些

91
00:05:07,199 --> 00:05:10,527
这几个1234567

92
00:05:10,783 --> 00:05:11,807
厦门有几个

93
00:05:15,391 --> 00:05:18,207
123456

94
00:05:18,463 --> 00:05:19,231
少一个呢

95
00:05:22,047 --> 00:05:26,911
我现在也不想花时间去比对可能某一个我们有去用没有去用它吧

96
00:05:28,191 --> 00:05:33,055
好要注意的是原来这一些分配器呀

97
00:05:33,311 --> 00:05:35,615
他还不是定义在http头

98
00:05:35,871 --> 00:05:36,383
不是

99
00:05:36,895 --> 00:05:38,687
它定义在一个特别的地方

100
00:05:38,943 --> 00:05:39,967
就这个

101
00:05:40,479 --> 00:05:41,503
源代码你看到了

102
00:05:42,271 --> 00:05:45,087
这个new gnu C XX

103
00:05:46,879 --> 00:05:48,927
这样的一个命名空间里头

104
00:05:49,951 --> 00:05:56,095
这是比较头痛的一点因为不会有任何文档就说这件事情只是我自己看了源代码之后

105
00:05:58,143 --> 00:05:59,423
去理解

106
00:06:00,703 --> 00:06:06,847
好我就把它用一变现在我们也并没有要去解释这一些分配器的行为和那个非常负

107
00:06:07,103 --> 00:06:10,175
复杂非常复杂我这边使用出两张图

108
00:06:10,431 --> 00:06:12,479
上面这个叫蒲allocator

109
00:06:12,735 --> 00:06:14,527
非常有名的内存池

110
00:06:15,039 --> 00:06:17,343
下面这个叫bitmapdata

111
00:06:17,599 --> 00:06:23,743
它的结构是长这样这么一个讲他去可能都要三小时以上但是这边直接告诉我

112
00:06:23,999 --> 00:06:30,143
既然用整理的这个图给你看一看当我在左下角这边

113
00:06:30,399 --> 00:06:33,215
做出六个容器之后

114
00:06:33,471 --> 00:06:35,775
我写个测试程序会询问我

115
00:06:37,311 --> 00:06:39,359
不信我在这边有一个询问

116
00:06:39,871 --> 00:06:41,919
为什么你要选哪一个呀

117
00:06:43,967 --> 00:06:50,111
那然后你要多少个元素所以我就可以选择刚刚

118
00:06:50,367 --> 00:06:51,903
六个容器里面的某一个

119
00:06:52,159 --> 00:06:54,463
每一个东西用的分配器不一样

120
00:06:54,975 --> 00:07:00,607
然后我可以选我要100万个300万个500万个元素然后下去就开始

121
00:07:01,631 --> 00:07:07,007
针对这个容器的容积是一个粒子双向链表就一直是不行

122
00:07:07,519 --> 00:07:13,663
那不是贝壳的没事不需变革就会分配内存分配内存就会用到对应的

123
00:07:13,919 --> 00:07:16,223
我就用这种方式

124
00:07:16,479 --> 00:07:17,247
来

125
00:07:18,015 --> 00:07:20,831
来学习怎么使用不一样的分配器

126
00:07:23,391 --> 00:07:25,695
OK那么等到这

127
00:07:26,207 --> 00:07:27,231
我说死定了

128
00:07:28,255 --> 00:07:33,631
比如说100万个元素都不是这个放好之后我这个上下有一个时间点

129
00:07:34,399 --> 00:07:38,751
一起啊我就知道我花了多少时间我就可以看看

130
00:07:39,263 --> 00:07:41,055
使用双向链表

131
00:07:41,567 --> 00:07:43,359
放100个元素的时候

132
00:07:43,615 --> 00:07:44,383
我用

133
00:07:45,407 --> 00:07:50,783
A和B和C O的这种分配器它们各自好钓了多少时间

134
00:07:51,551 --> 00:07:55,903
但这也只是一个例子这并不是自己给他讲一讲一个

135
00:07:56,415 --> 00:07:58,207
概念为了

136
00:07:58,463 --> 00:08:02,047
真正要做效率上的测试是不能这么简单的

137
00:08:03,583 --> 00:08:08,447
好这就是执行到最后我们这边直接一起啊就可以得到时间

138
00:08:08,959 --> 00:08:10,495
我们有把执行结果

139
00:08:11,007 --> 00:08:11,775
打印出来

140
00:08:12,799 --> 00:08:14,847
就是一些时间只

141
00:08:16,639 --> 00:08:22,783
这就是搭配不同的分配器在容器上面

142
00:08:23,039 --> 00:08:24,063
写法

143
00:08:27,647 --> 00:08:32,255
我们有一个疑惑就是有没有可能直接使用分配器

144
00:08:33,279 --> 00:08:39,423
当然是可能的分配器是个Class你就去用它吗它就提供两个函数一个叫

145
00:08:39,679 --> 00:08:41,983
Hello Kitty Hello Kitty

146
00:08:42,239 --> 00:08:46,079
一个哪一种所以你当然可以直接用它

147
00:08:46,335 --> 00:08:48,895
有没有需要那没有需要

148
00:08:50,175 --> 00:08:52,991
因为你的对你真正的

149
00:08:53,247 --> 00:08:55,039
工具四种气

150
00:08:55,295 --> 00:08:57,343
你实在没有必要

151
00:08:57,599 --> 00:09:02,207
用它被我那个分配器去哪位置就换内存

152
00:09:03,231 --> 00:09:06,815
不过我还是是一次给你看

153
00:09:35,231 --> 00:09:39,839
然后我就通过这个arc1这是一个

154
00:09:40,863 --> 00:09:43,935
去调用OK了调用的

155
00:09:45,727 --> 00:09:47,007
总共有六只

156
00:09:47,519 --> 00:09:50,079
我用不同的分配器我都是

157
00:09:50,847 --> 00:09:53,151
要用autocad nltk

158
00:09:53,407 --> 00:09:59,551
让他编译通过的通过了然后示范给你看如果你要直接使用方便

159
00:09:59,807 --> 00:10:01,087
这么写

160
00:10:03,647 --> 00:10:07,743
这个直接使用分配器这个里面这个参数这个参数

161
00:10:08,511 --> 00:10:09,535
我现在都写一

162
00:10:09,791 --> 00:10:13,631
一就是代表要一个元素元素是什么

163
00:10:13,887 --> 00:10:14,655
就是

164
00:10:15,167 --> 00:10:20,799
你在生命OK的时候见挂号里面说的那个像这个都是I am是什么

165
00:10:21,311 --> 00:10:22,079
我是MT

166
00:10:23,359 --> 00:10:24,127
我都是

167
00:10:24,639 --> 00:10:26,175
是的使用还有你

168
00:10:26,943 --> 00:10:32,063
你也可以放了一些要分配一颗石头看着石头这个class

169
00:10:32,575 --> 00:10:34,879
大小是多大赛导

170
00:10:35,647 --> 00:10:37,439
和一个房子等等

171
00:10:39,999 --> 00:10:42,559
说这个仪表是一个地方

172
00:10:43,583 --> 00:10:44,863
那么

173
00:10:46,655 --> 00:10:47,935
我前面讲说

174
00:10:48,959 --> 00:10:54,591
你可以这样用但是你实在不值得这样用也不需要这样用是因为

175
00:10:56,383 --> 00:10:57,663
请问你

176
00:10:58,943 --> 00:11:00,223
你目前如果你

177
00:11:00,479 --> 00:11:06,623
不是使用容器和容器之外你单独某一两个两三个两个30个

178
00:11:06,879 --> 00:11:09,951
需要内存的话你都是怎么拿的意思

179
00:11:12,255 --> 00:11:13,279
你可能要命

180
00:11:14,047 --> 00:11:15,583
咖啡店

181
00:11:15,839 --> 00:11:18,911
或者用malloc puppetry

182
00:11:20,959 --> 00:11:27,103
这些还是我们讲得到政府因为其实最后都是跑到没落的这个大主题就把内存管理的我们

183
00:11:27,359 --> 00:11:30,431
有另外一种可就叫内存管理还要去谈谈

184
00:11:32,479 --> 00:11:36,319
那我们最后都跑到没人

185
00:11:36,575 --> 00:11:42,463
Vmalloc的时候可以要做指定一个大小得到了一个统一的支撑

186
00:11:42,975 --> 00:11:45,023
Free的时候是还这个棍子

187
00:11:45,791 --> 00:11:49,631
你并没有制止连福利的时候要还多少个

188
00:11:50,399 --> 00:11:50,911
自己

189
00:11:51,935 --> 00:11:53,983
你的闹可能说拿到了自己

190
00:11:54,239 --> 00:11:55,775
所以说不用吃

191
00:11:56,799 --> 00:12:02,943
这才是对的这才是好的吗如果你还要去记住当初拿

192
00:12:03,199 --> 00:12:09,343
他的这一根指针他背后头是带着100个自己拿着一根指针是300那另外一个字

193
00:12:09,599 --> 00:12:12,415
你真是1000个谁受的了没有人说的

194
00:12:15,999 --> 00:12:16,767
所以

195
00:12:17,023 --> 00:12:18,303
Rails用嗜好

196
00:12:18,815 --> 00:12:22,399
但是现在你看看这里如果你要直接用分配器的话

197
00:12:24,447 --> 00:12:26,495
我们看994跟995

198
00:12:27,007 --> 00:12:29,055
你分配一个

199
00:12:29,311 --> 00:12:30,847
翻阅一个整数

200
00:12:31,359 --> 00:12:32,639
还的时候呢

201
00:12:33,151 --> 00:12:35,711
你不但还给他那个指针

202
00:12:36,223 --> 00:12:37,247
生意好你

203
00:12:37,503 --> 00:12:41,087
Hello Kitty得到一个只是你不但要还这个时间你还要还

204
00:12:41,599 --> 00:12:42,879
你当初要的是几个

205
00:12:43,391 --> 00:12:49,535
我现在的例子都是要一个所以我还都是换一个如果你一次要个那你这边还

206
00:12:49,791 --> 00:12:50,815
钥匙

207
00:12:51,071 --> 00:12:54,143
如果你要的是五个还是三个会怎么样呢

208
00:12:54,911 --> 00:12:57,215
我会怎么样不小的

209
00:12:58,239 --> 00:13:02,079
要是想要根据源代码的那个

210
00:13:02,591 --> 00:13:03,871
影响最小

211
00:13:04,383 --> 00:13:05,663
组织当然是不好

212
00:13:06,431 --> 00:13:12,575
所以这就是重点什么重点的你不应该直接用分配器因为你用分配器的话

213
00:13:12,831 --> 00:13:16,415
把你的负担很重要去记住当初要了多少个

214
00:13:18,463 --> 00:13:18,975
所以

215
00:13:20,511 --> 00:13:22,047
作为一个结论就是

216
00:13:22,815 --> 00:13:25,887
你真的要去用我这边示范给你看语法是这样

217
00:13:26,399 --> 00:13:32,031
不仅有你应该在你的程序里头去使用容器

218
00:13:33,823 --> 00:13:35,871
而只有小量想让的一些

219
00:13:36,127 --> 00:13:40,479
内存需求的话你就用你过去习惯的领悟了

220
00:13:40,991 --> 00:13:43,551
搭配的地址或者是malloc搭配服务

221
00:13:44,831 --> 00:13:47,391
而不要了用这个

222
00:13:47,647 --> 00:13:48,927
因为它不好用

223
00:13:49,183 --> 00:13:50,463
直接用的话不好

224
00:13:52,767 --> 00:13:55,583
以分配器置于它内部的结构

225
00:13:55,839 --> 00:13:58,143
设计那就非常好玩了

226
00:13:58,655 --> 00:13:59,679
谁是

227
00:13:59,935 --> 00:14:00,959
最有效率的

228
00:14:01,727 --> 00:14:03,775
谁是有什么特性

229
00:14:04,031 --> 00:14:05,311
另外的

230
00:14:05,823 --> 00:14:07,615
我们在第2讲时候会

231
00:14:07,871 --> 00:14:12,735
再多提一些但是最详细的部分要在另外一本课程内存

232
00:14:12,991 --> 00:14:13,503
管理

233
00:14:15,807 --> 00:14:17,855
好今天的第1集啊

234
00:14:18,111 --> 00:14:19,903
进行到这个地方
