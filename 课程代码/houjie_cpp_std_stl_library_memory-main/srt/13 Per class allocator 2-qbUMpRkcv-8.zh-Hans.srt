1
00:00:06,144 --> 00:00:07,424
我们的第2个版本

2
00:00:09,216 --> 00:00:12,800
这个材料是从这个地方出来的

3
00:00:14,592 --> 00:00:20,736
让点不去改变变量然后把它甚至于简化一些变成我的版本

4
00:00:20,992 --> 00:00:23,808
我们不这样向偶像致敬

5
00:00:24,064 --> 00:00:25,088
作者

6
00:00:25,856 --> 00:00:27,648
Scholars

7
00:00:27,904 --> 00:00:30,464
写的很棒的书籍

8
00:00:30,976 --> 00:00:33,280
128的10个条款

9
00:00:33,792 --> 00:00:35,328
里头有这么一个例子

10
00:00:36,864 --> 00:00:38,400
我们来看看这个长相

11
00:00:38,656 --> 00:00:40,960
现在这个Class airplane

12
00:00:42,240 --> 00:00:43,264
Beta在哪里

13
00:00:44,544 --> 00:00:45,056
这两个

14
00:00:46,592 --> 00:00:49,152
一个unsigned long Sonic character

15
00:00:50,176 --> 00:00:55,552
Unsigned long是四个自己Kevin是一个字节所以他加起来是五个字节

16
00:00:56,576 --> 00:01:02,720
不过等一下你会看到这个一般我们定期都会设定来们对其其位

17
00:01:02,976 --> 00:01:05,280
队伍会被调整为8

18
00:01:07,072 --> 00:01:08,864
这是他的数据在这边

19
00:01:09,120 --> 00:01:11,680
这个地方特别把他包装成一个structure

20
00:01:13,216 --> 00:01:18,848
这也是个重庆的手法现在把它叫做representation

21
00:01:19,104 --> 00:01:20,128
这段

22
00:01:21,920 --> 00:01:23,968
这里又出现一个优点

23
00:01:25,760 --> 00:01:30,112
如果你背有点不太理解赶快把时间要出去拿出来复习一下

24
00:01:31,648 --> 00:01:36,512
你可以这样去想象优点就是一个东西用多种角度去看它

25
00:01:36,768 --> 00:01:42,400
同一个东西用不同的角度或者说用不同的名称去表现

26
00:01:42,912 --> 00:01:45,216
所以这个优点是什么意思呢

27
00:01:46,240 --> 00:01:48,800
意思是说这里面有两个member

28
00:01:49,824 --> 00:01:52,896
他是这个两个member其实同一块东西

29
00:01:53,920 --> 00:01:54,432
岁

30
00:01:55,200 --> 00:01:55,968
从一块呢

31
00:01:56,736 --> 00:01:59,040
一个members就是刚刚你看到这个

32
00:01:59,296 --> 00:02:00,320
你个自解

33
00:02:00,832 --> 00:02:02,880
是中国第8个自己的这个东西

34
00:02:04,160 --> 00:02:05,440
另外一个member

35
00:02:06,208 --> 00:02:06,976
意思是

36
00:02:07,232 --> 00:02:10,816
你这句话的意思是我要把它看成一根指针

37
00:02:11,584 --> 00:02:13,376
这个死神的名字叫next

38
00:02:15,168 --> 00:02:17,728
这里带来一个很重要的观念

39
00:02:18,496 --> 00:02:20,544
我的数据本来是这么大

40
00:02:21,568 --> 00:02:26,432
我现在把各自己那只会变成800个自己

41
00:02:26,944 --> 00:02:32,064
但是我换一个角度去看他我是用指针去解释它

42
00:02:32,576 --> 00:02:34,112
指针是四个字节

43
00:02:34,368 --> 00:02:40,512
怎么说本来的八个字给我现在看的是前四个字节把它看成一根指针

44
00:02:42,304 --> 00:02:44,352
好注意这种概念

45
00:02:45,120 --> 00:02:47,424
这个叫embedded point

46
00:02:47,680 --> 00:02:49,984
嵌入式

47
00:02:53,312 --> 00:02:56,640
等下还会出现这个概念我们先把这个放下来

48
00:02:57,408 --> 00:02:59,968
好谢谢还是一些

49
00:03:00,224 --> 00:03:01,760
我市重点的东西

50
00:03:02,272 --> 00:03:03,808
再来就是这两个函数

51
00:03:04,064 --> 00:03:05,600
这一次加上了static

52
00:03:06,880 --> 00:03:11,232
所以我刻意拿这两个版本也有一点点让你比较

53
00:03:12,000 --> 00:03:13,536
刚刚的那个版本

54
00:03:15,072 --> 00:03:20,448
我记得这两个版本有一个是有一个没有可能被我加上去了

55
00:03:22,752 --> 00:03:25,568
好我们再回到这第2版本来

56
00:03:26,848 --> 00:03:28,896
后面还有一些这两个版本不一样的

57
00:03:29,152 --> 00:03:35,296
我都原貌呈现让你来比较一下只是猪细节做法的一些小小

58
00:03:35,552 --> 00:03:36,320
小不同但是

59
00:03:36,832 --> 00:03:38,112
殊途同归

60
00:03:39,392 --> 00:03:40,928
继续往下看

61
00:03:41,696 --> 00:03:47,840
这里面定义了一个常量要512就他的内存内存池

62
00:03:48,096 --> 00:03:49,120
里头呢

63
00:03:49,376 --> 00:03:52,448
每次要的是512个元素

64
00:03:55,008 --> 00:03:57,568
好当使用者要

65
00:03:57,824 --> 00:04:00,128
另一个App的时候

66
00:04:00,896 --> 00:04:04,480
分配内存的那一件事情就落到这里来了

67
00:04:05,248 --> 00:04:06,528
被我们控制了

68
00:04:08,064 --> 00:04:09,344
这里做什么事

69
00:04:11,392 --> 00:04:15,744
首先检检查这个大小符不符合AirPlay

70
00:04:17,024 --> 00:04:18,303
我这边有赞助价

71
00:04:19,839 --> 00:04:21,631
怎么会有错误呢

72
00:04:22,399 --> 00:04:25,215
不可没有错这不是编译器存进来的吗

73
00:04:25,983 --> 00:04:31,615
定义气的纯净这个的大小到这里所以这里还去检查和病人

74
00:04:32,895 --> 00:04:35,455
如果继承发生就会有问题

75
00:04:36,479 --> 00:04:38,783
但这不是我们现在讨论的主题

76
00:04:40,319 --> 00:04:46,463
我们这个故事第1部第2部到第3部到区竞标准库的分配器在中间不会

77
00:04:46,719 --> 00:04:47,999
会发生这个事情

78
00:04:49,279 --> 00:04:51,839
继承的事情说这边我们也就不讨论了

79
00:04:55,423 --> 00:05:01,567
好的这个讲这个可以想象这个检查一定会正确只要不要有技术发生就一定正确

80
00:05:01,823 --> 00:05:03,359
一次下来

81
00:05:04,127 --> 00:05:08,735
里头所做的事情跟刚刚的版本完全一样

82
00:05:09,247 --> 00:05:11,039
分配一大块

83
00:05:11,551 --> 00:05:13,599
然后坐汽车多大会

84
00:05:14,367 --> 00:05:16,671
他现在分配内存的动作用这个动作

85
00:05:17,695 --> 00:05:19,487
上一个版本适用

86
00:05:21,023 --> 00:05:21,535
宁

87
00:05:22,815 --> 00:05:24,863
现在新版本适用

88
00:05:25,119 --> 00:05:26,143
Operational

89
00:05:26,655 --> 00:05:27,679
这些都是缘

90
00:05:28,703 --> 00:05:30,239
Cplusplus给我们的

91
00:05:30,751 --> 00:05:31,775
原始的东西

92
00:05:32,031 --> 00:05:34,079
Primitives原始东西

93
00:05:34,335 --> 00:05:36,895
我们在前面都已经非常清楚她的行为了

94
00:05:37,407 --> 00:05:38,175
他们反正

95
00:05:38,431 --> 00:05:38,943
最

96
00:05:39,199 --> 00:05:41,247
中国跑到malloc去

97
00:05:42,783 --> 00:05:44,831
你这个现在这个版本

98
00:05:45,599 --> 00:05:46,623
分配多大

99
00:05:47,391 --> 00:05:48,159
成甲

100
00:05:48,671 --> 00:05:52,255
Sizeof airplane乘以这个大小就是512

101
00:05:52,511 --> 00:05:54,559
要这么多

102
00:05:55,327 --> 00:05:57,887
有没有用掉cookie那有

103
00:05:58,399 --> 00:06:04,543
只要调用malloc就有用的固体但是他只用药的翘头尾两个故事吧

104
00:06:04,799 --> 00:06:05,567
把自己而已

105
00:06:07,359 --> 00:06:11,199
然后把这一大块切切切切切成512个

106
00:06:11,711 --> 00:06:12,991
这里有透露

107
00:06:13,759 --> 00:06:15,295
我就不带你去看了

108
00:06:16,319 --> 00:06:17,599
这里

109
00:06:17,855 --> 00:06:18,879
借用了

110
00:06:19,391 --> 00:06:24,511
每一块砖512块每块是

111
00:06:25,535 --> 00:06:26,815
Apron怎么办

112
00:06:27,583 --> 00:06:28,863
Airplanes

113
00:06:30,143 --> 00:06:31,935
四加一个字节

114
00:06:32,447 --> 00:06:34,239
被赞成八个自己

115
00:06:35,775 --> 00:06:37,567
在这八个字节里面

116
00:06:38,591 --> 00:06:41,919
用这一个成员这个member去看他

117
00:06:42,431 --> 00:06:44,735
所以看到的是一根指针

118
00:06:45,503 --> 00:06:47,039
用这个指针来

119
00:06:47,295 --> 00:06:48,063
操作

120
00:06:49,599 --> 00:06:52,671
你可以这样想这边有一长串的东西

121
00:06:53,439 --> 00:06:56,511
现在一根指针在这里

122
00:07:00,095 --> 00:07:01,375
把它当成

123
00:07:02,399 --> 00:07:03,167
Sex

124
00:07:03,935 --> 00:07:04,959
Next

125
00:07:05,983 --> 00:07:07,263
然后移动

126
00:07:07,775 --> 00:07:09,311
移动多大呢

127
00:07:10,079 --> 00:07:12,639
因为你要切割的是App

128
00:07:12,895 --> 00:07:15,455
所以每次移动八个字节

129
00:07:16,991 --> 00:07:18,783
这样子叫拉好了

130
00:07:19,039 --> 00:07:20,319
这条链表

131
00:07:22,367 --> 00:07:25,439
这里每次移动八个字节

132
00:07:25,695 --> 00:07:28,255
所做的事情不断的移动

133
00:07:28,511 --> 00:07:31,839
不断的拉好这场戏就是这个服务的行为

134
00:07:36,447 --> 00:07:42,591
在整个的动作跟前面的一版本是完全一样的只是写法一些小细节不同

135
00:07:43,359 --> 00:07:49,503
而罕第1版本最大的不同最大的改善就是Union借用

136
00:07:50,015 --> 00:07:56,159
借用同一个东西的前四个字节当成指针的用

137
00:07:56,671 --> 00:08:00,511
这个概念叫embedded Point的概念

138
00:08:01,791 --> 00:08:05,887
这是一个很好的想法所以在所有的

139
00:08:06,911 --> 00:08:08,191
内存管理上面

140
00:08:08,703 --> 00:08:10,239
都用了这种技巧

141
00:08:14,847 --> 00:08:16,639
这个是

142
00:08:18,431 --> 00:08:20,479
下一页

143
00:08:22,527 --> 00:08:24,575
这里头所做的事情

144
00:08:25,343 --> 00:08:27,903
根本128

145
00:08:28,159 --> 00:08:29,951
第1版本完全一样

146
00:08:30,975 --> 00:08:36,351
啊收到回来的指针放入单向链表头

147
00:08:37,119 --> 00:08:38,143
这样就回收了

148
00:08:42,239 --> 00:08:43,263
你可能会很

149
00:08:43,519 --> 00:08:45,055
开始有联想

150
00:08:45,823 --> 00:08:49,919
我们回到上个月来这里是512个元素

151
00:08:51,199 --> 00:08:53,759
所以如果我是一个客户

152
00:08:54,015 --> 00:08:55,807
我使用AirPlay

153
00:08:56,319 --> 00:08:58,367
吻宁了10000次

154
00:08:58,879 --> 00:09:00,415
将会是什么情况

155
00:09:01,951 --> 00:09:03,999
你可以想象将会是

156
00:09:04,511 --> 00:09:10,655
512个用完了之后再一次510个在用完了再一次510

157
00:09:10,911 --> 00:09:12,703
最后用了总共1万个

158
00:09:14,751 --> 00:09:17,823
好我用完了之后1万架飞机然后我可以

159
00:09:19,871 --> 00:09:20,639
Debate

160
00:09:20,895 --> 00:09:26,527
我是使用者我是用14000个

161
00:09:27,807 --> 00:09:30,111
于是落入这一个函数

162
00:09:32,415 --> 00:09:36,767
因此将会有一个链表全场是10000

163
00:09:37,791 --> 00:09:41,887
把它都是五月五日现在已经全部串接回来就是一关

164
00:09:44,447 --> 00:09:45,727
如果

165
00:09:45,983 --> 00:09:48,287
我接下去继续又要

166
00:09:48,543 --> 00:09:51,615
让你又他又从这10000个里面去哪

167
00:09:52,639 --> 00:09:55,967
拿了5000个要还得3000个等等等

168
00:09:56,223 --> 00:09:59,295
所以这一条链表会有一个疯子

169
00:09:59,807 --> 00:10:01,087
高峰期

170
00:10:01,599 --> 00:10:07,743
好像那个交通的高峰尖峰时刻让你曾经一次

171
00:10:07,999 --> 00:10:11,327
性药过最最高的累计总量

172
00:10:11,839 --> 00:10:15,679
最后如果都还掉的话就全部落到了这个链表里头

173
00:10:18,239 --> 00:10:20,287
他会不会还给操作系统

174
00:10:22,335 --> 00:10:23,359
方出

175
00:10:23,615 --> 00:10:24,383
适用

176
00:10:24,895 --> 00:10:26,687
这个方式来拿

177
00:10:27,455 --> 00:10:28,991
这个其实就是没了

178
00:10:31,039 --> 00:10:33,343
那还的时候就应该调用主义了

179
00:10:34,879 --> 00:10:36,671
这里都没有调用实例

180
00:10:39,487 --> 00:10:43,327
这里只是把区块一个一个的回收到单向链表来

181
00:10:47,423 --> 00:10:48,959
我们看上一个版本

182
00:10:51,007 --> 00:10:53,311
上一个版本的这个函数

183
00:10:53,823 --> 00:10:54,847
也是没有辐射

184
00:10:55,103 --> 00:10:56,639
他只是把奇怪

185
00:10:56,895 --> 00:10:58,687
回收到自由链表来

186
00:11:01,759 --> 00:11:04,063
我要检讨一下这样子好吗

187
00:11:05,599 --> 00:11:09,439
这1万个人数也许是100万个或10000000个元素

188
00:11:10,719 --> 00:11:12,767
都不还给操作系统这样好吗

189
00:11:13,023 --> 00:11:14,559
这样当然不好

190
00:11:14,815 --> 00:11:15,839
当然不好

191
00:11:18,143 --> 00:11:22,495
但是如果要还的话会技术难点非常高

192
00:11:23,007 --> 00:11:25,055
这件事情我们后面再讨论

193
00:11:25,567 --> 00:11:28,895
回到这个减非常简单的设计

194
00:11:29,407 --> 00:11:31,967
他虽然没有还给操作系统

195
00:11:32,223 --> 00:11:35,295
但是你也不能说它是内存泄漏

196
00:11:35,807 --> 00:11:39,391
没有任何一个泄露都在他的手上

197
00:11:40,927 --> 00:11:41,951
都在他手上

198
00:11:43,487 --> 00:11:45,279
好看看执行结果

199
00:11:46,303 --> 00:11:47,327
这个是测试

200
00:11:49,887 --> 00:11:52,959
我想打印出现在这个FM多大了

201
00:11:53,215 --> 00:11:57,823
刚刚钻出来是54家1455吗还是算出来是吧

202
00:11:58,079 --> 00:12:00,127
这是因为对其的关系

203
00:12:01,663 --> 00:12:04,223
然后准备100根指针

204
00:12:05,247 --> 00:12:06,527
生命100次

205
00:12:09,343 --> 00:12:10,879
随机测试一下

206
00:12:11,135 --> 00:12:14,463
这个跟现在的主题无关我要测试我现在

207
00:12:14,719 --> 00:12:20,351
通过这一个小型的分配器均六到的东西是正确的可用的没有错乱的

208
00:12:20,863 --> 00:12:21,887
测试一下

209
00:12:23,423 --> 00:12:24,447
重点在这里

210
00:12:25,215 --> 00:12:27,519
我要输出前10个指针

211
00:12:28,031 --> 00:12:29,823
看看他们的间隔

212
00:12:30,847 --> 00:12:34,431
反正这个测试的这个概念跟刚刚第1版本完全一样

213
00:12:36,223 --> 00:12:38,527
测试出来的结果价格吧

214
00:12:40,063 --> 00:12:41,855
每一个区块就是吧

215
00:12:42,111 --> 00:12:48,255
每一个区块就是吧所以它是紧紧相连没有好用的内存

216
00:12:48,511 --> 00:12:51,071
不是没有好用的cookie

217
00:12:53,119 --> 00:12:53,887
非常好

218
00:12:56,191 --> 00:12:57,727
这是左边的情况

219
00:12:59,519 --> 00:13:00,543
右边的

220
00:13:01,567 --> 00:13:07,199
右边是没有写这个

221
00:13:07,967 --> 00:13:10,015
水没有进入这个空置来

222
00:13:11,551 --> 00:13:12,575
所以

223
00:13:13,087 --> 00:13:18,463
你有100万个100个这个例子是100个100个f

224
00:13:18,975 --> 00:13:21,279
每一个上下都在工作

225
00:13:21,791 --> 00:13:23,583
因此他们的间隔是

226
00:13:24,351 --> 00:13:26,143
原来的大小

227
00:13:26,655 --> 00:13:28,447
再加上下cookie

228
00:13:29,215 --> 00:13:30,495
大小正合适

229
00:13:35,871 --> 00:13:37,407
左边当然是很好的

230
00:13:37,919 --> 00:13:39,455
右边是原始情况

231
00:13:39,711 --> 00:13:41,503
左边是改善的情况

232
00:13:42,015 --> 00:13:45,343
怎么改善了因为我们写了一个小型的内内

233
00:13:45,855 --> 00:13:48,927
从此一个小镜的分配器

234
00:13:51,487 --> 00:13:52,767
第2版本

235
00:13:53,535 --> 00:13:58,143
那就比一般人进化就加上了瘾

236
00:13:58,399 --> 00:14:01,215
这样就非常好了非常非常好

237
00:14:02,751 --> 00:14:05,055
只除了最后我们有一个小小的遗憾

238
00:14:05,567 --> 00:14:10,175
就是这个疯子最后全部累计起来的他如果能够在

239
00:14:10,431 --> 00:14:13,759
想办法在还给操作系统那就更好了

240
00:14:16,063 --> 00:14:16,831
这是我们的

241
00:14:17,599 --> 00:14:18,367
第2版本
