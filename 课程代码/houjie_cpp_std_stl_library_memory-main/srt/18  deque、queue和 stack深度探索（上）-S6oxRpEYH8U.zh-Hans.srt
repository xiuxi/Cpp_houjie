1
00:00:06,656 --> 00:00:11,776
啊前面花了很少的时间介绍了几个很简单的我们从vector

2
00:00:12,032 --> 00:00:13,568
然后瑞

3
00:00:14,080 --> 00:00:16,128
多list的模式根本没有提

4
00:00:16,384 --> 00:00:18,176
就打出投影片因为他跟

5
00:00:19,712 --> 00:00:20,992
非常相像

6
00:00:21,248 --> 00:00:27,392
接下来这一个容器就比较复杂一些也非常有趣因为你几乎不可能在

7
00:00:28,672 --> 00:00:31,232
在一些经典的古典的这种

8
00:00:32,000 --> 00:00:33,280
数据结构

9
00:00:33,536 --> 00:00:39,424
书记看过这一种容器但它是非常好用非常有用的

10
00:00:40,448 --> 00:00:43,008
这种勇气叫dec

11
00:00:44,288 --> 00:00:50,432
你可能吃光分解成的Q也没错就双向开口的就不过西方人面

12
00:00:50,688 --> 00:00:52,480
我们也就跟着变大

13
00:00:52,736 --> 00:00:54,784
The back这个东西

14
00:00:56,064 --> 00:01:01,696
你可能会看到一些文章和书籍面试这么样用这种图来形容

15
00:01:02,464 --> 00:01:03,488
描述它

16
00:01:03,744 --> 00:01:08,352
怎么样一个双向开口的一块空间

17
00:01:09,632 --> 00:01:13,728
它对于单向开口的那就是master了

18
00:01:14,240 --> 00:01:18,080
Vector怎么样在一端扩充刚刚已经讲过了

19
00:01:18,592 --> 00:01:20,896
还要到别的地方去挖会

20
00:01:22,688 --> 00:01:28,832
那端反向C端头端也要扩充那这个怎么做呢这张

21
00:01:29,088 --> 00:01:31,648
同时不能表现出他怎么做

22
00:01:32,160 --> 00:01:34,208
他怎么做怎么做

23
00:01:35,744 --> 00:01:39,072
这是根据说scone源代码画出来的图

24
00:01:40,352 --> 00:01:43,168
他的方式是用分段

25
00:01:44,192 --> 00:01:45,728
然后把他串接起来

26
00:01:47,264 --> 00:01:53,152
好像这张图片表现出这有五段一段两段三段四段段

27
00:01:53,920 --> 00:01:57,760
现在白色的部分就是已经放了元素进去的

28
00:01:58,272 --> 00:02:03,648
这个灰格子的部分就是还没有放元素可以放但是还没放的

29
00:02:04,160 --> 00:02:05,440
空间容量

30
00:02:06,464 --> 00:02:07,744
那这五个

31
00:02:08,768 --> 00:02:10,304
一段落

32
00:02:10,816 --> 00:02:12,864
有什么称为buffer

33
00:02:13,376 --> 00:02:14,400
南充区

34
00:02:14,912 --> 00:02:21,056
不过后面的看到源代码的时候又或者他的艺术家也把这个东西叫做node集

35
00:02:21,312 --> 00:02:22,080
节点

36
00:02:22,592 --> 00:02:27,712
我习惯用缓冲区而因为节点比较常常用在链表的那种元素身上

37
00:02:28,736 --> 00:02:33,344
这五个缓冲区要怎么被结合起来了分段

38
00:02:33,600 --> 00:02:38,720
我常常讲这个分段连续他对外号称连续使用者是

39
00:02:38,976 --> 00:02:45,120
其实不知道他是很短的以为他是李旭的所以这五个东西必须有人

40
00:02:45,376 --> 00:02:47,424
控制台把他串接起来

41
00:02:47,936 --> 00:02:48,960
就是这个东西

42
00:02:50,240 --> 00:02:51,520
这是一个

43
00:02:52,032 --> 00:02:55,872
源代码里面的等下你会看到它的实现它是一个

44
00:02:56,128 --> 00:02:56,896
欧瑞

45
00:02:57,408 --> 00:03:02,528
是个master不起这个master就我们前面讲过半个他就是一个呗

46
00:03:03,040 --> 00:03:06,880
这里面的每个元素其实只是一个指针

47
00:03:07,648 --> 00:03:13,792
这张图上可以让你感受到这个指针这些指针分别指向各个缓冲区

48
00:03:14,048 --> 00:03:14,560
去buffer

49
00:03:16,096 --> 00:03:17,120
所以

50
00:03:17,376 --> 00:03:23,264
这五个缓冲区的次序是怎么样啊那就看这五个字真的是去

51
00:03:25,824 --> 00:03:26,592
这样就把它们

52
00:03:26,848 --> 00:03:27,872
并掉下来了

53
00:03:28,896 --> 00:03:30,432
如果

54
00:03:31,200 --> 00:03:34,016
我们不需要放元素在尾端

55
00:03:34,528 --> 00:03:37,088
把这一个缓冲区用光的话

56
00:03:38,112 --> 00:03:39,648
还要怎么扩充呢

57
00:03:40,928 --> 00:03:43,488
贝壳要怎么扩充了它只要在

58
00:03:43,744 --> 00:03:48,608
新分配一个缓冲区并且串接到这个地方来

59
00:03:49,632 --> 00:03:51,168
这样就是往后扩充了

60
00:03:51,936 --> 00:03:56,544
他说过前头也不爽的也装满了元素

61
00:03:57,056 --> 00:03:59,360
要继续不喜欢的怎么办呢

62
00:04:00,896 --> 00:04:07,040
贝壳这个容器只要在分配一个缓冲区并且用这边的指针哄的这个

63
00:04:07,296 --> 00:04:07,808
格格

64
00:04:08,064 --> 00:04:12,160
指针指向新的缓冲区这样就是往前库中

65
00:04:15,488 --> 00:04:21,631
这样子他就能够实现双向的一个一个开口可以可以拿东西可以去

66
00:04:21,887 --> 00:04:23,167
取东西可以放东西

67
00:04:23,679 --> 00:04:29,823
奥秘怎么没有看到这张图之前你很难想象怎么能够双向过

68
00:04:30,079 --> 00:04:32,127
我从2月开始这么做的

69
00:04:32,895 --> 00:04:37,759
这张图蓝色的部分每一个我的话的是革

70
00:04:38,015 --> 00:04:39,039
他是

71
00:04:39,295 --> 00:04:40,575
给代器iterator

72
00:04:41,087 --> 00:04:44,671
这个迭代器是一个class

73
00:04:45,951 --> 00:04:46,975
这个class

74
00:04:47,231 --> 00:04:48,767
胃部有四个元素

75
00:04:50,303 --> 00:04:54,655
后面会看到源代码就会更详细的是我们现在先看看我的整理

76
00:04:55,167 --> 00:04:56,703
这个迭代器

77
00:04:57,983 --> 00:04:59,007
四格

78
00:04:59,263 --> 00:05:02,079
在开源代码的名称里面叫做current

79
00:05:02,591 --> 00:05:04,383
First master node

80
00:05:04,639 --> 00:05:06,175
其中的node

81
00:05:07,199 --> 00:05:08,479
指的就是

82
00:05:09,247 --> 00:05:13,087
这款1块就可控制中心好了

83
00:05:13,599 --> 00:05:14,879
控制中心

84
00:05:15,391 --> 00:05:17,951
这个node指的就是控制中心

85
00:05:19,743 --> 00:05:22,047
所以一个迭代器

86
00:05:23,071 --> 00:05:26,399
它能够知道控制中心在哪里

87
00:05:27,167 --> 00:05:30,239
当这个迭代器要加加或减减的时候

88
00:05:31,007 --> 00:05:36,639
他就能够跳到另一个分段去因为分段的控制权不在这里

89
00:05:38,175 --> 00:05:42,783
我们现在谈到这边儿这个node用户是这样

90
00:05:43,295 --> 00:05:45,087
First contact

91
00:05:45,343 --> 00:05:48,671
First Class指的是

92
00:05:50,463 --> 00:05:56,607
刚刚这个node所指出来的那个分段一个吧分某一个就是指某一个吧

93
00:05:56,863 --> 00:05:59,423
在那个buffer里头的

94
00:05:59,679 --> 00:06:00,447
头

95
00:06:00,703 --> 00:06:01,471
捍卫

96
00:06:01,727 --> 00:06:04,287
各位看我画的图这个first

97
00:06:05,311 --> 00:06:06,847
Lastindex的是这里

98
00:06:07,615 --> 00:06:11,711
前臂后开区间最后一个元素的下一个位置

99
00:06:12,479 --> 00:06:14,015
First test

100
00:06:14,783 --> 00:06:16,063
这两个

101
00:06:16,831 --> 00:06:21,439
指针作为标并标识出这个缓冲区的

102
00:06:21,951 --> 00:06:22,719
简介

103
00:06:23,743 --> 00:06:24,511
在什么地方

104
00:06:25,279 --> 00:06:27,583
为什么要这样标出来呢

105
00:06:28,351 --> 00:06:32,191
因为这个iterator这一大块这个这个iterator

106
00:06:33,727 --> 00:06:36,031
讲是说现在指向这里好了

107
00:06:36,799 --> 00:06:42,943
哪怕他家家的时候就跑这里来在加加这里就要加加加加加加加当他家家乐

108
00:06:43,199 --> 00:06:44,223
这里的时候

109
00:06:44,479 --> 00:06:45,759
已经到边界了

110
00:06:46,271 --> 00:06:50,879
这时候他为了保持一种连续空间的这一种

111
00:06:51,135 --> 00:06:53,951
状态最棒这个议题的

112
00:06:54,207 --> 00:06:58,559
到这里的时候其实应该到下一个环中去的这里

113
00:07:01,375 --> 00:07:05,215
所以这个iterator在加加减减的过程中

114
00:07:05,983 --> 00:07:12,127
每次加加或减价他都要判断他是不是走到了边界如果走到了B

115
00:07:12,383 --> 00:07:15,199
边界它就要跳到下一个

116
00:07:15,455 --> 00:07:16,223
中区

117
00:07:16,479 --> 00:07:21,599
她怎么跳到下一个缓冲区呢他就要藉由这一个指针

118
00:07:22,879 --> 00:07:25,439
指向这个中控中心先

119
00:07:26,463 --> 00:07:27,743
移到下一个

120
00:07:28,767 --> 00:07:29,791
这一个地方

121
00:07:30,047 --> 00:07:32,863
这个指针可以指出下一个缓冲区在哪里

122
00:07:33,375 --> 00:07:34,911
然后他才可以跳过来

123
00:07:36,191 --> 00:07:40,543
更详细的部分后面太原大了会清楚这个概念

124
00:07:41,311 --> 00:07:42,335
所以

125
00:07:43,103 --> 00:07:44,383
那么做个整理就是

126
00:07:44,639 --> 00:07:49,247
这个大可能他是一个连续的是一个分段连续

127
00:07:50,015 --> 00:07:52,575
连续式假像分段是40

128
00:07:53,343 --> 00:07:58,207
而迭代器的走了说为了维持这个连续的这种假象

129
00:07:58,463 --> 00:08:00,767
张杰再次走到了

130
00:08:01,023 --> 00:08:07,167
边解锁不管是尾巴这个编写我的同事个边界它都要有能力

131
00:08:07,423 --> 00:08:09,727
跳到下一个缓冲区去

132
00:08:12,031 --> 00:08:16,127
那怎么漂亮下一个缓冲区那它必须能够回到控制中心来

133
00:08:16,383 --> 00:08:16,895
所以

134
00:08:17,407 --> 00:08:23,551
边界靠这两个字出来而回到控制中心的考这一个指针指出来

135
00:08:26,111 --> 00:08:28,671
至于第1个叫current的是什么

136
00:08:30,719 --> 00:08:35,583
要知道迭代器的任务就是要指向某一个元素

137
00:08:35,839 --> 00:08:41,983
说现在在这个缓冲区里面到底这一个迭代器指的是哪一个元素呢

138
00:08:42,239 --> 00:08:44,031
这就是这个科润的作用

139
00:08:44,287 --> 00:08:47,615
现在current指的是这里的元素是99

140
00:08:50,175 --> 00:08:51,455
所以你可以想象

141
00:08:51,967 --> 00:08:56,831
对于的迭代器角色现在的状况就是这个图啊可能是这里

142
00:08:57,343 --> 00:08:58,623
剪剪的话呢

143
00:08:58,879 --> 00:09:02,207
这个红色就以到这里来再捡捡就一到这里

144
00:09:03,487 --> 00:09:09,631
First and last都不会变因为他们是标并指向边界它们是不变的只有克

145
00:09:09,887 --> 00:09:10,399
Currency

146
00:09:10,655 --> 00:09:11,423
电动

147
00:09:13,215 --> 00:09:19,359
但是如果跑道落到下一个缓冲区和前一个缓冲区当然是所有

148
00:09:19,615 --> 00:09:21,151
四个人数变动

149
00:09:26,271 --> 00:09:27,039
好

150
00:09:27,295 --> 00:09:30,111
为什么我在这一张图里头

151
00:09:31,135 --> 00:09:33,439
要画出三个与周围的

152
00:09:33,951 --> 00:09:34,719
给大气

153
00:09:35,487 --> 00:09:37,279
下面的这个start

154
00:09:37,535 --> 00:09:38,559
Finish

155
00:09:38,815 --> 00:09:41,375
这个就是源代码里面的名称

156
00:09:43,679 --> 00:09:47,263
前的不是提过吗所有的容器

157
00:09:48,287 --> 00:09:49,567
都维护的

158
00:09:50,591 --> 00:09:52,895
两个迭代器

159
00:09:53,663 --> 00:09:55,711
分别指向头和胃

160
00:09:56,223 --> 00:09:57,247
就是这样

161
00:10:00,831 --> 00:10:06,975
所有的容器几乎所有了这个要一的细想的是几乎

162
00:10:07,231 --> 00:10:10,815
几乎所有容器都提供两个函数

163
00:10:11,071 --> 00:10:14,911
成人函授教并跟and begin就是春回大地

164
00:10:15,423 --> 00:10:17,471
就不作为

165
00:10:19,263 --> 00:10:20,543
我们往下看

166
00:10:23,359 --> 00:10:27,967
一样是这张图现在我就把源代码打出来了我们可以比对

167
00:10:28,735 --> 00:10:29,759
Factory

168
00:10:31,039 --> 00:10:36,415
我仍然是先用的绿2.91版的源代码因为它比较好理解

169
00:10:37,951 --> 00:10:43,327
对了我在整个课程里面一直是用个东西的源代码来做讲解那么在其他的

170
00:10:44,095 --> 00:10:45,887
平台舒服的编译器呢

171
00:10:46,655 --> 00:10:50,751
你可以联想给你推销的这些原理都一样

172
00:10:51,263 --> 00:10:53,823
只是细节的我有些小小的不同

173
00:10:55,615 --> 00:11:01,759
我们当然是找最好最容易理解而且在业界被公认为效率最高的一个版本来

174
00:11:02,015 --> 00:11:04,063
讲所以我去

175
00:11:04,319 --> 00:11:07,391
好我们来看这个project

176
00:11:09,439 --> 00:11:13,279
里头我总是先观察他的数据

177
00:11:14,303 --> 00:11:15,583
跳出来在这里

178
00:11:16,351 --> 00:11:17,119
绿色的

179
00:11:17,887 --> 00:11:19,935
这就是start的这个

180
00:11:20,959 --> 00:11:22,239
Venus这个

181
00:11:23,007 --> 00:11:23,775
Maps

182
00:11:26,847 --> 00:11:27,871
Website

183
00:11:28,383 --> 00:11:31,199
就是这个中控控制中心的大小

184
00:11:31,455 --> 00:11:34,527
我前面我刚才提过这个控制中心

185
00:11:34,783 --> 00:11:40,671
他是一个vector谁他是会增长的你可以看到这个地方划了巴格

186
00:11:41,183 --> 00:11:42,207
表示他可以

187
00:11:42,719 --> 00:11:45,279
串接起八个缓冲区

188
00:11:46,303 --> 00:11:47,583
用光了怎么办呢

189
00:11:48,095 --> 00:11:52,447
你继续上我的例子放了100万个元素是发个缓冲区根本不够吗

190
00:11:53,471 --> 00:11:57,055
那么这个控制中心就会自动成长为16

191
00:11:57,823 --> 00:11:59,359
发来的32

192
00:12:00,639 --> 00:12:06,783
364因为我说了他是一个master所以他的成长是两倍成长的

193
00:12:09,343 --> 00:12:14,207
好那我们来家看这一些数据全部把加起来是多大

194
00:12:15,999 --> 00:12:17,023
Map是什么

195
00:12:17,791 --> 00:12:19,327
US on Messenger

196
00:12:20,095 --> 00:12:21,631
Report是什么

197
00:12:21,887 --> 00:12:22,655
在上面

198
00:12:24,447 --> 00:12:25,215
他是

199
00:12:25,727 --> 00:12:26,495
Hitherto

200
00:12:27,519 --> 00:12:29,567
这个口语不太好讲啊

201
00:12:30,591 --> 00:12:32,639
它是指针指向这个类型

202
00:12:33,407 --> 00:12:35,199
而这个类型在网上看

203
00:12:35,711 --> 00:12:38,015
在网上看

204
00:12:42,879 --> 00:12:45,695
我这边没有列出来我看一下

205
00:12:49,791 --> 00:12:50,815
我没有列出来

206
00:12:51,327 --> 00:12:52,607
不过我这边有个注解

207
00:12:53,119 --> 00:12:56,447
好的你要相信我这个注解是什么意思就是说

208
00:12:57,215 --> 00:12:58,751
这一个

209
00:12:59,775 --> 00:13:03,615
App这个变量到底是什么东西

210
00:13:03,871 --> 00:13:05,151
是指针

211
00:13:05,407 --> 00:13:07,455
指向指针指向的

212
00:13:07,967 --> 00:13:09,247
体型号型号

213
00:13:10,527 --> 00:13:14,367
所以为什么会听见啊型号因为这1

214
00:13:14,623 --> 00:13:18,207
各指针所指的这里面证每一个元素又都是指针

215
00:13:18,463 --> 00:13:20,255
所以才会这样设计

216
00:13:21,279 --> 00:13:22,559
它的大小是多少

217
00:13:22,815 --> 00:13:25,887
它本身是一根指针啊所以它的大小是

218
00:13:26,143 --> 00:13:28,191
在32位练方案是

219
00:13:29,471 --> 00:13:30,495
Maxsize

220
00:13:30,751 --> 00:13:35,871
Website他的类型是30 time table上面我也没列出来

221
00:13:36,895 --> 00:13:39,967
30 type就是一个大小也是4

222
00:13:40,991 --> 00:13:47,135
其实他可能是这个要想一下真是个unsigned long或者379大小

223
00:13:47,391 --> 00:13:48,927
这两个都知道了

224
00:13:49,695 --> 00:13:50,719
四加四

225
00:13:51,231 --> 00:13:54,303
那么这两个呢大跟非你去它是一种类的

226
00:13:54,815 --> 00:13:58,143
Iterator是什么我们不知道它的大小啊

227
00:13:58,655 --> 00:13:59,935
Iterator在这里

228
00:14:03,263 --> 00:14:04,031
他是

229
00:14:04,543 --> 00:14:05,055
一个

230
00:14:05,567 --> 00:14:06,847
这个class

231
00:14:07,871 --> 00:14:12,991
灵车换了一个名称这个可能就这一个Class在哪呢

232
00:14:14,015 --> 00:14:14,527
下一页

233
00:14:18,367 --> 00:14:20,671
他的数据找出来是这四个

234
00:14:21,951 --> 00:14:23,743
这四个前三个是指针

235
00:14:24,511 --> 00:14:25,535
第4个呢

236
00:14:27,071 --> 00:14:28,095
这个类型

237
00:14:29,119 --> 00:14:29,887
网上看

238
00:14:30,399 --> 00:14:31,167
看得到

239
00:14:31,423 --> 00:14:33,727
Nethunter在这个地方

240
00:14:35,775 --> 00:14:36,543
也是个指针

241
00:14:38,591 --> 00:14:39,871
在这四个都是指针

242
00:14:40,895 --> 00:14:47,039
也是因为我看到了这个源代码所以华盛顿就是这个浅色的部分这些这些

243
00:14:47,295 --> 00:14:49,343
而且这些都是迭代器

244
00:14:50,111 --> 00:14:52,671
这四个就是这四个东西

245
00:14:53,695 --> 00:14:55,999
看我的画图它同样都是指针

246
00:14:57,023 --> 00:14:58,047
所以

247
00:14:58,303 --> 00:14:59,839
一个迭代器多大

248
00:15:00,095 --> 00:15:01,887
四乘以46

249
00:15:03,423 --> 00:15:04,703
在data里面

250
00:15:05,215 --> 00:15:09,055
一个迭代器本身的大小是16

251
00:15:11,359 --> 00:15:16,223
他这个大小不会影响比如说我们人数要放100万个啦

252
00:15:16,479 --> 00:15:22,623
什么等等等地跟那些没有什么关系他本身多大没有跟我们写程式写程序没有

253
00:15:22,879 --> 00:15:23,903
太大的关系

254
00:15:24,415 --> 00:15:25,951
不过我们

255
00:15:26,719 --> 00:15:28,767
还是能这样认识他还是很好的

256
00:15:30,559 --> 00:15:31,583
好他是16

257
00:15:31,839 --> 00:15:33,119
说回到前夜了

258
00:15:34,143 --> 00:15:36,703
一个DAC本身到底是多大

259
00:15:37,983 --> 00:15:40,031
这两个start to finish

260
00:15:42,591 --> 00:15:43,871
每一个是16

261
00:15:45,407 --> 00:15:46,431
16乘以二

262
00:15:46,687 --> 00:15:47,711
32

263
00:15:48,223 --> 00:15:50,271
这两个人哪一个是4

264
00:15:50,527 --> 00:15:53,855
428除以32加84

265
00:15:55,135 --> 00:15:57,439
当你创建一个DAC时候

266
00:15:57,695 --> 00:16:01,279
这个对象本身40个白40个自己

267
00:16:02,559 --> 00:16:08,191
至于他那不放多少元素那是动态分配或的跟这个对象本身没有关系

268
00:16:12,543 --> 00:16:13,311
好

269
00:16:13,567 --> 00:16:14,847
我们继续往下看

270
00:16:15,615 --> 00:16:17,151
这个DAC

271
00:16:17,919 --> 00:16:20,991
有三个参数模板参数

272
00:16:22,527 --> 00:16:27,135
我可以先几点就是到了新版本现在2.9了

273
00:16:27,647 --> 00:16:29,695
现在你看的是2.9

274
00:16:29,951 --> 00:16:32,511
到4.9 5.0 5.1呢

275
00:16:32,767 --> 00:16:33,535
不一样了

276
00:16:34,047 --> 00:16:40,191
不再是三个参数这边先提一下这里的三个参数的意思是

277
00:16:40,447 --> 00:16:46,335
一个大家很清楚吗旧元素的类型那个就是分配器的类型的三个呢

278
00:16:46,591 --> 00:16:48,383
叫做buffer size

279
00:16:48,639 --> 00:16:51,199
刚刚在讲这些就是发粉

280
00:16:51,711 --> 00:16:54,783
花粉到底可以容纳多少个元素

281
00:16:55,807 --> 00:16:58,367
在旧的版本是允许你指定的

282
00:16:58,879 --> 00:17:00,671
它的默认值是0

283
00:17:01,439 --> 00:17:02,719
这真是奇怪

284
00:17:04,255 --> 00:17:07,839
他怎么会默认缓冲区大小为零呢

285
00:17:08,863 --> 00:17:11,423
我们看它这个很特殊的设计

286
00:17:12,447 --> 00:17:14,239
源代码在上面这里

287
00:17:14,751 --> 00:17:17,823
有一个哈里头有一个函数叫做

288
00:17:18,335 --> 00:17:19,615
Buffer_size

289
00:17:20,639 --> 00:17:21,407
要用来

290
00:17:21,919 --> 00:17:23,199
确定用来

291
00:17:23,455 --> 00:17:28,319
判断用来计算一个缓冲区可以容纳多少元素

292
00:17:29,599 --> 00:17:31,647
如果是0的话

293
00:17:32,159 --> 00:17:35,743
还没有讲啊这边有一些文字说明啊

294
00:17:37,023 --> 00:17:39,071
我就不知道这个面了

295
00:17:39,583 --> 00:17:41,631
三个的意思是这样

296
00:17:42,143 --> 00:17:45,983
如果0表示使用于是默认值

297
00:17:46,239 --> 00:17:49,311
那默认值怎么定义呢好多上看

298
00:17:50,079 --> 00:17:50,847
如果是

299
00:17:51,103 --> 00:17:52,383
540

300
00:17:53,151 --> 00:17:57,503
这座开始计算但如果是0的话

301
00:17:58,015 --> 00:17:58,783
就是后

302
00:17:59,295 --> 00:18:01,855
你仔细看这一个运算式

303
00:18:02,367 --> 00:18:04,415
如果是0的话

304
00:18:05,183 --> 00:18:07,231
来看看无事

305
00:18:09,535 --> 00:18:10,559
我等一点

306
00:18:10,815 --> 00:18:12,607
他是林就表示

307
00:18:13,119 --> 00:18:13,631
要选

308
00:18:17,215 --> 00:18:18,495
再看一次

309
00:18:19,519 --> 00:18:21,055
恩如果是0

310
00:18:22,335 --> 00:18:24,127
零不等于零吗

311
00:18:26,943 --> 00:18:30,271
不对那所以要找的是

312
00:18:35,135 --> 00:18:38,207
我都有点搞混了我们花一点时间看看这个

313
00:18:46,399 --> 00:18:47,423
我们再看一次

314
00:18:47,679 --> 00:18:49,727
其实你也可以从上面我的注解的

315
00:18:49,983 --> 00:18:51,007
到答案了

316
00:18:52,031 --> 00:18:56,383
我们先讲如果有指定值的话直接无好了比如说

317
00:18:56,895 --> 00:18:57,919
长武进去

318
00:18:58,943 --> 00:18:59,455
那么

319
00:18:59,711 --> 00:19:00,479
无

320
00:19:00,735 --> 00:19:01,759
他不是你

321
00:19:02,783 --> 00:19:03,551
所以

322
00:19:04,575 --> 00:19:05,855
这个结果就是

323
00:19:06,367 --> 00:19:07,391
绿色的这个

324
00:19:08,159 --> 00:19:12,767
这就是说你指定要五个你的缓冲区指定五个元素所以把暗95

325
00:19:14,815 --> 00:19:18,655
那如果你没指定默认是0 0呢

326
00:19:18,911 --> 00:19:21,727
好令那就是坐后面这个动作

327
00:19:23,775 --> 00:19:26,079
后面这一个动作

328
00:19:26,591 --> 00:19:27,615
又要看看

329
00:19:28,383 --> 00:19:30,943
到底一个元素是多大

330
00:19:31,967 --> 00:19:34,271
如果这个元素

331
00:19:34,527 --> 00:19:37,087
大于512个字节

332
00:19:38,879 --> 00:19:43,743
他是在袜子这个蛮大的他就让一个缓冲区只放一个元素

333
00:19:45,791 --> 00:19:47,583
但如果你的元素

334
00:19:48,095 --> 00:19:48,607
次

335
00:19:49,631 --> 00:19:54,751
比510小比如说你放整数好了那它的大小是

336
00:19:55,519 --> 00:20:00,895
那么一个缓冲区要放多少个整数那就是512

337
00:20:01,151 --> 00:20:02,431
除以4

338
00:20:03,455 --> 00:20:04,991
就是这一个运算

339
00:20:07,039 --> 00:20:12,927
你会去慢慢你慢慢体会的话那你就看一下我前面的这个注解就会非常的清楚

340
00:20:14,719 --> 00:20:16,255
所以

341
00:20:16,511 --> 00:20:18,815
旧的版本登陆2.9版

342
00:20:19,071 --> 00:20:20,351
允许我们

343
00:20:21,375 --> 00:20:23,423
指定缓冲区的大小

344
00:20:26,751 --> 00:20:29,823
新版不允许等下看一个代码可以看到

345
00:20:33,663 --> 00:20:34,943
我们继续往下

346
00:20:37,503 --> 00:20:41,343
所以对于这个本身它的分段联系

347
00:20:41,855 --> 00:20:43,647
大概我们都已经解释过了

348
00:20:44,159 --> 00:20:46,463
我们现在来看看它的迭代器

349
00:20:46,719 --> 00:20:47,487
Iterator

350
00:20:49,023 --> 00:20:55,167
这一张图片所呈现的源代码只是很小的一部分这里有点点点

351
00:20:55,423 --> 00:20:58,239
很小的一部分我要呈现的是什么呢

352
00:20:58,495 --> 00:21:04,639
他升为迭代器的大家庭的一份子整个STL的一份子他要尊

353
00:21:04,895 --> 00:21:06,431
因循的规则是

354
00:21:06,687 --> 00:21:08,735
它必须定义出

355
00:21:10,015 --> 00:21:11,295
这五个

356
00:21:12,575 --> 00:21:16,928
相关的类型sata

357
00:21:17,696 --> 00:21:18,208
走狗

358
00:21:20,256 --> 00:21:21,024
我们看看他

359
00:21:21,536 --> 00:21:27,680
在可怕自己要定义把一个容器一定有他自己专属的迭代器那这个迭代

360
00:21:27,936 --> 00:21:31,776
在其定义的这些类型有没有道理的我们现在来看看

361
00:21:33,056 --> 00:21:39,200
他被他自己定义他的分类是什么category是哪一种分类呢是random

362
00:21:43,040 --> 00:21:44,064
4K跳的

363
00:21:45,344 --> 00:21:46,112
这合理吗

364
00:21:48,928 --> 00:21:49,440
合理

365
00:21:49,952 --> 00:21:52,000
虽然他其实是

366
00:21:52,256 --> 00:21:53,280
断掉

367
00:21:54,304 --> 00:21:57,632
但是他对外声称我是连续的

368
00:21:58,144 --> 00:22:00,192
所以他要制造这个假象

369
00:22:00,448 --> 00:22:04,288
这个小象怎么制造的后面这个后面一个门大的题目

370
00:22:04,800 --> 00:22:06,080
完全要靠

371
00:22:06,336 --> 00:22:12,480
迭代器你要让使用者认为加加加加一直加加或者加等于问加等于80

372
00:22:12,736 --> 00:22:16,832
票都是没问题的这样就是一种连续的

373
00:22:18,112 --> 00:22:19,904
这个表现

374
00:22:20,416 --> 00:22:23,744
所以只要大口可以提供

375
00:22:24,000 --> 00:22:25,024
迭代器

376
00:22:25,792 --> 00:22:31,936
能够制造出连续的这种假象那么外界使用者就认为这个事

377
00:22:32,192 --> 00:22:32,960
连续的

378
00:22:35,008 --> 00:22:40,384
所以他这边就告诉大家说我我就是连续的randomaccess

379
00:22:40,896 --> 00:22:41,664
可以跳的

380
00:22:44,224 --> 00:22:44,992
好

381
00:22:46,528 --> 00:22:47,808
我们继续往下看

382
00:22:52,672 --> 00:22:54,208
倒进行到这里了

383
00:22:54,976 --> 00:23:00,096
除了迭代器本身怎么制造那个假象还没讲那个集中在后头

384
00:23:00,608 --> 00:23:04,704
除了那个之外我想大家对于一个分段

385
00:23:05,472 --> 00:23:07,264
然后怎么被控制中心

386
00:23:08,032 --> 00:23:12,384
然后一个迭代器里头需要四个变量边界

387
00:23:13,152 --> 00:23:15,712
要回到控制中心的指针

388
00:23:16,224 --> 00:23:19,296
The current当前的元素的指针

389
00:23:19,808 --> 00:23:20,576
这些事情

390
00:23:21,088 --> 00:23:24,160
我知道都有概念的也知道为什么要那么设计了

391
00:23:26,976 --> 00:23:28,512
我选一个

392
00:23:28,768 --> 00:23:32,096
有趣的函数

393
00:23:32,864 --> 00:23:34,144
聪明的地方

394
00:23:35,680 --> 00:23:37,728
这个函数在insert

395
00:23:42,336 --> 00:23:44,384
音色的意思就是

396
00:23:45,408 --> 00:23:47,456
允许你指定一个位置

397
00:23:47,712 --> 00:23:51,040
在那个位置上面放一个新的元素进去

398
00:23:52,320 --> 00:23:53,600
它有两个参数

399
00:23:54,112 --> 00:23:55,904
另一个参数叫狍子英雄

400
00:23:56,160 --> 00:23:56,672
是什么

401
00:23:56,928 --> 00:23:57,696
一个迭代器

402
00:23:58,464 --> 00:24:01,280
也就是说你调用它的时候可以指定一个位置

403
00:24:02,048 --> 00:24:03,840
这个位置用迭代器指出来

404
00:24:04,096 --> 00:24:08,448
然后你可以放一个新的元素值进去这个家因素

405
00:24:11,264 --> 00:24:16,128
他聪明的地方在于由于他可以往前往后去

406
00:24:16,384 --> 00:24:17,920
去看去推

407
00:24:19,968 --> 00:24:21,760
所以它会早出

408
00:24:22,016 --> 00:24:24,064
你现在要安插的位置点

409
00:24:24,576 --> 00:24:28,160
距离尾端比较近还是距离头端比较近

410
00:24:29,696 --> 00:24:33,024
因为你元素插进去之后是必须推动

411
00:24:34,048 --> 00:24:36,864
Open空腾出空间出来

412
00:24:38,400 --> 00:24:39,936
假设你现在有

413
00:24:40,448 --> 00:24:41,472
10000个元素

414
00:24:42,496 --> 00:24:45,056
你要安插在第5个位置上

415
00:24:46,080 --> 00:24:48,896
当然是把前四个网一端推

416
00:24:49,152 --> 00:24:49,920
比较快

417
00:24:50,688 --> 00:24:51,968
因为后面还有

418
00:24:52,992 --> 00:24:54,272
9900

419
00:24:55,040 --> 00:24:55,552
就是

420
00:24:56,832 --> 00:25:02,976
我爱你算错就是你了解我的意思在这么长的区域里面你差得很前面的地方

421
00:25:03,232 --> 00:25:09,376
当然是往前推才好了既然这个大可以两端为王比较短的那边推出

422
00:25:09,632 --> 00:25:10,144
打开会

423
00:25:11,168 --> 00:25:15,520
因为每一次推都要调用构造函数和析构函数相当发时间

424
00:25:18,080 --> 00:25:20,896
这个地方就表现出他就是会这么做

425
00:25:21,664 --> 00:25:22,944
好我们来看一看

426
00:25:24,736 --> 00:25:25,248
If

427
00:25:25,504 --> 00:25:26,784
一进来就判断了

428
00:25:27,552 --> 00:25:29,856
好的是你指定的位置

429
00:25:30,624 --> 00:25:31,648
这个位置

430
00:25:32,672 --> 00:25:33,952
是7点吗

431
00:25:36,768 --> 00:25:40,608
注意传进来的iterator是适格的这个地方是个

432
00:25:42,144 --> 00:25:48,288
四个里面真正指向元素的是红色的这一根叫current current所以他的

433
00:25:48,544 --> 00:25:49,056
判断

434
00:25:49,312 --> 00:25:50,848
迭代器的current

435
00:25:51,104 --> 00:25:53,920
汉起点的客人是相同的吗

436
00:25:54,432 --> 00:25:55,968
注意这个注解在这里

437
00:25:56,224 --> 00:25:59,040
判断相同的话表示是最前端

438
00:25:59,296 --> 00:26:04,672
最前端的话是不需要推呀最前端交给不去from去做

439
00:26:04,928 --> 00:26:07,232
From这个函数我们就不去管它了

440
00:26:07,744 --> 00:26:09,280
他想必就是在前头

441
00:26:09,536 --> 00:26:10,304
放东西

442
00:26:12,352 --> 00:26:14,400
如果不这样就结束了

443
00:26:15,424 --> 00:26:17,984
如果不能满足这个条件

444
00:26:18,240 --> 00:26:21,824
那么就看看是不是最尾端的人一个

445
00:26:23,616 --> 00:26:28,480
如果是最尾端的那个的话那就交给不具备

446
00:26:28,736 --> 00:26:29,248
去做

447
00:26:30,528 --> 00:26:36,160
你看这么一份空间里面他在判断因此时的头

448
00:26:36,672 --> 00:26:37,440
89

449
00:26:37,952 --> 00:26:41,280
很简单或者因素在最尾巴纳也很简单

450
00:26:41,792 --> 00:26:47,168
这两件事情都检查完毕之后如果都不满足的话

451
00:26:47,680 --> 00:26:48,448
跑到这里来

452
00:26:49,472 --> 00:26:52,800
Insert axillary

453
00:26:53,312 --> 00:26:55,616
这个辅助函数把它放在下一页

454
00:26:59,200 --> 00:27:01,504
Insert exec

455
00:27:02,784 --> 00:27:08,928
这里头做什么事情呢这里的动作注解讲得非常清楚这边有一个简

456
00:27:09,184 --> 00:27:13,280
除以二要做什么事呢他在判断

457
00:27:14,816 --> 00:27:17,120
你安插进去的那个点

458
00:27:17,632 --> 00:27:20,960
前面往前走往后端走的

459
00:27:21,216 --> 00:27:24,288
读书跟王伟巴狗的歌手谁比较长

460
00:27:26,080 --> 00:27:27,360
所以这边有个数12

461
00:27:27,616 --> 00:27:28,896
主要就是终点

462
00:27:29,664 --> 00:27:31,456
发来看看说是不是小鱼

463
00:27:31,712 --> 00:27:32,224
终点

464
00:27:32,992 --> 00:27:34,528
如果小于中点

465
00:27:34,784 --> 00:27:36,832
表示比较靠近头端

466
00:27:38,368 --> 00:27:40,160
好的这里所做的事情呢

467
00:27:40,672 --> 00:27:42,720
这是往后端推动

468
00:27:44,256 --> 00:27:46,816
这里的细节我就不讲了你可以

469
00:27:47,072 --> 00:27:49,888
苹果在这地方看一看这边的住家

470
00:27:54,752 --> 00:27:56,288
那如果

471
00:27:56,544 --> 00:28:01,408
是defenders前面所计算出来的那个位置好

472
00:28:02,176 --> 00:28:06,272
大鱼中段的话就表示他比较靠近尾端

473
00:28:07,296 --> 00:28:10,624
那么执行了就是这一对动作

474
00:28:15,232 --> 00:28:17,792
所以这里的我整理一下

475
00:28:18,304 --> 00:28:23,680
就是它去判断音色这点比较靠近头还是比较靠近一位

476
00:28:24,704 --> 00:28:27,008
他选择比较短的那一端

477
00:28:28,288 --> 00:28:29,568
把那些元素呢

478
00:28:29,824 --> 00:28:34,432
往一边推动头推动或者是王伟达推动推动

479
00:28:34,688 --> 00:28:36,480
空出一个位置出来

480
00:28:36,992 --> 00:28:38,528
这些都做完了之后

481
00:28:39,040 --> 00:28:43,136
If else区做完之后终于空出一个了

482
00:28:43,392 --> 00:28:49,536
于是在这一个卖狗的位置上在安叉点上设定新的词

483
00:28:50,304 --> 00:28:52,608
也就等于放了一个新的元素进去

484
00:28:54,400 --> 00:28:57,472
Spacex竟然有这样的一个币种

485
00:28:58,240 --> 00:29:01,056
我们觉得蛮聪明的一个做法

486
00:29:05,920 --> 00:29:07,456
这个stack
