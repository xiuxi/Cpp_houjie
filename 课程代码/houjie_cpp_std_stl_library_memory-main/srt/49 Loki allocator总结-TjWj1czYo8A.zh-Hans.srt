1
00:00:00,256 --> 00:00:06,400
Hello Kitty有什么呢

2
00:00:06,656 --> 00:00:07,424
优缺点

3
00:00:08,960 --> 00:00:10,240
他曾经有两个bug

4
00:00:11,008 --> 00:00:13,824
我刚提过了特别保留就把你看

5
00:00:14,080 --> 00:00:16,640
以上面动动脑筋新版已修正

6
00:00:18,688 --> 00:00:20,480
他精简强悍

7
00:00:20,992 --> 00:00:22,272
设计很精简

8
00:00:23,040 --> 00:00:24,576
手段很强悍

9
00:00:25,088 --> 00:00:26,368
你可以说很暴力

10
00:00:26,880 --> 00:00:29,440
不知道暴力是关于他丰富的写法

11
00:00:30,208 --> 00:00:33,024
微信

12
00:00:33,792 --> 00:00:37,120
碰到什么条件之后呢那个出去

13
00:00:38,912 --> 00:00:44,544
如果他没有发生失误的话其实也也无所谓

14
00:00:45,568 --> 00:00:48,896
因为那个逻辑不是太难看我们是蛮强调

15
00:00:49,152 --> 00:00:52,736
代码的可读性和可读性也上课还不错

16
00:00:54,784 --> 00:00:55,552
第3个

17
00:00:56,320 --> 00:00:57,856
他使用这种方式

18
00:00:58,880 --> 00:01:00,416
用aristides

19
00:01:00,672 --> 00:01:02,976
Index

20
00:01:04,256 --> 00:01:07,328
这个在下中上那个下

21
00:01:07,584 --> 00:01:08,352
Trunk

22
00:01:08,608 --> 00:01:10,912
那个Class里面我们看到了

23
00:01:11,424 --> 00:01:16,288
这是一种很特殊的实现手法我们等于是

24
00:01:17,056 --> 00:01:20,640
剥削了一点编写代码的小技巧

25
00:01:21,920 --> 00:01:22,688
下一个

26
00:01:22,944 --> 00:01:27,296
它可以用很简单的方式判断一个唱歌是不是全回收

27
00:01:28,320 --> 00:01:32,672
由于能够很简单的判断的权回收那就可以把一块

28
00:01:32,928 --> 00:01:34,208
1块

29
00:01:34,720 --> 00:01:35,232
遗存

30
00:01:35,744 --> 00:01:37,280
在这里就是一个唱歌了

31
00:01:37,792 --> 00:01:39,072
归还给操作系统

32
00:01:39,584 --> 00:01:42,400
很简单的方式是什么方式呢

33
00:01:42,912 --> 00:01:48,800
还有他的像个有记录可用句话还是一个让它变成60

34
00:01:49,312 --> 00:01:55,456
这是全部给出去了当他回不到原来的状态这个状态是有被记录的

35
00:01:55,712 --> 00:01:58,272
当他恢复了他就是全回收

36
00:01:59,296 --> 00:02:04,416
这个概念跟在第3讲的malloc是一样的没有哪个用counter在记录

37
00:02:06,976 --> 00:02:07,488
接下来

38
00:02:08,000 --> 00:02:11,328
还有differently这个字眼

39
00:02:11,584 --> 00:02:14,144
在第3讲的时候出现是malloc

40
00:02:14,912 --> 00:02:19,776
他在他也是分段管理是有一个全回收判断

41
00:02:20,544 --> 00:02:26,432
它有延缓归还中是两个再换一个永远是两个孩还一个

42
00:02:26,944 --> 00:02:27,968
这个家的妇儿

43
00:02:28,736 --> 00:02:31,040
他也有就是刚刚被我

44
00:02:31,296 --> 00:02:33,600
跳过去的我说那里面有个bug啊

45
00:02:33,856 --> 00:02:35,392
这里面的动作

46
00:02:35,648 --> 00:02:37,696
我不带你去看的那一段

47
00:02:43,328 --> 00:02:44,096
最后

48
00:02:45,376 --> 00:02:47,168
这是一个OK的

49
00:02:47,936 --> 00:02:53,056
用来分配大量的小块的不带cookie的

50
00:02:53,312 --> 00:02:53,824
为什么会

51
00:02:54,592 --> 00:02:55,360
非常好

52
00:02:56,896 --> 00:02:57,664
非常好

53
00:02:59,200 --> 00:03:05,344
但他的客户是容器我们一般人不会去用它的你用它的话你就要记录没

54
00:03:05,600 --> 00:03:08,160
1块的大小没有人受得了这种事情

55
00:03:08,928 --> 00:03:11,232
在他的客户显示容器

56
00:03:12,768 --> 00:03:15,840
但是它本身却用到了next

57
00:03:16,608 --> 00:03:18,912
Vector不就是一种容器吗

58
00:03:20,704 --> 00:03:22,240
它使用容器

59
00:03:23,008 --> 00:03:25,568
然后他本身在被容器使用

60
00:03:25,824 --> 00:03:26,848
这是怎么一回事

61
00:03:28,896 --> 00:03:30,944
先有鸡还是先有蛋

62
00:03:32,480 --> 00:03:34,272
没有人能回答这种问题

63
00:03:36,576 --> 00:03:40,416
最适合跑出一个鸡生蛋蛋生鸡的问题

64
00:03:42,208 --> 00:03:44,768
再想下去头脑好像快爆炸了

65
00:03:45,792 --> 00:03:49,376
它使用容器然后它又要被容器使用

66
00:03:52,960 --> 00:03:55,008
如果真的这么做的话

67
00:03:55,264 --> 00:03:57,312
其实这是两回事

68
00:03:59,616 --> 00:04:01,920
这部不相干扰

69
00:04:03,712 --> 00:04:05,760
怎么说呢我到底在说什么

70
00:04:06,272 --> 00:04:07,808
我们回头去看看

71
00:04:09,600 --> 00:04:12,672
它使用vector

72
00:04:17,024 --> 00:04:22,655
它使用NASA的这个动作在当的代码里面已经出现过了不必再讲

73
00:04:22,911 --> 00:04:25,983
我现在用口头叙述我们回到这个画面来

74
00:04:27,519 --> 00:04:28,031
这里

75
00:04:28,799 --> 00:04:34,943
是他本身已经使用了react native背后是什么分配器的

76
00:04:35,199 --> 00:04:35,711
再执行

77
00:04:36,735 --> 00:04:37,759
不是他

78
00:04:39,295 --> 00:04:44,415
好吧那个master找出来好了

79
00:04:50,815 --> 00:04:56,959
算了我放弃我不去找我想我这样的解释你是听得下去的他所使用的

80
00:04:57,215 --> 00:04:57,727
Vector

81
00:04:57,983 --> 00:05:01,055
背后有一个分配器按不是楼梯

82
00:05:01,567 --> 00:05:03,359
C标准库来套

83
00:05:06,175 --> 00:05:08,735
等到这个logo完成了之后

84
00:05:10,015 --> 00:05:12,575
你应用端再一次使用

85
00:05:13,087 --> 00:05:14,111
容器

86
00:05:14,367 --> 00:05:17,183
It is now TV分配器

87
00:05:17,695 --> 00:05:21,791
这时候已经跟标准库的那一个脱离关系了

88
00:05:22,559 --> 00:05:26,911
这是两件事情没有期盼这样的一种

89
00:05:27,167 --> 00:05:27,935
循环

90
00:05:28,447 --> 00:05:29,215
交互

91
00:05:30,751 --> 00:05:33,055
这个纠缠不清的关系没有

92
00:05:35,103 --> 00:05:41,247
当然这也就表示你的代码里面就同时不但存在了不但用到

93
00:05:41,503 --> 00:05:43,551
到了标准库的

94
00:05:44,063 --> 00:05:44,831
容器

95
00:05:45,343 --> 00:05:48,159
一级标准库了分配器

96
00:05:48,415 --> 00:05:51,999
也用到了rokid分配器

97
00:05:53,535 --> 00:05:54,303
这个

98
00:05:54,815 --> 00:05:56,607
值得你好好的

99
00:05:57,119 --> 00:05:58,399
试想一下

100
00:05:58,655 --> 00:06:01,983
他们之间没有诞生机器承担的问题

101
00:06:03,775 --> 00:06:09,919
但是毕竟逻辑上的一般人碰触到这一个我现在提的这个问题就待在哪

102
00:06:11,199 --> 00:06:14,271
因为确实不容易想的很清楚

103
00:06:16,063 --> 00:06:18,623
所以一个更好的做法是

104
00:06:20,159 --> 00:06:22,463
不要在这里头使用的

105
00:06:24,767 --> 00:06:28,095
你可以自己如果你现在觉得这个东西很棒

106
00:06:28,351 --> 00:06:30,143
你想把它改写成

107
00:06:31,167 --> 00:06:32,191
标准格式

108
00:06:32,959 --> 00:06:36,031
来支持你所使用的容器

109
00:06:37,055 --> 00:06:38,847
你可以把这个代码呢

110
00:06:39,103 --> 00:06:44,223
而且函数的接口当然名称都要符合家家标准库的规格

111
00:06:44,479 --> 00:06:46,783
这样这个命名啊

112
00:06:47,295 --> 00:06:48,575
这个命名

113
00:06:49,343 --> 00:06:51,391
Hello OK这个不能大写

114
00:06:51,647 --> 00:06:57,791
这个demo可以这也不能大写要按照规格去重新把它的接口的整理一下

115
00:06:58,559 --> 00:07:02,399
并且最重要的这里头不要再用那个

116
00:07:03,167 --> 00:07:07,519
那就改用一个你你写出来的一个小型的数据

117
00:07:07,775 --> 00:07:10,079
属小型的容器

118
00:07:10,591 --> 00:07:16,735
它具备weka的功能是一个很简单东西自己要实现他并不困难

119
00:07:17,247 --> 00:07:21,087
在我自己做一份出来的放在这里头就可以

120
00:07:21,343 --> 00:07:27,487
完全的去消除了你对于这个刚刚可能提到的鸡生蛋蛋生鸡的这种困

121
00:07:27,743 --> 00:07:31,583
困惑也完全消除你对

122
00:07:31,839 --> 00:07:32,607
标准

123
00:07:33,119 --> 00:07:34,399
酷分配器的

124
00:07:35,167 --> 00:07:35,935
使用

125
00:07:39,775 --> 00:07:42,079
我这边就是我们整个对于

126
00:07:42,335 --> 00:07:44,127
Nokia located

127
00:07:44,383 --> 00:07:45,151
检讨

128
00:07:46,687 --> 00:07:48,735
这就是最后一张投影片

129
00:07:48,991 --> 00:07:50,783
我们在第四章里面

130
00:07:51,807 --> 00:07:52,575
跟大家

131
00:07:53,343 --> 00:07:57,439
介绍了一个我认为很棒的rowkey allocate
