1
00:00:00,256 --> 00:00:06,400
好我们先搞起来呢

2
00:00:06,656 --> 00:00:10,496
Expression new表达式为

3
00:00:10,752 --> 00:00:13,056
现在我来看看adreno

4
00:00:14,080 --> 00:00:16,896
当然也归类为一个表达式expiration

5
00:00:17,920 --> 00:00:24,064
谢楠竟然出现在这个名字显然他是我们是要一次性的去

6
00:00:24,576 --> 00:00:25,344
去

7
00:00:25,600 --> 00:00:26,624
建造

8
00:00:26,880 --> 00:00:27,648
一个

9
00:00:27,904 --> 00:00:29,184
一整个瑞

10
00:00:29,440 --> 00:00:30,720
对象

11
00:00:31,232 --> 00:00:32,512
用法是这样子

12
00:00:35,072 --> 00:00:35,584
6

13
00:00:35,840 --> 00:00:40,704
小括号中括号要放在这个位置我想大家都已经用过了

14
00:00:42,752 --> 00:00:43,776
我会有问题

15
00:00:44,032 --> 00:00:46,592
那么初学者呢比较容易

16
00:00:47,104 --> 00:00:52,480
发生了一个失误是这边使用win8这个价格瑞宁

17
00:00:54,272 --> 00:00:56,320
这边的却忘了加中括号

18
00:00:57,856 --> 00:01:03,744
在这个深入讨论里面我们就可以知道你加我没加中括号会带来什么的影响

19
00:01:04,256 --> 00:01:06,816
这个耳温度

20
00:01:07,072 --> 00:01:08,352
创建出来的

21
00:01:08,608 --> 00:01:14,752
当然如果我们所想象的就是一个array里头那有啥我这边是干嘛所以三个不

22
00:01:15,008 --> 00:01:19,616
数这个不是不是标准库的那个是我自己写的最大写的c

23
00:01:19,872 --> 00:01:24,736
怎么有用的尖括号它不适合模仿三个

24
00:01:24,992 --> 00:01:31,136
那么如果没有对应该搭配要有中国好如果没有这么写

25
00:01:31,392 --> 00:01:37,536
写的话会产生什么影响这边有的注解如果这么写的话会调用叶子繁殖的

26
00:01:37,792 --> 00:01:43,936
而如果你没有写的话那就是编译器不知道你背后的这个指针所指的是

27
00:01:44,192 --> 00:01:50,336
是一个为他不知道所以会好像我们前面所讨论的就是一般正常的给力的

28
00:01:50,592 --> 00:01:56,736
以为这个只是一个Object对象所以他只会给任启一次析构函数

29
00:01:56,992 --> 00:02:03,136
这就是这两者的差别所以

30
00:02:03,392 --> 00:02:09,536
我们可能在书籍或者说很多的自信息里面告诉我们真的会发生

31
00:02:09,792 --> 00:02:15,936
内存泄漏我们非常怕内存泄露这个事情到底是信用哪一块呢

32
00:02:16,192 --> 00:02:22,336
这个命令这个动作其实得到的最快上面有带这个小

33
00:02:22,592 --> 00:02:28,736
小东西怎么控制cookie是一个这个字也就是小饼干

34
00:02:28,992 --> 00:02:35,136
帮你分配这个的时候那这个系统给你一块小饼干

35
00:02:35,392 --> 00:02:41,536
他里头的记录是没有写something about about

36
00:02:41,792 --> 00:02:47,936
就是一些不计一些琐碎的东西其实最重要的就是

37
00:02:48,192 --> 00:02:54,336
记录着快乐长度因为这一块从最底层

38
00:02:54,592 --> 00:03:00,736
产品到最底层是malloc给我们的所以他对应的是free去回收的

39
00:03:00,992 --> 00:03:07,136
Free只拿到一根指针他怎么知道这支撑这个指针一次一次的

40
00:03:07,392 --> 00:03:13,536
下去后回到主义去所以会收到这个自称为这个函数他怎么知道

41
00:03:13,792 --> 00:03:19,936
这个这1块是多大了他必须知道这是没有人能告诉他所以

42
00:03:20,192 --> 00:03:26,336
最后mallory的设计就说好了那我分配给你的时候

43
00:03:26,592 --> 00:03:32,736
有没有分配给你的时候带着一个小东西好了里头记录这个程度这个设计是在所有

44
00:03:32,992 --> 00:03:39,136
有的平台上面malloc和free这两个函数在所有的平台上所有的cplusplus

45
00:03:39,392 --> 00:03:45,536
编译器平台都是这么设计的这个叫控制非常重要的一个东西我们后面会有在吗

46
00:03:45,792 --> 00:03:51,936
BCD下它的结构图给大家看所以

47
00:03:52,192 --> 00:03:58,336
如果我们这边是用rnn得到了是这一块的地铁旺季家中

48
00:03:58,592 --> 00:04:04,736
中括号的话最后的机会长度并没有随之改

49
00:04:04,992 --> 00:04:11,136
所以最终这一会要还回去被回收给操作系统的时候

50
00:04:11,392 --> 00:04:17,536
是不会有内存泄漏内存泄漏是发生在这个药

51
00:04:17,791 --> 00:04:23,935
要用三次或者是一次这关系到你们写中国好事发生的这个

52
00:04:24,191 --> 00:04:30,335
我们来看看这种情况下

53
00:04:30,591 --> 00:04:36,735
现在63个实验室标准库的水位计的时候忘记加中括号

54
00:04:36,991 --> 00:04:43,135
那么这一块会完成回收

55
00:04:43,391 --> 00:04:49,535
但是在回收之前要分别三次调用析构函数这时候呢由于这个

56
00:04:49,791 --> 00:04:55,935
令他的一般设计上都是头戴的一根针指针

57
00:04:56,191 --> 00:05:02,335
有再另外再分配一块了释放真正的是不算所以调用3次

58
00:05:02,591 --> 00:05:06,175
这个就会很干净的清掉如果指标一次呢

59
00:05:06,431 --> 00:05:12,575
看电视这一个还是这一个等一下后面好有分析不是这个就是这一个

60
00:05:12,831 --> 00:05:18,975
只要看不同平台上的实现总之三筷子是放在一块

61
00:05:19,231 --> 00:05:25,375
所以内存泄漏时气流的这个地方回到这个例子来如果我们

62
00:05:25,631 --> 00:05:31,775
放的是复数复数只有时不屈服而已他里面没有什么只针对他的析构函数其实也是

63
00:05:32,031 --> 00:05:33,055
也是没有用

64
00:05:33,311 --> 00:05:39,455
Trivial不重要最强单词

65
00:05:39,711 --> 00:05:45,855
此次其实也无所谓当然我们写代码的时候或者我们好的一个变成观念

66
00:05:46,111 --> 00:05:52,255
编程的技巧我们不能够去想啊如果这样的话那我要这样如果那样的话我要那样

67
00:05:52,511 --> 00:05:58,655
我们应该统一要养成一个好的习惯你用arima你就要对应

68
00:05:58,911 --> 00:06:01,471
使用arraylist

69
00:06:03,775 --> 00:06:09,407
这个是我们对Oracle jdbc试下看

70
00:06:09,919 --> 00:06:13,503
现在我就来试试看

71
00:06:13,759 --> 00:06:15,039
我自己

72
00:06:15,295 --> 00:06:18,879
帮我做了一些小的实验这是

73
00:06:19,391 --> 00:06:20,927
代码的部分

74
00:06:21,183 --> 00:06:25,535
我来看看我是走进行了些什么事情这次执行结果

75
00:06:25,791 --> 00:06:31,935
这个是我使用的classpath我先来分析看看这个有什么东西有一个

76
00:06:32,703 --> 00:06:34,751
默认构造函数

77
00:06:35,775 --> 00:06:37,055
为什么我这里呀

78
00:06:38,079 --> 00:06:41,151
泰铢一个默认构造函数的因为

79
00:06:41,407 --> 00:06:42,175
你在

80
00:06:42,943 --> 00:06:49,087
另一个array的时候一个数组的时候你没有办法一一的给定出

81
00:06:49,343 --> 00:06:49,855
兔子

82
00:06:50,879 --> 00:06:52,159
我们回到上个月看看

83
00:06:52,671 --> 00:06:53,695
你这边又

84
00:06:53,951 --> 00:06:56,255
没有机会再让你射出时

85
00:06:57,535 --> 00:07:02,399
说一定这么是三次的这里是33次的

86
00:07:02,655 --> 00:07:04,703
默认构造函数

87
00:07:06,239 --> 00:07:12,383
本来这里我这个App一定要写一个这个默认构造函数以方便等效果测试

88
00:07:13,151 --> 00:07:14,431
输出

89
00:07:15,967 --> 00:07:17,759
说出是这个list

90
00:07:18,015 --> 00:07:20,319
关键词什么就是现在这一块

91
00:07:20,575 --> 00:07:21,343
是

92
00:07:21,599 --> 00:07:23,391
占用哪里的内存

93
00:07:23,903 --> 00:07:29,023
好另外我还有另外一个构造函数这个我们先不讲的话有析构函数

94
00:07:30,047 --> 00:07:31,327
我来看看

95
00:07:32,095 --> 00:07:35,679
我在自己在另一个类的时候

96
00:07:35,935 --> 00:07:39,263
他的行为模式是不是我刚刚所说

97
00:07:39,519 --> 00:07:40,543
怎么有趣了

98
00:07:41,311 --> 00:07:43,871
必须有默认构造函数

99
00:07:44,639 --> 00:07:47,967
否则的话下面的动作这一个动作就会出现error

100
00:07:50,015 --> 00:07:51,807
而这个做出来之后

101
00:07:52,319 --> 00:07:53,599
我们可以想象

102
00:07:54,111 --> 00:07:54,879
飞长途

103
00:07:55,647 --> 00:07:59,231
这三个的鱿鱼都调用默认构造函数

104
00:07:59,487 --> 00:08:03,839
默认构造函数把这个IP都是为零所以这三个应该是0

105
00:08:06,143 --> 00:08:08,703
而他们每一次被这样起来

106
00:08:08,959 --> 00:08:10,239
Pointer

107
00:08:10,751 --> 00:08:14,079
This就是指向这个对象的起点吗

108
00:08:14,335 --> 00:08:16,127
应该会移动这句话

109
00:08:17,663 --> 00:08:23,551
不管是这样构造函数或者后头条用习惯还是我的这些指针应该会自动会跑

110
00:08:24,319 --> 00:08:26,623
摩托罗拉的出来看是不是这样

111
00:08:27,647 --> 00:08:31,231
你却一开始三个IP都是0

112
00:08:31,999 --> 00:08:33,279
他们的地址呢

113
00:08:33,535 --> 00:08:35,327
当被调用的时候

114
00:08:35,583 --> 00:08:37,631
Xpoint有被打印出去

115
00:08:38,911 --> 00:08:39,423
椅子

116
00:08:41,215 --> 00:08:42,751
分别间隔多少

117
00:08:43,263 --> 00:08:44,799
从80到90

118
00:08:45,055 --> 00:08:48,639
90到9次每一个都是间隔14个自己

119
00:08:48,895 --> 00:08:51,711
为什么是四个自己因为这一个A

120
00:08:52,223 --> 00:08:53,759
他就是一个整数

121
00:08:54,015 --> 00:08:55,807
就是四个自己

122
00:08:56,575 --> 00:09:00,671
根据这一个输出划出这个图出来

123
00:09:00,927 --> 00:09:02,719
Hello我们又把这个地址

124
00:09:03,487 --> 00:09:04,767
超过来没有

125
00:09:06,815 --> 00:09:09,119
好接下来

126
00:09:10,399 --> 00:09:13,727
根据我想根据我们对这种额外的第1季

127
00:09:15,007 --> 00:09:16,799
我们去一栋这个指针

128
00:09:18,335 --> 00:09:20,127
811的设定

129
00:09:20,639 --> 00:09:21,407
充值

130
00:09:23,199 --> 00:09:25,759
设初只在调用构造函数

131
00:09:26,015 --> 00:09:28,063
叫我又设计了一个这样的构造函数

132
00:09:29,343 --> 00:09:31,135
好我的做法是这样子

133
00:09:32,671 --> 00:09:34,975
这个逼我也不就只上7点了

134
00:09:35,743 --> 00:09:38,559
我让另外一根指针跟他指的一样

135
00:09:39,327 --> 00:09:40,863
然后把这个指针

136
00:09:41,375 --> 00:09:41,887
佳佳

137
00:09:43,679 --> 00:09:45,983
加多少次那家三次

138
00:09:46,751 --> 00:09:51,103
因为现在这个瑞的13个是我这边就加三次

139
00:09:52,383 --> 00:09:54,431
每一次都把这个指针加加

140
00:09:54,687 --> 00:09:57,759
佳佳说这个了

141
00:09:58,015 --> 00:09:59,039
这个服务

142
00:09:59,807 --> 00:10:02,111
等于这个指针就

143
00:10:02,623 --> 00:10:03,647
夹子夹下来

144
00:10:05,951 --> 00:10:11,071
问一次家每次移动我都去射出时

145
00:10:12,095 --> 00:10:17,983
我们前面已经讨论过了其实我们没有办法直接调用构造

146
00:10:19,263 --> 00:10:25,407
但是我们有一个绕一个弯的做法就是调用freshman units

147
00:10:25,919 --> 00:10:27,199
来自数据

148
00:10:27,967 --> 00:10:32,319
Viessmann News等一下就会出现那个主题我们前面已经

149
00:10:32,575 --> 00:10:33,855
大咧讲过了

150
00:10:34,623 --> 00:10:36,415
它的形式是这样

151
00:10:36,671 --> 00:10:37,183
宁

152
00:10:37,439 --> 00:10:42,047
加一个中括号小括号里投放的就是指

153
00:10:42,303 --> 00:10:43,071
指针

154
00:10:43,839 --> 00:10:47,935
意思就是你就打算在那个位置上这个位置上

155
00:10:48,959 --> 00:10:50,495
来建立一个东西

156
00:10:51,775 --> 00:10:54,335
这一个位置的意思是

157
00:10:54,591 --> 00:10:56,639
说我已经有一块内存

158
00:10:58,175 --> 00:11:00,991
的确我们刚刚已经分配出一些内存出来

159
00:11:02,271 --> 00:11:03,039
所以

160
00:11:03,295 --> 00:11:04,831
我在这里呢也

161
00:11:05,599 --> 00:11:08,415
示范一下prisma怒的用法

162
00:11:09,439 --> 00:11:10,975
这个电机的就

163
00:11:11,487 --> 00:11:13,791
不断的移动这里不断的移动

164
00:11:14,047 --> 00:11:17,375
每次移动调用为什么牛

165
00:11:17,631 --> 00:11:22,239
把它翻译成定点的六在这个定点上面要创建对象

166
00:11:23,519 --> 00:11:25,823
好这样就可以调用气

167
00:11:26,335 --> 00:11:27,871
这一个多少

168
00:11:28,383 --> 00:11:29,919
一直有多少呢

169
00:11:30,943 --> 00:11:32,223
按照爱来给

170
00:11:33,759 --> 00:11:34,271
于是

171
00:11:34,783 --> 00:11:37,599
这一个循环结束之后

172
00:11:38,111 --> 00:11:39,647
应该得到的是

173
00:11:39,903 --> 00:11:40,671
这三个

174
00:11:41,951 --> 00:11:42,975
一直都一样啊

175
00:11:43,487 --> 00:11:43,999
这里

176
00:11:44,255 --> 00:11:46,303
8c 9094

177
00:11:46,559 --> 00:11:48,607
US 19094

178
00:11:49,119 --> 00:11:50,655
儿子现在变成012

179
00:11:52,447 --> 00:11:54,751
这是这这一个动作做出来的

180
00:11:58,079 --> 00:11:59,871
做完事后

181
00:12:00,639 --> 00:12:06,015
我们非常规矩的既然这里是用而为命这里就有3D的

182
00:12:08,063 --> 00:12:11,903
看看是不是确实的调用去三次析构函数

183
00:12:12,671 --> 00:12:13,183
确实

184
00:12:13,951 --> 00:12:14,975
搜索结果在这里

185
00:12:16,255 --> 00:12:21,631
从这一个地方我们观察到我这边也有注解说明了它的四驱是立法的

186
00:12:23,167 --> 00:12:27,519
钢构件建构构件的时候是从上往下

187
00:12:28,543 --> 00:12:31,359
要虚构的时候是由下往上

188
00:12:31,871 --> 00:12:38,015
77构是由上往下或由下往上修辞去无所谓只要全部都有干劲

189
00:12:38,271 --> 00:12:39,295
安静的西勾掉就好

190
00:13:03,359 --> 00:13:04,383
打开康事业

191
00:13:04,639 --> 00:13:07,455
Iranian generated第1个

192
00:13:08,223 --> 00:13:10,015
听说如果不

193
00:13:10,271 --> 00:13:11,807
对应的来写的话会

194
00:13:12,575 --> 00:13:17,951
造成内存泄漏泄露是哪一会那不是儿为本身

195
00:13:18,975 --> 00:13:23,071
是像这一种情况还会发生内存泄漏

196
00:13:25,631 --> 00:13:30,751
第二件事情由于由刚刚的这个测试程序我们知道

197
00:13:32,031 --> 00:13:35,103
Allen888 Thomas

198
00:13:36,639 --> 00:13:39,967
引起的便当already中括号这种用法的时候

199
00:13:40,735 --> 00:13:45,087
在建构是由上往下机构是由下往上

200
00:13:46,879 --> 00:13:48,671
并且在这个例子里面

201
00:13:48,927 --> 00:13:52,767
我也是犯了placement是为定点的

202
00:13:53,279 --> 00:13:54,303
用法

203
00:13:59,167 --> 00:14:00,191
继续往下

204
00:14:01,215 --> 00:14:02,495
刚刚谈到了

205
00:14:02,751 --> 00:14:04,287
Cookie这个东西

206
00:14:04,799 --> 00:14:06,847
其实是个很大的中点

207
00:14:07,615 --> 00:14:10,687
因为后台我们在做内存管理的时候

208
00:14:11,967 --> 00:14:13,503
我们也很大的诉求是

209
00:14:13,759 --> 00:14:15,039
不要这个故事

210
00:14:17,343 --> 00:14:17,855
所以

211
00:14:18,111 --> 00:14:22,463
Cookie的存在以及它到底多大这个是

212
00:14:22,975 --> 00:14:24,511
我现在需要理解的

213
00:14:27,583 --> 00:14:31,423
这一张图是在vc6里下

214
00:14:32,191 --> 00:14:34,239
观察malloc

215
00:14:34,495 --> 00:14:37,055
给我们的内存它的布局

216
00:14:38,079 --> 00:14:39,359
这个图很宝贵

217
00:14:39,615 --> 00:14:40,639
是

218
00:14:40,895 --> 00:14:42,431
看了很

219
00:14:42,687 --> 00:14:45,247
细锁的代码怎么怎么出来的

220
00:14:46,271 --> 00:14:50,367
阿兰也验证过它确实你没落可得到了是这样的内容

221
00:14:51,647 --> 00:14:53,439
这里讲vc6

222
00:14:54,207 --> 00:14:56,511
那么他更新的版本是不是这样的

223
00:14:57,023 --> 00:14:58,815
我没有办法一一的去

224
00:14:59,071 --> 00:15:01,375
追踪每一个版本

225
00:15:01,631 --> 00:15:05,471
但是这是很核心的部分我认为不会改动

226
00:15:06,751 --> 00:15:09,823
在其他的平台上比如在科目的下面

227
00:15:10,591 --> 00:15:12,127
再不练习一下面

228
00:15:12,639 --> 00:15:17,759
他的布局也许会有点变化但是原理都是不变的

229
00:15:18,527 --> 00:15:21,087
至少一定会带着古迹

230
00:15:21,343 --> 00:15:22,879
下来就是古迹

231
00:15:23,135 --> 00:15:23,903
我们现在只是

232
00:15:24,159 --> 00:15:25,695
浅尝即止

233
00:15:26,463 --> 00:15:27,487
你们后头

234
00:15:27,743 --> 00:15:29,023
在第3讲

235
00:15:30,559 --> 00:15:36,447
我有一个主题专门在讲maillog那边就会把这个这个地方讲得非常清楚

236
00:15:37,983 --> 00:15:39,007
好

237
00:15:40,799 --> 00:15:43,359
我们是从adreno隐身的话题

238
00:15:43,615 --> 00:15:44,639
所以看看这一行

239
00:15:46,687 --> 00:15:50,271
我做这个动作的时候我需要十个整数

240
00:15:51,295 --> 00:15:53,343
每一个总数是四个字节吗

241
00:15:53,855 --> 00:15:56,159
得到的结果是这块

242
00:15:57,183 --> 00:15:58,719
你得到的指针

243
00:15:59,231 --> 00:16:00,255
只是这里

244
00:16:01,791 --> 00:16:05,375
那是在你不知道的情况是下去是没有给你的

245
00:16:05,887 --> 00:16:07,423
是这么一大块

246
00:16:07,935 --> 00:16:09,215
最会全部给你了

247
00:16:09,471 --> 00:16:10,495
只是你不知道而已

248
00:16:12,031 --> 00:16:16,127
这个往上往下有一些现在讲的这个颜色的

249
00:16:17,663 --> 00:16:19,199
浅黄色的这一个

250
00:16:19,967 --> 00:16:22,527
这个在debug模式下才会出现

251
00:16:23,807 --> 00:16:29,951
好细节我们都到后台第3讲没了可能是不再去提一下中只会有这块东西大小

252
00:16:30,207 --> 00:16:30,719
小呢

253
00:16:30,975 --> 00:16:31,999
非常确定

254
00:16:32,255 --> 00:16:34,559
32个自己还是个自己

255
00:16:36,351 --> 00:16:38,143
在网上跟最下

256
00:16:38,399 --> 00:16:39,935
有两个Gucci

257
00:16:40,191 --> 00:16:43,263
我习惯把它叫作上固体跟夏季

258
00:16:44,031 --> 00:16:47,103
他负责记录的是整块的大小

259
00:16:48,639 --> 00:16:49,407
而这个

260
00:16:50,687 --> 00:16:54,015
加上去之后这些都是固定的药

261
00:16:54,271 --> 00:16:57,087
此外不耽误berhad外开销

262
00:16:57,855 --> 00:17:03,999
加完之后还必须调整到16的边界这是在vc6的平台下面还有一

263
00:17:04,255 --> 00:17:04,767
有一个

264
00:17:05,023 --> 00:17:08,607
设定为什么要使用的边界呢也是到我们

265
00:17:08,863 --> 00:17:11,423
深入怎么样

266
00:17:12,447 --> 00:17:16,799
所以你要知道你在B C比下你的每一个或者的区块

267
00:17:17,823 --> 00:17:21,663
有一些加上你看不见全部加起来是16的倍数

268
00:17:22,687 --> 00:17:25,247
在这个例子里头加上去之一

269
00:17:25,503 --> 00:17:27,551
行家必须把钱夹

270
00:17:28,063 --> 00:17:31,647
我们签了12个byte没到客厅的车到自己

271
00:17:31,903 --> 00:17:33,183
这个照片

272
00:17:33,439 --> 00:17:34,463
全谷物

273
00:17:34,975 --> 00:17:36,511
家全部加起来

274
00:17:37,023 --> 00:17:40,095
这是60 H 16进位有事

275
00:17:40,351 --> 00:17:41,631
这个怎么算出来

276
00:17:42,143 --> 00:17:43,935
要不落后头就说

277
00:17:44,959 --> 00:17:46,495
这个就是cookie的作用

278
00:17:47,007 --> 00:17:48,287
60h

279
00:17:49,055 --> 00:17:52,127
已经给去了所以最后一个秘制的药

280
00:17:52,383 --> 00:17:55,711
家用来当做一个案和offer的状态

281
00:17:56,223 --> 00:18:00,831
6177时记住的这个大小是60

282
00:18:02,111 --> 00:18:04,927
上下铺给的内容是完全一样的

283
00:18:07,231 --> 00:18:07,743
好

284
00:18:08,255 --> 00:18:10,815
这个是我们实际在内存获得的结果

285
00:18:12,863 --> 00:18:13,887
这个时候

286
00:18:15,423 --> 00:18:18,239
那家伙不加中括号

287
00:18:19,519 --> 00:18:21,055
其实在这个例子

288
00:18:21,311 --> 00:18:23,615
整数这种粒子是没有影响

289
00:18:25,407 --> 00:18:30,271
因为这个比例因为其实这里面10个整数他根本就没有所谓的析构函数

290
00:18:31,039 --> 00:18:32,319
所以你到底是

291
00:18:32,575 --> 00:18:37,951
对他来讲只调用一次还是给我10次的聚合函数一点影响都没有

292
00:18:41,535 --> 00:18:43,071
所以对于整数

293
00:18:43,839 --> 00:18:46,143
是无所谓的加不加无所谓的

294
00:18:47,679 --> 00:18:50,239
这就好像前面我们的例子对于负数

295
00:18:50,495 --> 00:18:52,031
再看一下前面的例子

296
00:18:52,543 --> 00:18:56,383
我在于故事我当时说这一块能不能全部回收

297
00:18:56,895 --> 00:18:58,687
可以不会有内存泄漏

298
00:18:59,455 --> 00:19:02,527
因为这个负数的析构函数没有意义

299
00:19:04,063 --> 00:19:05,599
这是一样的意思

300
00:19:09,439 --> 00:19:13,791
但是如果你放的是update

301
00:19:14,815 --> 00:19:20,447
而且这个Object这个对象他的析构函数是有意义是重要的

302
00:19:21,983 --> 00:19:22,495
那么

303
00:19:23,775 --> 00:19:26,079
并期待对待你

304
00:19:26,335 --> 00:19:29,151
创建一个类的时候就不一样了

305
00:19:29,919 --> 00:19:31,455
我现在放三个demo

306
00:19:31,711 --> 00:19:33,503
我的每一个demo是

307
00:19:34,015 --> 00:19:36,063
出况这个东西三个整数

308
00:19:37,087 --> 00:19:39,135
我没有把背后的原因

309
00:19:39,391 --> 00:19:42,463
代码给你看非常简单的一个

310
00:19:42,719 --> 00:19:43,487
Class

311
00:19:45,279 --> 00:19:48,351
你要求三这个三就被写到这里来了

312
00:19:49,631 --> 00:19:50,143
所以

313
00:19:51,935 --> 00:19:53,983
这个词语这个函数

314
00:19:54,239 --> 00:19:57,567
帮你姐姐的时候最终会调用到服务

315
00:19:57,823 --> 00:19:59,359
Free这个函数呢

316
00:19:59,615 --> 00:20:05,759
他才能够网上看到三他才知道原来要调用3次

317
00:20:10,367 --> 00:20:13,183
以下特别放那个三

318
00:20:13,695 --> 00:20:16,255
在坟墓地底下的也会

319
00:20:18,047 --> 00:20:20,095
我认识你我就没有去测试了

320
00:20:20,351 --> 00:20:22,399
这些都是共同的原理

321
00:20:25,215 --> 00:20:27,775
所以如果你这边

322
00:20:30,335 --> 00:20:34,431
放的是一个array new这里没有redis的话

323
00:20:36,223 --> 00:20:39,039
在debug模式下调试模式下

324
00:20:39,295 --> 00:20:42,367
VC就会给出这一个画面出来

325
00:20:44,415 --> 00:20:45,695
因为它侦测到

326
00:20:47,231 --> 00:20:53,375
好吧你不要中括号的话那他把这个屁当成一个一般的指针

327
00:20:53,631 --> 00:20:55,423
它指向一块

328
00:20:56,703 --> 00:20:57,471
遗像

329
00:20:58,495 --> 00:21:03,103
于是他按照射会对象的方式想要去解析这一个

330
00:21:03,871 --> 00:21:04,383
布局

331
00:21:05,151 --> 00:21:05,663
但是

332
00:21:07,711 --> 00:21:13,855
发现不是他发现他就按照他的方式去解释但是这这这里多出了一个三整个布局都乱

333
00:21:14,111 --> 00:21:14,623
关掉了

334
00:21:15,903 --> 00:21:17,440
还会出现这个画面

335
00:21:22,048 --> 00:21:24,352
找不到这个地方去理解到

336
00:21:24,608 --> 00:21:28,960
原来我们去使用aranyaprathet的时候

337
00:21:30,240 --> 00:21:34,080
每个内存块的布局是不一样的raid

338
00:21:34,336 --> 00:21:37,408
各处有被写到内存块的头去了

339
00:21:40,224 --> 00:21:46,368
这一张投影片还有其他这个小细节比如说这个61h 74 60hz

340
00:21:46,624 --> 00:21:47,904
算了

341
00:21:48,928 --> 00:21:53,536
好我来解释一下好了这70大后头那都会讲得很清楚

342
00:21:54,048 --> 00:21:55,840
上这个三

343
00:21:56,096 --> 00:21:59,680
这个demo现在是三个整数所以是12个字节

344
00:22:00,192 --> 00:22:06,336
12个字节出现在哪里了12个自己还曾13就是36这个30

345
00:22:07,616 --> 00:22:09,152
要的是36

346
00:22:10,432 --> 00:22:12,480
现在又加上了这一个整数

347
00:22:12,736 --> 00:22:14,784
也是四个字节是一家四

348
00:22:17,344 --> 00:22:18,368
好一些

349
00:22:18,624 --> 00:22:21,952
那么上下这个浅黄色的那是36

350
00:22:22,720 --> 00:22:25,024
332下面是436

351
00:22:25,536 --> 00:22:27,072
这个八加起来

352
00:22:27,840 --> 00:22:30,656
再加上上下有两个cookie

353
00:22:30,912 --> 00:22:31,936
472

354
00:22:33,216 --> 00:22:34,752
加起来是84

355
00:22:36,032 --> 00:22:40,384
24要调到16的边界就是最靠近就是96了

356
00:22:40,896 --> 00:22:42,688
所以要加上12个Pad

357
00:22:43,200 --> 00:22:44,480
说一个自己的Pad

358
00:22:45,248 --> 00:22:49,088
从84条到96相差12这个

359
00:22:49,856 --> 00:22:51,136
这个是会变动的

360
00:22:51,904 --> 00:22:53,440
调到16的倍数

361
00:22:54,720 --> 00:22:57,280
这就是个96就是六年

362
00:23:02,144 --> 00:23:04,192
好这部分后面会更清楚

363
00:23:05,472 --> 00:23:06,496
继续往下

364
00:23:07,776 --> 00:23:08,288
飞

365
00:23:09,056 --> 00:23:12,384
这样我们就彻底理解了adreno的动作

366
00:23:12,896 --> 00:23:14,944
接下来我们要看的就是你

367
00:23:15,200 --> 00:23:21,344
我们的目标就是把cplusplus的这些基本构建有个内存的这些工具

368
00:23:21,600 --> 00:23:22,368
不能弄清楚

369
00:23:22,624 --> 00:23:24,160
然后我们

370
00:23:24,672 --> 00:23:25,696
一个一个来

371
00:23:25,952 --> 00:23:26,720
重载它

372
00:23:28,000 --> 00:23:31,328
接下来我们要谈的是另外一个脚被什么6
