1
00:00:04,864 --> 00:00:06,400
终于我们进入了

2
00:00:07,168 --> 00:00:07,680
一个

3
00:00:07,936 --> 00:00:10,496
大部头的设计

4
00:00:11,008 --> 00:00:11,776
Hello Kitty

5
00:00:14,592 --> 00:00:15,104
好

6
00:00:17,408 --> 00:00:18,176
这个

7
00:00:18,688 --> 00:00:20,480
源代码的头文件在这边

8
00:00:21,760 --> 00:00:27,904
我们介绍了1234567另外还有89所有这些都在一定选这个子目录里头

9
00:00:28,416 --> 00:00:30,720
B&h

10
00:00:32,256 --> 00:00:33,280
他的Class名称

11
00:00:33,536 --> 00:00:34,048
在这里

12
00:00:35,840 --> 00:00:37,376
这里继承了一个东西

13
00:00:37,888 --> 00:00:43,520
看起来又不像是跟这个跟这个分配器我们前面看到如果有一些父类子类继承了

14
00:00:44,800 --> 00:00:48,384
富勒斯也是分配器好像是分

15
00:00:48,640 --> 00:00:50,688
分摊分摊

16
00:01:26,016 --> 00:01:27,040
这里面呢

17
00:01:27,296 --> 00:01:27,808
这里面

18
00:01:28,064 --> 00:01:32,160
真正最重要的动作为金牌群全出来的就是这一个

19
00:01:33,184 --> 00:01:39,328
Allocate the single single Object and allocate single Object

20
00:01:39,584 --> 00:01:42,144
Single Object要是test

21
00:01:42,400 --> 00:01:42,912
一个

22
00:01:43,424 --> 00:01:44,192
这边

23
00:01:44,448 --> 00:01:47,008
这个里头提供一次供应一个

24
00:01:48,544 --> 00:01:51,104
如果要的是一个以上你看这个

25
00:01:51,360 --> 00:01:52,640
这个判断

26
00:01:53,152 --> 00:01:54,432
N等于

27
00:01:55,968 --> 00:01:57,504
15那才会进来

28
00:01:58,016 --> 00:01:59,808
不是一个的话x

29
00:02:00,832 --> 00:02:02,112
让这个去做

30
00:02:02,368 --> 00:02:03,904
这个比不是没了可能

31
00:02:04,416 --> 00:02:05,952
下面这个判断也是一样

32
00:02:06,208 --> 00:02:09,280
所以看得出来他只为那种

33
00:02:09,792 --> 00:02:12,864
客户要一个元素的那种客户来服务

34
00:02:13,120 --> 00:02:14,912
一个以上

35
00:02:15,680 --> 00:02:17,728
要用红色的这个去做

36
00:02:19,264 --> 00:02:20,544
这件事情

37
00:02:20,800 --> 00:02:22,080
为什么呢

38
00:02:23,360 --> 00:02:25,152
其实这个是非常合情合理

39
00:02:26,176 --> 00:02:31,808
我们所认识的我们所介绍的时候的分配器都是为容器的服务

40
00:02:32,064 --> 00:02:37,184
荣庆有那个一次要那个要一个以上的元素这种容器吗

41
00:02:39,744 --> 00:02:40,256
没有

42
00:02:40,512 --> 00:02:41,536
其实没有

43
00:02:46,656 --> 00:02:48,704
对你很想想说的容器

44
00:02:49,472 --> 00:02:51,264
一次都是要一个人

45
00:02:52,288 --> 00:02:54,080
睡觉的设计是合理的

46
00:02:56,384 --> 00:02:59,712
甚至于我都很难想象什么情况之下会

47
00:02:59,968 --> 00:03:00,736
我是一个

48
00:03:03,296 --> 00:03:07,136
那什么情况就是只能一直接使用这个分配器

49
00:03:09,184 --> 00:03:15,328
那个只是就像我我扮演的角色我因为要带领大家所以我要做一个测试卷

50
00:03:15,584 --> 00:03:16,352
我直接用它

51
00:03:16,608 --> 00:03:17,376
那才有可能

52
00:03:20,192 --> 00:03:23,008
否则的话是不建议直接使用分配器

53
00:03:23,264 --> 00:03:25,568
我们应该使用的是勇气

54
00:03:27,616 --> 00:03:28,384
好好笑看

55
00:03:29,664 --> 00:03:33,248
现在我来介绍利用图形图形势最容易懂了

56
00:03:33,760 --> 00:03:34,784
方式来

57
00:03:35,552 --> 00:03:37,088
介绍他里面的概念

58
00:03:37,856 --> 00:03:39,392
我们这一夜谈到了

59
00:03:39,648 --> 00:03:40,416
Flex

60
00:03:41,184 --> 00:03:42,464
Superblock

61
00:03:42,976 --> 00:03:48,352
Bitmap mininet这都是在这一个分配器里面出现的东西

62
00:03:49,888 --> 00:03:51,936
Plus就是客户要的

63
00:03:52,960 --> 00:03:56,032
如果他的客人是容器容器要的一个元素

64
00:03:56,800 --> 00:03:58,080
就是这个啦

65
00:03:58,848 --> 00:03:59,872
也就是这里的

66
00:04:00,640 --> 00:04:01,152
葛

67
00:04:01,664 --> 00:04:02,432
一格

68
00:04:04,224 --> 00:04:07,808
如果它的容器它的客户是链表的话

69
00:04:08,064 --> 00:04:10,112
容标准库里面那个链表list

70
00:04:10,880 --> 00:04:11,904
那你

71
00:04:12,416 --> 00:04:13,184
指定的

72
00:04:13,696 --> 00:04:19,839
数据还要加上下两个呀还要加前后两个指针加起来在这个节点那个节点

73
00:04:20,095 --> 00:04:21,631
还是这里的一个block

74
00:04:24,447 --> 00:04:27,263
好这边讲64个block

75
00:04:29,311 --> 00:04:30,079
意思是

76
00:04:30,591 --> 00:04:31,103
他

77
00:04:31,615 --> 00:04:34,431
一次性的是要64个

78
00:04:34,687 --> 00:04:37,503
一次性地挖一大块64个

79
00:04:37,759 --> 00:04:39,551
Lux来开始供应

80
00:04:40,575 --> 00:04:42,623
在64将来会掉呗

81
00:04:42,879 --> 00:04:43,647
从早

82
00:04:44,671 --> 00:04:49,535
1282 5651 21024说他会急剧增长

83
00:04:50,303 --> 00:04:51,839
每次玩这么多的

84
00:04:52,095 --> 00:04:53,119
10块供应

85
00:04:55,679 --> 00:04:58,495
这样子挖起来这一大块

86
00:04:58,751 --> 00:05:01,311
再加上这个bitmap

87
00:05:01,567 --> 00:05:03,103
就是一个一个的

88
00:05:03,871 --> 00:05:04,383
加起来

89
00:05:04,639 --> 00:05:07,455
还要再加上一些东西的整个

90
00:05:07,711 --> 00:05:09,247
Superblock

91
00:05:09,759 --> 00:05:10,527
Superblock

92
00:05:14,111 --> 00:05:17,951
这个super_block是这些区块的前头加上这个

93
00:05:18,207 --> 00:05:18,975
Bitmap

94
00:05:19,487 --> 00:05:19,999
好

95
00:05:20,511 --> 00:05:23,583
这个就是一个一个的0101的东西用来

96
00:05:24,095 --> 00:05:25,631
记录之后头

97
00:05:26,143 --> 00:05:28,447
是在他手中或者已经给出去了

98
00:05:29,471 --> 00:05:31,775
我们现在来看这里有64个区块

99
00:05:33,311 --> 00:05:36,383
因此需要64个bit

100
00:05:36,895 --> 00:05:38,431
来表现他们的状态

101
00:05:38,943 --> 00:05:40,991
一个表一个区块

102
00:05:41,247 --> 00:05:43,807
因此这里需要64个月

103
00:05:46,879 --> 00:05:49,695
在实现上它是把它分为

104
00:05:50,719 --> 00:05:53,791
还需要几个bitmap这个就是bitmap

105
00:05:54,047 --> 00:05:55,327
这也是bitmap

106
00:05:58,911 --> 00:06:01,215
他说使用的单元是一个

107
00:06:03,263 --> 00:06:05,055
或者加一个s3e19

108
00:06:05,567 --> 00:06:06,847
不太正符号整数

109
00:06:07,615 --> 00:06:09,663
一个总数是32个

110
00:06:10,431 --> 00:06:11,199
32位

111
00:06:11,967 --> 00:06:13,503
现在需要64

112
00:06:13,759 --> 00:06:16,319
最需要两个字

113
00:06:16,575 --> 00:06:17,599
两个总数

114
00:06:18,879 --> 00:06:20,927
为了应付64

115
00:06:21,183 --> 00:06:21,695
这里

116
00:06:22,207 --> 00:06:24,255
这里需要两个整数

117
00:06:25,023 --> 00:06:29,119
目前的状态全部都在手中还没有给出去

118
00:06:29,375 --> 00:06:31,423
所以这边的全部都是1

119
00:06:32,959 --> 00:06:35,263
1表示在手中0表示给出去

120
00:06:35,775 --> 00:06:39,615
全部都是一所以我用16进位表示又全部都是

121
00:06:44,223 --> 00:06:46,015
前面还有一个整数

122
00:06:46,527 --> 00:06:48,063
意思是由Scott

123
00:06:48,831 --> 00:06:50,879
这里已经用掉几个了

124
00:06:51,647 --> 00:06:55,487
现在还没有一个都没用叫沈世明这也是一个整数

125
00:06:57,791 --> 00:06:59,071
我没有办法按照

126
00:06:59,327 --> 00:07:03,935
比例来话说这个这么长是一个怎么说就这么短也是一个整数

127
00:07:05,727 --> 00:07:07,519
正前面还有一个数字

128
00:07:08,799 --> 00:07:11,871
进入的superblock的大小

129
00:07:13,151 --> 00:07:19,295
这里所有的superblock是不含这个这是什么成浅很浅的浅咖钱钱

130
00:07:19,551 --> 00:07:20,831
粉红色的这个东西

131
00:07:21,087 --> 00:07:21,855
不喊他

132
00:07:22,111 --> 00:07:23,391
后头这些大小

133
00:07:24,159 --> 00:07:25,183
这不现在家家看

134
00:07:26,975 --> 00:07:27,487
如果

135
00:07:28,255 --> 00:07:29,535
Plus size

136
00:07:29,791 --> 00:07:30,815
八个字节

137
00:07:31,583 --> 00:07:35,423
其实在这个整个设计里面的他的block最小的什么

138
00:07:35,935 --> 00:07:42,079
然后是八的倍数的成长86 243则它只允许这种大小

139
00:07:43,359 --> 00:07:45,919
现在我的例子呢比如说我放一个大富豪

140
00:07:46,943 --> 00:07:48,991
每个元素是个大破碎发

141
00:07:50,527 --> 00:07:52,831
因此superblock的大小是多少呢

142
00:07:53,599 --> 00:07:54,111
好

143
00:07:54,367 --> 00:07:55,391
这一个是4

144
00:07:55,647 --> 00:07:58,719
我现在以字节为单位啊这个是次

145
00:08:00,255 --> 00:08:02,559
后面这两个人是二x四

146
00:08:02,815 --> 00:08:03,327
这两个

147
00:08:04,607 --> 00:08:06,911
再加上这个64

148
00:08:07,423 --> 00:08:09,471
64成语每个多少吧

149
00:08:11,007 --> 00:08:12,287
我刚刚讲是18吗

150
00:08:13,823 --> 00:08:15,103
这样子加起来

151
00:08:16,127 --> 00:08:17,663
524个字节

152
00:08:17,919 --> 00:08:20,223
52次就会被登记在这里

153
00:08:20,991 --> 00:08:25,343
当然这个的不会带动后面可能有变动行为是不会动

154
00:08:25,855 --> 00:08:29,951
524表示在他之后的这一个叫superblock的大小

155
00:08:34,559 --> 00:08:40,703
在运作过程中将会比如说你有100万个元素10000000个元素好了因此将会有

156
00:08:40,959 --> 00:08:43,519
有你可以想象有很多的superblock

157
00:08:43,775 --> 00:08:49,919
而且这些superblock会越来越大的这个64再来一个吧再来

158
00:08:50,175 --> 00:08:52,479
两臂一项就会变成天文数字

159
00:08:54,015 --> 00:08:55,807
这些superblock

160
00:08:56,575 --> 00:08:59,391
也要有一个地方来控制它

161
00:09:00,159 --> 00:09:00,927
操纵他

162
00:09:02,975 --> 00:09:04,255
家有一个Master

163
00:09:07,583 --> 00:09:09,887
这里有两格

164
00:09:11,167 --> 00:09:13,215
表现一个单元

165
00:09:13,471 --> 00:09:19,615
两格世代表两根指针两根指针形成一个半圆这个半圆要超过

166
00:09:19,871 --> 00:09:20,895
空这个superblock

167
00:09:21,919 --> 00:09:23,455
在这两根指针呢

168
00:09:23,711 --> 00:09:29,343
指的就是superblock这个子64块里面的头和尾

169
00:09:30,879 --> 00:09:37,023
这里的文化他的这个地方表示我可以拿这个指针所指的那个位置就是这个颜色

170
00:09:39,071 --> 00:09:41,631
注意一下头和尾巴所发的位置

171
00:09:43,167 --> 00:09:44,191
用来指向

172
00:09:44,447 --> 00:09:46,751
最前面和最后面的元素

173
00:09:49,311 --> 00:09:50,847
这样为一个单元

174
00:09:51,359 --> 00:09:52,639
这是一个superblock

175
00:09:52,895 --> 00:09:58,527
如果有第2个Super快就会有第2个单元这些单元

176
00:09:59,551 --> 00:10:02,623
放在什么地方放在一个vector little

177
00:10:06,207 --> 00:10:07,743
在他的设计里面

178
00:10:07,999 --> 00:10:10,815
他自己写出了一个叫minister

179
00:10:11,839 --> 00:10:14,911
这是他里面的源代码的名称叫minister

180
00:10:16,191 --> 00:10:18,239
他不想用容器那个

181
00:10:18,495 --> 00:10:22,847
因为他自己就是分配器是要为容器来服务的

182
00:10:24,127 --> 00:10:30,271
如果他又用了容器然后它又要被容器使用你说怎么办呢你头脑会打结了

183
00:10:30,527 --> 00:10:32,063
鸡生蛋还是蛋生鸡呀

184
00:10:34,367 --> 00:10:37,951
所以他自己写的一个小型的叫minister

185
00:10:38,463 --> 00:10:40,511
完全模仿的写法

186
00:10:42,047 --> 00:10:42,559
喂

187
00:10:42,815 --> 00:10:44,607
让我们对外科有什么理解啊

188
00:10:45,631 --> 00:10:48,191
但愿你有这样的理解我现在告诉你

189
00:10:48,703 --> 00:10:52,031
标准互联的master其实里头就是三根支撑

190
00:10:53,823 --> 00:10:57,407
Extends the finished in their end of storage

191
00:10:57,919 --> 00:10:59,199
大致相同

192
00:10:59,711 --> 00:11:03,295
美女是指向最后一个元素的下一个位置

193
00:11:03,551 --> 00:11:04,831
现在这是什么情况

194
00:11:05,087 --> 00:11:05,855
现在只有英

195
00:11:06,111 --> 00:11:06,623
乐余

196
00:11:07,391 --> 00:11:10,975
一个单元而已这两个是一个单元啊

197
00:11:11,487 --> 00:11:17,631
也就是这个minister它只有一个元素所以这个头指向这里伪呢为止

198
00:11:17,887 --> 00:11:18,399
此项

199
00:11:18,655 --> 00:11:21,727
最后元素的下一位置

200
00:11:23,775 --> 00:11:26,847
End of storage指的是那个

201
00:11:27,103 --> 00:11:31,199
那个容量的那个尾巴我没有把它画出来啊

202
00:11:31,455 --> 00:11:35,295
在这张图里面他指的也是这个位置

203
00:11:36,063 --> 00:11:37,599
这是

204
00:11:37,855 --> 00:11:43,487
各元素的情况现在这个股可能你看见由于这里我换两个可能让你误会

205
00:11:43,999 --> 00:11:48,095
其实我是非常刻意的我这两个有一个出的框框框起来

206
00:11:48,351 --> 00:11:49,887
表示他是一个单元

207
00:11:50,143 --> 00:11:52,959
深浅蓝色的这个出框框

208
00:11:53,215 --> 00:11:56,031
我们先跳几月去看一下

209
00:11:56,287 --> 00:11:59,359
后面的变化等下会回到这一页了

210
00:11:59,871 --> 00:12:00,895
我现在跳

211
00:12:01,151 --> 00:12:02,943
跳跳跳

212
00:12:04,223 --> 00:12:09,599
你看现在就有两个单元的在找什么呢发的游戏呀

213
00:12:11,391 --> 00:12:12,415
如果再往下

214
00:12:13,183 --> 00:12:14,463
三个单元

215
00:12:15,231 --> 00:12:19,839
那就要需要把三个单元需要单个字符

216
00:12:20,863 --> 00:12:25,215
不是需要再讲一次三个单元对应的三个数字

217
00:12:27,519 --> 00:12:28,031
不过

218
00:12:28,287 --> 00:12:30,591
Vector本身是两倍成长

219
00:12:31,359 --> 00:12:35,967
所以刚刚从0变成一变成22下来的同事

220
00:12:36,223 --> 00:12:38,015
所以这里是四个单元

221
00:12:39,295 --> 00:12:41,343
用了三个最后一个没有用

222
00:12:43,391 --> 00:12:47,999
这是我们很快速的看一下这个数这个minister的变化

223
00:12:50,303 --> 00:12:51,327
再回到前面

224
00:12:54,399 --> 00:12:55,679
我刚刚是这夜

225
00:12:58,239 --> 00:13:00,543
介绍了什么呢

226
00:13:01,311 --> 00:13:02,335
Superblock

227
00:13:03,103 --> 00:13:04,895
Bitmap

228
00:13:05,663 --> 00:13:07,711
还有秘密的

229
00:13:10,527 --> 00:13:12,063
现在我开始看

230
00:13:12,319 --> 00:13:13,599
我要在这个

231
00:13:13,855 --> 00:13:18,463
分配器上分配内存我现在分配一个了

232
00:13:18,719 --> 00:13:24,863
我是客户我我觉得到了一个指针就指向这个灰色的起点我得到了满足了

233
00:13:25,119 --> 00:13:29,471
而这个分配器的这个已经给出去了所以这个counter了

234
00:13:30,751 --> 00:13:31,519
UV cut

235
00:13:31,775 --> 00:13:34,079
已经用了多少个人用了一个

236
00:13:35,103 --> 00:13:37,151
Banana

237
00:13:37,663 --> 00:13:43,807
Bitmap的变化次去刚好能和block区块的变化

238
00:13:44,063 --> 00:13:50,207
在这个变化次序相反所以你这样为什么要想法为什么不相同啊

239
00:13:50,463 --> 00:13:54,303
这只是他设计的一个是坐他愿意这样他高兴这样

240
00:13:54,559 --> 00:13:55,327
你看啊

241
00:13:55,839 --> 00:13:56,607
所以这个

242
00:13:56,863 --> 00:13:59,423
Block是从这边开始分配的

243
00:13:59,679 --> 00:14:01,983
箭头是往这边走

244
00:14:02,239 --> 00:14:06,335
Open Map的是往这边来进行

245
00:14:07,103 --> 00:14:11,455
所以这个回声会是给去就代表

246
00:14:11,711 --> 00:14:13,759
最后一个bit变成立方

247
00:14:14,271 --> 00:14:20,415
如果继续往右边分配那这个bit就往左边变成你

248
00:14:22,975 --> 00:14:29,119
现在给了一个出去了这里变成abcde的e

249
00:14:29,375 --> 00:14:35,519
多看几张图就清楚了我们下一个分配第2个就会变成100

250
00:14:35,775 --> 00:14:41,919
也就是C注意这边有点儿了已经用

251
00:14:42,175 --> 00:14:43,455
用漂亮的

252
00:14:43,711 --> 00:14:49,855
三月我这个一直用一只用我客户一直申请了

253
00:14:50,111 --> 00:14:55,743
用了63个这种共64只用了63

254
00:14:55,999 --> 00:14:58,047
因此这个地方

255
00:14:58,559 --> 00:15:04,703
这地方是63而实现这些都用过了所以全部变成0

256
00:15:04,959 --> 00:15:09,567
只有最后一个是一

257
00:15:10,847 --> 00:15:15,455
因此这个画出来就是8000

258
00:15:15,711 --> 00:15:17,247
0000

259
00:15:20,575 --> 00:15:26,719
现在都还在使用最刚开始的这个

260
00:15:26,975 --> 00:15:30,559
Superblock说这边只有一个单元

261
00:15:35,167 --> 00:15:37,983
我们再往下

262
00:15:39,263 --> 00:15:45,407
我已经接到下一页了有什么变化如果客户还得这一个区块

263
00:15:45,919 --> 00:15:48,991
指针指向这里还有这个区块

264
00:15:49,247 --> 00:15:50,783
这时候这个counter

265
00:15:51,295 --> 00:15:55,647
打开一下3月3月16日三现在病62

266
00:15:57,183 --> 00:16:03,327
还有呢相对应的被指压按起来说这个的

267
00:16:03,583 --> 00:16:07,167
01

268
00:16:07,423 --> 00:16:13,567
101

269
00:16:13,823 --> 00:16:19,967
我想这样子对于一个superb

270
00:16:20,223 --> 00:16:26,367
Proc的变化非常清楚了也很爷也还蛮容易写出来的

271
00:16:26,623 --> 00:16:31,487
我们再看下一页

272
00:16:31,743 --> 00:16:37,887
如果我把第1个师父不让使用光了

273
00:16:38,143 --> 00:16:44,287
那是64个吧用光那么这个分配器就会启动第2个

274
00:16:44,543 --> 00:16:50,687
我们看他的变化所以刚刚的那个已经用光了你看全部都变成

275
00:16:50,943 --> 00:16:53,247
深灰色了这里全部变成0了

276
00:16:53,503 --> 00:16:56,831
这里呢由Scott已经用了64个

277
00:16:57,087 --> 00:17:00,415
这个长度是不会变的

278
00:17:01,951 --> 00:17:08,095
这一块的这头为两根指针是放在这个东西这个单元

279
00:17:08,351 --> 00:17:14,495
这个也不会变但现在要启动第2个出口出来

280
00:17:14,751 --> 00:17:20,895
出来了这时候这个变成128刚是64

281
00:17:21,151 --> 00:17:27,295
0128并且第1个就给出去了因为只要又要一个才会

282
00:17:27,551 --> 00:17:33,695
找出第2个出口出来去128个区域

283
00:17:33,951 --> 00:17:40,095
一会就需要128个bit来表现他们的状态

284
00:17:40,351 --> 00:17:46,495
128个屁就是四个整数

285
00:17:46,751 --> 00:17:51,871
现在最后这个整数的最后这个壁纸变成0了

286
00:17:52,127 --> 00:17:56,735
这个只是一A B C D E的e

287
00:17:58,015 --> 00:18:00,319
这个字已经变得很小了不过

288
00:18:00,575 --> 00:18:06,719
你打印出来的讲义应该还是非常清楚的或者是你在屏幕上看应该还是

289
00:18:06,975 --> 00:18:13,119
足够清楚好了我们来算一算这个长度第2个

290
00:18:13,375 --> 00:18:19,519
Superblock的程度这边有这个词1044是怎么来的

291
00:18:19,775 --> 00:18:25,919
现在superblock翻译的block区块的大小是

292
00:18:26,175 --> 00:18:28,735
把自己连续刚刚的故事

293
00:18:28,991 --> 00:18:35,135
在很多38个自己这都是大家好

294
00:18:35,391 --> 00:18:41,023
这个是就是这个优势康是个自己

295
00:18:41,279 --> 00:18:45,887
后面这个自称一次就是四个整数

296
00:18:46,399 --> 00:18:51,775
再来那128个区块可以吧

297
00:18:52,031 --> 00:18:56,895
把这样盛出来

298
00:18:57,151 --> 00:19:03,295
四加16加1024 1044

299
00:19:05,855 --> 00:19:11,999
好吧然后这个

300
00:19:12,255 --> 00:19:18,399
这边长出第2个这个mininet长出第2个单元也是头

301
00:19:18,655 --> 00:19:22,495
头尾

302
00:19:22,751 --> 00:19:28,383
这就是第2个superblock出现

303
00:19:35,039 --> 00:19:40,415
注意我这边写grow-up这里成长

304
00:19:42,207 --> 00:19:48,351
我相信你对于标准库的容器一定有一个

305
00:19:48,607 --> 00:19:50,655
一定有一些概念

306
00:19:50,911 --> 00:19:56,287
那么有一个很很多人都已经知道的概念是什么呢

307
00:19:56,543 --> 00:19:57,567
Vector

308
00:19:57,823 --> 00:20:03,455
他会成长当他的空间不够的时候他被列为成长

309
00:20:03,711 --> 00:20:07,039
我们看上一页

310
00:20:07,295 --> 00:20:11,135
上月这只有一个单元就表示

311
00:20:11,391 --> 00:20:13,439
Access有一个元素

312
00:20:13,951 --> 00:20:20,095
现在要增加一个新的元素它不够了所以它会两倍也就是变成了

313
00:20:59,519 --> 00:21:05,663
但是这个都是很底层的东西这是这个分配这个名字

314
00:21:05,919 --> 00:21:11,807
不得的事情他的上层我们是无所谓了

315
00:21:13,855 --> 00:21:17,696
好只是第2个super_block

316
00:21:17,952 --> 00:21:24,096
我们继续往下看如果把第2个也就是师傅block.one 100

317
00:21:24,352 --> 00:21:29,728
88区块怎么用网也就是说我们已经用掉了一开始用的64

318
00:21:29,984 --> 00:21:33,312
又用掉了128现在在哪一个

319
00:21:34,336 --> 00:21:36,384
这时候就启动

320
00:21:36,640 --> 00:21:38,688
Sandisk

321
00:21:38,944 --> 00:21:45,088
动态分配的三个superblock先看前两个60

322
00:21:45,344 --> 00:21:47,904
是用这个就是最重要的128

323
00:21:48,160 --> 00:21:50,208
所有的变成都变成0了

324
00:21:53,536 --> 00:21:58,912
然后看着第3个这个多长怎么算呢

325
00:21:59,168 --> 00:22:00,192
这是一个整数

326
00:22:00,448 --> 00:22:02,240
所以14个自己

327
00:22:02,496 --> 00:22:04,288
后面需要

328
00:22:04,544 --> 00:22:05,568
花各种树

329
00:22:06,336 --> 00:22:10,432
发个整数是256bit

330
00:22:10,688 --> 00:22:14,784
才能表现后头的256个区块

331
00:22:16,832 --> 00:22:19,904
所以这边需要八个整数

332
00:22:20,160 --> 00:22:25,280
加上后头256每个区块18个字节

333
00:22:27,072 --> 00:22:28,864
加起来

334
00:22:29,376 --> 00:22:32,192
2084登记的最

335
00:22:33,984 --> 00:22:35,776
这也是一个整数

336
00:22:41,152 --> 00:22:47,296
好由于展出的第3个superblock所以这个mini master也要有的13

337
00:22:47,552 --> 00:22:51,392
单个的第3个单元来控制它

338
00:22:51,648 --> 00:22:52,672
头尾

339
00:22:56,768 --> 00:23:01,120
上一页是两个单元现在要在成长

340
00:23:01,376 --> 00:23:05,472
小便是个单元二变成了4

341
00:23:07,264 --> 00:23:09,312
但是现在使用吊扇

342
00:23:09,568 --> 00:23:12,384
所以我最后那一个目前还没用

343
00:23:12,640 --> 00:23:13,920
到它被用掉

344
00:23:14,176 --> 00:23:15,968
关掉这个颜色来表现

345
00:23:21,088 --> 00:23:27,232
就这样的继续成长下去这都是分配我们还没讲到释放

346
00:23:27,488 --> 00:23:29,024
回收还没谈到

347
00:23:31,328 --> 00:23:33,120
帮我们看这边有两段话

348
00:23:35,680 --> 00:23:41,824
如果没有全部曾经全回收的话全会说就是这个说这个我们的

349
00:23:42,080 --> 00:23:44,896
又全部还回去叫全回收

350
00:23:45,920 --> 00:23:52,064
如果不曾经全回收的话那么分配的规模也就是刚本来就是

351
00:23:52,320 --> 00:23:57,184
事件越发变得又会不断的被身相当惊人

352
00:23:58,720 --> 00:24:00,512
一下子就到天文数字

353
00:24:00,768 --> 00:24:03,072
30次你看看会变成什么样

354
00:24:03,840 --> 00:24:05,888
民事机构为单位了

355
00:24:06,912 --> 00:24:12,032
不过如果有曾经全回收的话那么下一次就会减半

356
00:24:15,872 --> 00:24:19,968
这什么数学依据和什么吗没有没有这就是这个团队的设计

357
00:24:21,248 --> 00:24:22,528
还算合理

358
00:24:23,296 --> 00:24:25,344
但是没有什么数学依据

359
00:24:28,160 --> 00:24:30,464
再看这一段

360
00:24:30,720 --> 00:24:33,792
这一个master也就是这个

361
00:24:34,560 --> 00:24:35,840
也就是这一些

362
00:24:36,608 --> 00:24:39,168
它的大小是没有限制的

363
00:24:39,680 --> 00:24:45,824
这是一个秘密的表达自己写的那个本来就不该有限制了这个一般观念

364
00:24:46,080 --> 00:24:47,872
只要内存够

365
00:24:50,688 --> 00:24:55,552
每一个entry就是这里的两个为一个单元这样的一个entry

366
00:24:55,808 --> 00:24:58,624
代表一种流派

367
00:25:00,416 --> 00:25:01,696
意思是什么呢

368
00:25:01,952 --> 00:25:03,744
这个value type这就是

369
00:25:04,000 --> 00:25:05,024
现在元素

370
00:25:07,584 --> 00:25:12,704
你是说不同的话就差和即时大小相同也是不会会用

371
00:25:13,984 --> 00:25:16,544
比如说你现在设计

372
00:25:18,848 --> 00:25:20,384
建立容器

373
00:25:20,896 --> 00:25:23,968
容器里面有元素

374
00:25:25,248 --> 00:25:28,576
也许还要经过一些包装最后就变成一个区

375
00:25:29,088 --> 00:25:31,392
许会跟他要求一个区块

376
00:25:33,184 --> 00:25:38,560
这里说说不定你的容器a和容器B

377
00:25:38,816 --> 00:25:43,168
他们的发出来的需求大小是一样

378
00:25:43,936 --> 00:25:50,080
但是它里头的元素其实类型不同有一个叫石头一个是

379
00:25:51,616 --> 00:25:52,384
一个是

380
00:25:52,640 --> 00:25:53,664
黄牛

381
00:25:53,920 --> 00:25:55,968
它们的大小都是100

382
00:25:57,504 --> 00:25:58,272
比如这样

383
00:25:58,784 --> 00:26:00,320
这就是这句话的意思

384
00:26:00,576 --> 00:26:05,952
即使大小相同也是不会混用在同一个

385
00:26:06,208 --> 00:26:08,000
Superblock little

386
00:26:09,280 --> 00:26:11,328
一个superblock他有一个

387
00:26:11,584 --> 00:26:12,864
为什么定义

388
00:26:14,400 --> 00:26:20,032
因为黄牛的就是为黄牛儿取费为为石头准备的就是为适度的准备

389
00:26:21,056 --> 00:26:22,592
这句话的意思
