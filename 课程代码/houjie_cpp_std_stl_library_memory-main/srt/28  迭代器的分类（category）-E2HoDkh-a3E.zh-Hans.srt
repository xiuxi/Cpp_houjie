1
00:00:07,680 --> 00:00:09,984
号我们前面完成了第2架

2
00:00:11,776 --> 00:00:14,080
从现在开始了我们来谈第3讲

3
00:00:14,848 --> 00:00:16,640
整个现在的标准库

4
00:00:16,896 --> 00:00:22,528
最庞大的那部分我们叫STL他另外周边还有一些东西在s9之外

5
00:00:22,784 --> 00:00:23,552
Yamaha

6
00:00:24,320 --> 00:00:27,392
Siri讲坛是STL里头的

7
00:00:27,904 --> 00:00:31,488
这种药最庞大的一部分容器

8
00:00:32,512 --> 00:00:37,632
第3家开始了我们也是在谈STL算法

9
00:00:39,168 --> 00:00:41,216
而这第2讲啊

10
00:00:41,728 --> 00:00:45,824
第3讲解第3讲汉第2讲一样我们也都是要深入到

11
00:00:46,336 --> 00:00:52,480
这些东西里头的这些固件组件component里头的这个

12
00:00:52,736 --> 00:00:53,504
源代码

13
00:00:53,760 --> 00:00:59,904
那么了解这个源代码我们就非常清楚里面的一些限制他的能力

14
00:01:00,160 --> 00:01:06,304
在语言上还是怎么表现出来的这个对我们后面来运用就非常的有帮助

15
00:01:06,560 --> 00:01:11,168
另外方面当然也是学习到技术上的东西不只是应用上的东西

16
00:01:12,960 --> 00:01:13,984
好首先

17
00:01:14,240 --> 00:01:17,312
标准库0的算法是一个什么样的东西

18
00:01:18,848 --> 00:01:21,408
从语言的层面来看

19
00:01:22,688 --> 00:01:26,272
标准库STL的六大部件

20
00:01:26,784 --> 00:01:32,928
前面我们的二奖主要他的容器它其实是一个Class template类模板

21
00:01:33,184 --> 00:01:38,816
回想一下全部这些容器都是在一个类里头而且他这个模板

22
00:01:39,072 --> 00:01:41,120
这是从语言的层次来讲

23
00:01:41,376 --> 00:01:42,912
算法是什么呢

24
00:01:43,168 --> 00:01:45,216
是一个方向temperate

25
00:01:45,984 --> 00:01:51,616
算法比如说说好了排序这些做成一个函数那你要用它你就调用它吗

26
00:01:51,872 --> 00:01:58,016
给他这个函数的样子但是它是一个模板函数函数模板至于其他的这个货

27
00:01:58,272 --> 00:02:02,112
后面接下去都要讲了那这些其实全部都是Class template

28
00:02:02,368 --> 00:02:03,904
就很独特了

29
00:02:04,160 --> 00:02:06,208
算法是一个方向temperate

30
00:02:06,464 --> 00:02:09,024
语法上来讲我们这样写

31
00:02:09,280 --> 00:02:14,912
这个斜体字表示就是是不是一个真正的名称是一个一个

32
00:02:15,424 --> 00:02:16,704
Placeholder一个

33
00:02:16,960 --> 00:02:20,288
一个一个菜名称所以意思是说

34
00:02:21,312 --> 00:02:23,872
标准库里面所有的算法

35
00:02:24,128 --> 00:02:25,920
不赞成这种样子

36
00:02:26,176 --> 00:02:27,200
你这个来看

37
00:02:27,456 --> 00:02:30,272
那这是一个什么这是一个方向函数

38
00:02:30,528 --> 00:02:36,416
但是它有一些抽象的一些一些尚未定义出来的类型

39
00:02:36,928 --> 00:02:41,792
所以这是一个模板就符合上面所说的算法是一个方形

40
00:02:42,048 --> 00:02:48,192
那么另外一种形式通常算法可能会有第2个版本

41
00:02:48,448 --> 00:02:50,496
把这个第2版本

42
00:02:51,008 --> 00:02:52,288
那就这个样子

43
00:02:52,544 --> 00:02:58,688
名称相同比如说说他就会这样啊有一个数则他是两个参数的有一个受伤的他是三个词

44
00:02:58,944 --> 00:03:05,088
参数将这一种情况第3个参数就是意思是说我们在调用so的是

45
00:03:05,344 --> 00:03:05,856
时候

46
00:03:06,368 --> 00:03:10,720
它允许我们在调用它的时候传入一个

47
00:03:11,488 --> 00:03:14,048
Criteria一个准则

48
00:03:14,304 --> 00:03:20,448
比如说排序要排大小什么时候比大小大跟小要怎么比怎么定义这个叫

49
00:03:20,704 --> 00:03:22,240
Criteria则

50
00:03:22,496 --> 00:03:25,568
而后面里陆陆续续就会看到

51
00:03:26,336 --> 00:03:31,456
在很多的算法里头都允许你传入一个

52
00:03:31,712 --> 00:03:37,856
Criteria进来向这个名字叫个compared因为受的话排序要比

53
00:03:38,112 --> 00:03:41,952
大小最捧场准则是一个比较大小的一个准则

54
00:03:42,720 --> 00:03:47,328
这个后面再来体质适用是一个什么东西它其实是一个方程

55
00:03:48,096 --> 00:03:53,728
我这后面再来说了所以算法基本上就是这辆这样的形式

56
00:03:53,984 --> 00:03:59,104
各位可以看到这个算法呢其实算法

57
00:03:59,360 --> 00:04:00,128
下来

58
00:04:00,384 --> 00:04:04,224
对父容器的价来处理容器里面贝塔

59
00:04:06,272 --> 00:04:12,416
但是我们前面讲过说闭门造车就是现在来讲是好事情啊这个

60
00:04:12,672 --> 00:04:15,488
这一切开来的两边各自进行

61
00:04:16,000 --> 00:04:21,631
彼此没有干点彼此之间唯一的关系靠的是一个迭代器

62
00:04:22,655 --> 00:04:28,799
所以算法其实是看不到容器的他只看到他收到的这两个参数

63
00:04:29,055 --> 00:04:33,151
每一个算法一定有最前面两个参数就是迭代器

64
00:04:33,407 --> 00:04:38,015
他只看到迭代器迭代器是由容器来提供的

65
00:04:38,783 --> 00:04:44,415
Phash算法要去处理数据的时候那可能会想要知道

66
00:04:44,671 --> 00:04:45,951
我到底处理了

67
00:04:46,975 --> 00:04:51,583
标的target我的目标是不是一种什么样的容器

68
00:04:54,143 --> 00:04:58,239
为什么他会想要知道这个呢因为如果他知道的话

69
00:04:59,007 --> 00:05:00,287
知道这个容器的

70
00:05:00,543 --> 00:05:02,335
某些性质

71
00:05:02,591 --> 00:05:06,687
也许可以帮助算法找出一个最快最有效率的

72
00:05:06,943 --> 00:05:07,711
动作

73
00:05:08,223 --> 00:05:10,271
后面慢慢就会清楚这个观念

74
00:05:11,295 --> 00:05:12,063
所以

75
00:05:12,575 --> 00:05:18,719
算法会想要提问问迭代器一些问题而迭代器的需要

76
00:05:18,975 --> 00:05:21,279
要能够回答他这样的话

77
00:05:21,535 --> 00:05:22,815
算法

78
00:05:23,071 --> 00:05:28,191
虽然看不到容器但是它可以通过问答的方式去知道

79
00:05:28,703 --> 00:05:29,983
在这个容器里面

80
00:05:30,495 --> 00:05:33,055
在移动的情况等等等

81
00:05:34,591 --> 00:05:36,127
这就是这段话的意思

82
00:05:36,895 --> 00:05:40,223
廊坊那变算法的看不见容器

83
00:05:40,735 --> 00:05:43,039
所以他对他一无所知

84
00:05:43,295 --> 00:05:49,439
所以算法所需要的一切的信息这个信息通常就是指别在气怎么

85
00:05:50,719 --> 00:05:53,279
等一下就会看到它的分类啊怎么走

86
00:05:54,303 --> 00:05:58,655
他需要的一切的信息都必须从iterator迭代器取的

87
00:05:58,911 --> 00:06:02,495
而迭代器那必须能够回答所有的提问

88
00:06:03,007 --> 00:06:06,079
才能够搭配这个算法的所有的操作

89
00:06:06,335 --> 00:06:09,407
如果算法发出问题

90
00:06:09,919 --> 00:06:11,455
迭代器没有办法回答

91
00:06:12,223 --> 00:06:14,527
那会怎么样编译到哪一好

92
00:06:14,783 --> 00:06:17,087
兵器时代就会报错

93
00:06:19,135 --> 00:06:23,487
我们前面奇水晶谈到了这个迭代器呀

94
00:06:23,743 --> 00:06:28,351
他应该提供一个相关类型的App

95
00:06:29,119 --> 00:06:32,703
怎么卖流type拉什么分类category这种东西

96
00:06:33,727 --> 00:06:34,239
现在

97
00:06:35,519 --> 00:06:36,543
我们要

98
00:06:36,799 --> 00:06:41,407
由于搭配的算法我们正在谈算法所以要把这

99
00:06:41,663 --> 00:06:42,175
这个

100
00:06:44,479 --> 00:06:46,271
迭代器它能够

101
00:06:46,527 --> 00:06:52,671
提供的特别是在分类这件事情上面它是怎么设计的麦把弄得非常的清楚

102
00:06:53,183 --> 00:06:58,559
MC张是容器的一个中毒

103
00:06:59,583 --> 00:07:02,655
迭代器是由容器来提供的

104
00:07:03,167 --> 00:07:04,191
所以

105
00:07:04,703 --> 00:07:07,519
我们观看图你可以去推想

106
00:07:08,287 --> 00:07:09,567
迭代器

107
00:07:09,823 --> 00:07:11,615
这个array的迭代器

108
00:07:12,383 --> 00:07:14,687
他应该有什么样的移动特性呢

109
00:07:15,455 --> 00:07:16,991
这是一个连续空间

110
00:07:17,247 --> 00:07:23,135
所以在移动的特性就像指针一样应该是一个random access小说

111
00:07:23,391 --> 00:07:25,695
随机的访问就可以跳

112
00:07:26,207 --> 00:07:28,255
从这个地方我可以跳

113
00:07:28,511 --> 00:07:29,279
三格

114
00:07:29,535 --> 00:07:30,815
直接跳到这里了

115
00:07:32,607 --> 00:07:33,375
Western

116
00:07:34,655 --> 00:07:37,727
他也是连续空间说他也是应该可以跳

117
00:07:37,983 --> 00:07:39,519
也是random access

118
00:07:40,287 --> 00:07:41,055
这可能

119
00:07:41,567 --> 00:07:46,687
我们知道这可是其实是分段连续是假的连续但是他是

120
00:07:46,943 --> 00:07:51,551
给使用者感觉像真的联系一样所以它的迭代器

121
00:07:52,319 --> 00:07:55,135
也应该是random access可以跳

122
00:07:56,415 --> 00:07:57,439
Listener

123
00:07:58,463 --> 00:07:59,743
双向链表

124
00:08:00,255 --> 00:08:01,279
他不能跳

125
00:08:01,535 --> 00:08:05,375
不连续空间的这种容器都是不能跳要的

126
00:08:05,887 --> 00:08:10,495
所以它的迭代器应该是action

127
00:08:10,751 --> 00:08:12,543
这种样子双向

128
00:08:12,799 --> 00:08:17,151
可以往前走一步再走一步再走一步或者往后走但是你不能跳

129
00:08:18,175 --> 00:08:24,319
Full list既然叫full list他就只能走一个方向单向链表所以它

130
00:08:24,575 --> 00:08:26,367
他似乎也protect

131
00:08:28,671 --> 00:08:29,951
这个汉字一个呢

132
00:08:30,463 --> 00:08:35,839
红黑树飞长途虽然没有表现出他到底是单向和双向

133
00:08:36,095 --> 00:08:42,239
不过前面我们在第二章讲到容器的时候有那个红色跟黑色的节点那些图

134
00:08:42,495 --> 00:08:44,799
你可以看得很清楚他是双响

135
00:08:45,055 --> 00:08:45,823
所以

136
00:08:46,079 --> 00:08:50,431
红黑树所做出来的东西他可以做出set map

137
00:08:50,687 --> 00:08:54,527
Multiset multimap这些东西全部都是

138
00:08:54,783 --> 00:08:56,831
双向bidirectional

139
00:09:00,671 --> 00:09:01,439
那么

140
00:09:01,951 --> 00:09:03,487
On others

141
00:09:03,999 --> 00:09:07,071
王鸥的非不定去的这种容器呢

142
00:09:07,839 --> 00:09:13,983
我们说其实我们在第二章谈过了他的底部是hashtable做出来的那不还记得吗他就好几个

143
00:09:14,239 --> 00:09:18,591
给个筒子他几个男子哪个男子下面是一个链表

144
00:09:19,103 --> 00:09:23,199
要看看这个链表是一个单向还是双向链表

145
00:09:23,967 --> 00:09:26,015
才能够判断后才能够

146
00:09:26,271 --> 00:09:27,295
决定书

147
00:09:27,807 --> 00:09:30,367
Hashtable本身是一个

148
00:09:31,391 --> 00:09:32,415
单向的

149
00:09:32,671 --> 00:09:34,719
这个还是一个双向的

150
00:09:36,511 --> 00:09:42,655
我们觉得这个总图因为我们在第2章第2讲一句已经对于容器非常理解了所以

151
00:09:43,167 --> 00:09:46,239
应该现在随便问你哪一个容器集中式

152
00:09:46,751 --> 00:09:47,775
迭代器它是

153
00:09:48,287 --> 00:09:54,431
来一个容器所提供的迭代器它是一个怎么样的一个移动方式现在应该了然于胸

154
00:09:54,687 --> 00:09:59,551
熊这种迭代方式的移动方也大器的移动方式

155
00:10:00,063 --> 00:10:05,183
你要怎么设计也许最初浅的想法就是让我有一个

156
00:10:05,695 --> 00:10:07,487
比如说一个做好了

157
00:10:08,255 --> 00:10:11,071
Quickly and integration

158
00:10:11,839 --> 00:10:13,119
表示12345

159
00:10:13,887 --> 00:10:14,655
123

160
00:10:15,167 --> 00:10:16,703
等等等自动分类

161
00:10:17,471 --> 00:10:20,543
但是你看到标准库不是这种做法

162
00:10:21,055 --> 00:10:23,103
它不是用123来表示

163
00:10:23,871 --> 00:10:25,407
不同的分类

164
00:10:25,919 --> 00:10:28,223
他用的是这么写

165
00:10:29,247 --> 00:10:34,879
我现在是谈的是category pedigree就是移动的这种能力的分类

166
00:10:36,415 --> 00:10:40,767
五种开degree他不是12345他15个class

167
00:10:41,279 --> 00:10:45,631
我每次看到我都把它长成克拉什么东西

168
00:10:47,935 --> 00:10:54,079
之后面都带着一个tag一个标签是他命名的时候方便我们去理解他都是一些变

169
00:10:54,335 --> 00:10:57,407
而这些标签是有继承关系的

170
00:10:58,431 --> 00:11:01,247
如果你仔细看这个图形和下来仔细看

171
00:11:02,015 --> 00:11:04,319
这个人在把华盛顿就是下面这样

172
00:11:07,135 --> 00:11:08,671
Randomaccess继承制

173
00:11:09,183 --> 00:11:15,327
Population双向双向要继承制单相三相继承资源或者另外一个单独的offer

174
00:11:15,583 --> 00:11:21,727
难度的operator并没有跟谁最上面的源代码呢

175
00:11:21,983 --> 00:11:24,031
华盛顿是真英种样子

176
00:11:24,287 --> 00:11:28,127
龙为什么他不用123455来表现而要用

177
00:11:28,639 --> 00:11:29,407
克拉斯

178
00:11:29,663 --> 00:11:34,015
克拉斯他们就做什么把对象为什么呢

179
00:11:34,271 --> 00:11:35,551
后面你会看到

180
00:11:35,807 --> 00:11:36,575
原因

181
00:11:36,831 --> 00:11:42,975
我们现在能够了解你就是原来压容器所提供的

182
00:11:43,231 --> 00:11:46,559
迭代器iterator它的分类

183
00:11:46,815 --> 00:11:49,375
不是12345儿是这一种

184
00:11:49,631 --> 00:11:51,935
对象

185
00:11:55,007 --> 00:11:59,871
好我们就来写一个程序示范下

186
00:12:00,383 --> 00:12:02,175
怎么样打印出

187
00:12:02,431 --> 00:12:08,575
各式各样容器里所提供的迭代器它的分类的形式给你看

188
00:12:09,087 --> 00:12:13,695
这个程序这里2块从哪里开始进行了从这里

189
00:12:16,511 --> 00:12:22,655
好我写了一个函数叫astray category分类分类的打印出来

190
00:12:24,447 --> 00:12:25,727
要用这么多次

191
00:12:26,495 --> 00:12:29,823
我在这里头呢我设计了一个参数

192
00:12:30,335 --> 00:12:31,615
这个参数是

193
00:12:33,151 --> 00:12:35,199
各式各样的容器

194
00:12:35,967 --> 00:12:39,807
各式各样我们前面在第2家学过的所有的容器

195
00:12:42,879 --> 00:12:43,647
Iterator

196
00:12:46,207 --> 00:12:47,743
这样是一个type

197
00:12:48,255 --> 00:12:49,023
类型

198
00:12:49,279 --> 00:12:55,423
为什么后面加小括号空的小括号意思就是产生一个临时

199
00:12:55,679 --> 00:12:56,447
是对象

200
00:12:56,959 --> 00:13:00,543
这是语法的部分是一家试试

201
00:13:01,055 --> 00:13:03,871
有这样的语法而且这样的语法呢

202
00:13:04,127 --> 00:13:10,271
常常会出现那我们在C加加然后用到标准库一定会常常看到这种语法一定要

203
00:13:10,527 --> 00:13:12,575
定要了解它

204
00:13:13,855 --> 00:13:19,999
直接加小括号本来他不那么后面你应该定义对象的名称吗比如说int

205
00:13:20,255 --> 00:13:22,559
爱拍就是对象名称

206
00:13:22,815 --> 00:13:27,423
20现在是int直接加小括号类似这样的语法

207
00:13:28,703 --> 00:13:34,847
所以我就把这种容器的迭代器都做了一些零食

208
00:13:35,103 --> 00:13:38,175
使得对象所谓临时对象就是没有名称的

209
00:13:38,687 --> 00:13:41,247
把他们从东传到这款出来

210
00:13:42,527 --> 00:13:45,087
这个函数可见创建的东西

211
00:13:45,343 --> 00:13:45,855
就

212
00:13:46,623 --> 00:13:48,415
各式各样的类型了

213
00:13:49,695 --> 00:13:52,511
所以我这个函数必须选择一个模板

214
00:13:54,047 --> 00:13:56,863
传进来的IP呀是什么类型的不知道

215
00:13:57,119 --> 00:13:58,143
反正是爱

216
00:13:58,655 --> 00:14:01,215
反正将来听一起会推导出来

217
00:14:02,239 --> 00:14:05,823
叫我右边这一些就通通丢了左边这里来

218
00:14:06,847 --> 00:14:09,151
左边这一个函数

219
00:14:10,943 --> 00:14:11,967
我要做什么事情

220
00:14:12,991 --> 00:14:15,807
我拿到的是迭代器iterator

221
00:14:16,319 --> 00:14:17,855
我就把它丢到

222
00:14:18,367 --> 00:14:23,231
萃取及据说是我们的第2讲的一个很大的主主角

223
00:14:23,999 --> 00:14:25,279
Chris丢进去

224
00:14:26,047 --> 00:14:26,815
问他

225
00:14:27,327 --> 00:14:30,655
我常常口语上说问能打这个就是问

226
00:14:30,911 --> 00:14:32,959
即为整个就是提问

227
00:14:33,215 --> 00:14:39,359
我再问问这个萃取机请问一下我现在教给你的这一个迭代器呀

228
00:14:40,127 --> 00:14:40,895
他的

229
00:14:41,151 --> 00:14:42,687
Category是什么

230
00:14:44,479 --> 00:14:46,015
这么这么一写出来

231
00:14:46,271 --> 00:14:48,575
如果编译通过那这就是答案

232
00:14:50,879 --> 00:14:52,159
我正在提问

233
00:14:52,415 --> 00:14:53,695
定义通过的话呢

234
00:14:53,951 --> 00:14:54,463
表示

235
00:14:54,719 --> 00:15:00,095
确实存进去的这个迭代器它有这么一个定义那这样就是回答了

236
00:15:00,607 --> 00:15:03,935
好我把这个回答这么长太长了

237
00:15:04,191 --> 00:15:05,471
换一个名字叫

238
00:15:05,727 --> 00:15:07,263
China3

239
00:15:08,543 --> 00:15:09,311
换一个名字

240
00:15:10,079 --> 00:15:11,871
然后这个名字呢

241
00:15:12,639 --> 00:15:14,687
就把它

242
00:15:15,199 --> 00:15:16,991
在调用另外一个函数

243
00:15:17,247 --> 00:15:18,015
上头

244
00:15:19,039 --> 00:15:21,343
有个函数名字都相同

245
00:15:21,855 --> 00:15:23,647
都是叫district a degree

246
00:15:24,415 --> 00:15:25,695
网上丢

247
00:15:25,951 --> 00:15:31,583
所以这五个相同的函数它们名称相同我们在是一家里面在做什么呢

248
00:15:32,863 --> 00:15:35,935
这个函数重载overloading

249
00:15:37,215 --> 00:15:41,567
他们之间的差别在于它收到的

250
00:15:42,591 --> 00:15:46,175
参数的类型不同只是看看

251
00:15:46,687 --> 00:15:47,455
这里有五个

252
00:15:49,503 --> 00:15:50,271
这五个

253
00:15:50,527 --> 00:15:52,319
他说收到了参数呢

254
00:15:53,087 --> 00:15:55,903
分别是random access iterator

255
00:15:56,159 --> 00:15:56,671
Tech

256
00:15:57,183 --> 00:15:59,487
在这被遮住了那下看好了

257
00:15:59,743 --> 00:16:02,815
这个教派的reaction elettrotec

258
00:16:03,071 --> 00:16:08,447
这个叫forward pass这个叫output这个叫应付的歌

259
00:16:08,703 --> 00:16:10,495
就是上一页

260
00:16:10,751 --> 00:16:11,519
这个

261
00:16:15,359 --> 00:16:16,639
再回来这里了

262
00:16:17,151 --> 00:16:20,223
这里你就看到了为什么

263
00:16:21,247 --> 00:16:26,367
对于分类不用123455来表示调用对象来表示

264
00:16:27,135 --> 00:16:27,903
你看

265
00:16:28,927 --> 00:16:29,951
这个地方

266
00:16:30,207 --> 00:16:33,023
传进来调用这个函数

267
00:16:34,559 --> 00:16:35,327
不管

268
00:16:35,583 --> 00:16:37,119
Category是什么

269
00:16:37,631 --> 00:16:38,399
反正

270
00:16:38,655 --> 00:16:44,799
就这一行调用网上就自然而然编译器就会找到该调用谁

271
00:16:45,055 --> 00:16:50,431
如果这个分类是整数的12345那不行

272
00:16:50,687 --> 00:16:52,991
那没有办法写的这么漂亮

273
00:16:56,831 --> 00:16:59,135
这只是一个原因

274
00:16:59,391 --> 00:17:01,183
另还有另外一个原因

275
00:17:01,951 --> 00:17:05,791
当我们在谈为什么不用12345我要用那个

276
00:17:06,303 --> 00:17:07,583
Structure结构

277
00:17:08,607 --> 00:17:14,751
我做出来对象来表现分类这只是原因之一后面还有其他

278
00:17:15,007 --> 00:17:16,287
太原看到的来说

279
00:17:16,543 --> 00:17:19,103
好所以呢

280
00:17:19,871 --> 00:17:22,943
这一些容器的这些iterator

281
00:17:23,199 --> 00:17:29,343
放进来之后根据他们到底是什么性质就会往上调用到正确

282
00:17:29,599 --> 00:17:32,159
一个函数之一

283
00:17:32,671 --> 00:17:36,255
我就在这五个函数里面能自己打印出

284
00:17:36,511 --> 00:17:37,791
这些字符串

285
00:17:38,559 --> 00:17:39,583
蓝色的这些

286
00:17:40,863 --> 00:17:41,887
得到了结果在这里

287
00:17:44,447 --> 00:17:49,311
可以请阁下来这个是执行结果这个是当初的调用

288
00:17:49,567 --> 00:17:50,847
来比对一下

289
00:17:51,359 --> 00:17:52,383
我们刚刚说

290
00:17:52,639 --> 00:17:56,735
上页说当你看到容器的总顿总统

291
00:17:57,759 --> 00:18:01,087
或者说你心中已经完全理解了之后

292
00:18:02,111 --> 00:18:04,415
你现在看源代码是这么使用

293
00:18:04,671 --> 00:18:07,231
应该知道它的执行结果是什么

294
00:18:07,999 --> 00:18:10,047
现在可以拿来验证一下

295
00:18:12,095 --> 00:18:13,375
随便看一个好了

296
00:18:13,887 --> 00:18:15,935
这个分段再看这一个好的

297
00:18:16,191 --> 00:18:17,471
这个是set

298
00:18:17,727 --> 00:18:20,031
赛车的底部是红黑树

299
00:18:20,543 --> 00:18:22,079
醉红黑树

300
00:18:22,847 --> 00:18:25,151
它的迭代器是

301
00:18:25,919 --> 00:18:28,223
百度VS双向

302
00:18:28,479 --> 00:18:34,623
是不是12345的1616个12

303
00:18:34,879 --> 00:18:38,207
34567 690 x

304
00:18:42,559 --> 00:18:48,703
讲我们就利用这个地址能非常清楚的去验证我们对于种

305
00:18:48,959 --> 00:18:51,519
铜器的旅途的迭代器的理解

306
00:18:54,591 --> 00:18:58,687
这一张画面有两个独特的东西

307
00:18:59,199 --> 00:18:59,711
这两个

308
00:19:01,247 --> 00:19:04,319
Action is weather of old Street weather

309
00:19:07,647 --> 00:19:10,463
他们都不是来自容器

310
00:19:11,487 --> 00:19:14,559
你看它的产生的方式跟上面不太一样

311
00:19:16,351 --> 00:19:17,631
这两个

312
00:19:17,887 --> 00:19:18,911
迭代器了

313
00:19:19,167 --> 00:19:23,263
在技术上了其实可以说是一个App

314
00:19:23,519 --> 00:19:24,543
适配器

315
00:19:24,799 --> 00:19:28,639
他只好目前不用管他反正这两个比较独特

316
00:19:29,151 --> 00:19:32,991
形式上就比较毒的那他们输出的结果是什么

317
00:19:33,759 --> 00:19:36,575
就是这个右边黑色最后的这两个输出

318
00:19:37,087 --> 00:19:43,231
一个是你看这个叫ice cream就是依附的意思

319
00:19:43,487 --> 00:19:48,095
这个f303它的输出是office iterator

320
00:19:49,119 --> 00:19:54,495
比较特别一点啊所有的容器内没有一个operator

321
00:19:55,263 --> 00:19:57,311
你看它这边的输出没有一个是

322
00:19:57,823 --> 00:20:00,383
只有这个区市区里的位置

323
00:20:01,151 --> 00:20:03,967
他是一个operator

324
00:20:07,039 --> 00:20:08,319
我们后面会

325
00:20:09,087 --> 00:20:11,647
有专门的投影片专门来讲这两个东西

326
00:20:11,903 --> 00:20:13,183
很有趣

327
00:20:13,695 --> 00:20:16,255
特别的东西

328
00:20:25,471 --> 00:20:31,615
刚刚我是根据五个分类自己打印出一些字串字符数

329
00:20:31,871 --> 00:20:32,895
串来表现

330
00:20:33,663 --> 00:20:35,711
Iterator迭代器的名称

331
00:20:37,247 --> 00:20:40,831
是我自己准备的那些名称那些字母上打去

332
00:20:42,367 --> 00:20:45,439
有没有可能不要我自己这样准备了

333
00:20:46,975 --> 00:20:47,999
换句话说

334
00:20:49,279 --> 00:20:52,095
一个类型type

335
00:20:52,863 --> 00:20:55,423
他本身有没有办法去

336
00:20:56,703 --> 00:21:01,567
去就不要经过我们自己使用者的加工

337
00:21:01,823 --> 00:21:03,103
刘道涵的名称

338
00:21:04,895 --> 00:21:06,175
我看这页

339
00:21:08,223 --> 00:21:11,295
我要利用Siri有个东西叫type_id

340
00:21:12,831 --> 00:21:18,976
这个菜吧爱的你要用他的话的你必须函数这个它的应付这一个头文件

341
00:21:19,232 --> 00:21:23,840
利用卡还可以打印出一些那个类型的名称给我看

342
00:21:24,352 --> 00:21:24,864
好

343
00:21:25,120 --> 00:21:27,936
看看这个罪业这里

344
00:21:28,192 --> 00:21:30,496
就是上午夜的这一块

345
00:21:31,520 --> 00:21:33,568
这个函数的bistro category

346
00:21:34,080 --> 00:21:38,176
下一页这里也是觉的spread category是一样的

347
00:21:42,528 --> 00:21:46,112
但是在这一夜我多做了一件事

348
00:21:46,624 --> 00:21:49,952
再看一次上夜散射进去之后是这两个

349
00:21:51,232 --> 00:21:56,096
职业的进来之后一样的这两个然后我多做下面一件事情

350
00:21:56,608 --> 00:21:59,936
这个下面看起来很多其实都是注解只有一行

351
00:22:00,960 --> 00:22:06,336
是什么那我把放进来的iterator参数在这里

352
00:22:07,360 --> 00:22:08,128
Twitter

353
00:22:08,384 --> 00:22:09,664
放到type

354
00:22:09,920 --> 00:22:12,992
等一下这个只是说出真正到处在后面

355
00:22:13,504 --> 00:22:19,648
放到type_id去这太不爱丽丝cplusplus提供的一个你可以说它是一个操作符

356
00:22:19,904 --> 00:22:21,184
不好的

357
00:22:21,440 --> 00:22:26,304
这样子下去龙他好了你把一个太后放到里头去

358
00:22:26,816 --> 00:22:29,888
放进去之后得到了一个对象

359
00:22:30,144 --> 00:22:34,752
而且你可以通过这个RT调用name

360
00:22:36,032 --> 00:22:42,176
这就是新家家编译器本身对于传进来的这个菜的命

361
00:22:42,432 --> 00:22:43,968
命令他就会唱给你

362
00:22:46,016 --> 00:22:47,296
我们就这么做了

363
00:22:48,064 --> 00:22:51,648
学习一下睡觉加语言本身的提供的这个东西

364
00:22:52,160 --> 00:22:54,208
你要记得要含入这个头文件

365
00:22:57,280 --> 00:23:03,424
好得到的结果那就是右边王色圈起来这个是已经非常小了看不清楚

366
00:23:03,680 --> 00:23:07,264
我要看你付给你的这个讲义了

367
00:23:08,800 --> 00:23:11,360
是些什么东西他的名声是什么

368
00:23:11,616 --> 00:23:14,432
随便拿一个来看好了

369
00:23:14,944 --> 00:23:17,504
这个这个叫best interest

370
00:23:18,016 --> 00:23:20,832
这个能说着啊必驰iterator

371
00:23:21,344 --> 00:23:23,648
它的名称是这样蛮不错的

372
00:23:24,160 --> 00:23:26,464
但是每一个名称前面还会大呀

373
00:23:26,720 --> 00:23:32,864
一些奇怪的字怎么star3 sc17后面还会带一些奇奇怪怪都看不懂

374
00:23:33,376 --> 00:23:34,144
符号

375
00:23:35,936 --> 00:23:40,288
这边是顺在传达一点这算是题外话

376
00:23:40,800 --> 00:23:42,080
一个菜谱

377
00:23:42,592 --> 00:23:45,664
比如说一个他那啥了你给他命名叫ABC

378
00:23:47,200 --> 00:23:52,832
星期天他编完之后呢他这个不叫ABC的角abc前面还会

379
00:23:53,088 --> 00:23:53,856
多加一些

380
00:23:54,624 --> 00:23:57,696
文数字后面会多加一些文数字

381
00:23:58,464 --> 00:24:04,608
这是编译过程中的一些新增加的东西他还是代表ABC这个类

382
00:24:04,864 --> 00:24:05,888
这个class

383
00:24:06,144 --> 00:24:10,752
20名称略略有点不同这就是你的这边黄色所看到的

384
00:24:11,008 --> 00:24:12,544
这些命名字

385
00:24:13,568 --> 00:24:18,688
这就不是我们自己准备的了我想上页打印出来是我所准备的故事

386
00:24:21,248 --> 00:24:27,392
最近左手边准备一大堆筑节令的时候什么那是一个output

387
00:24:28,160 --> 00:24:32,000
Depend on取决于libraries现

388
00:24:32,512 --> 00:24:34,304
不同的Library

389
00:24:34,816 --> 00:24:39,168
总理头对于这一些类type

390
00:24:39,424 --> 00:24:40,448
邓铃铛

391
00:24:41,472 --> 00:24:45,824
主要名称一定是一样的红黑树的

392
00:24:46,080 --> 00:24:48,640
Hashtable的iterator的

393
00:24:49,152 --> 00:24:54,528
主要名称一样但是前后附加的那些取决于library的实现

394
00:24:56,320 --> 00:25:02,464
所以他穿回来就是是什么呢也能培训会

395
00:25:02,720 --> 00:25:08,864
是由实现的这个版本来定义信息传回来的不一样汉登录新的不一样

396
00:25:09,120 --> 00:25:10,400
IPhone SE也不一样

397
00:25:11,680 --> 00:25:17,824
但我们到我们的重点只是用这样的输出来

398
00:25:18,080 --> 00:25:18,592
加深

399
00:25:18,848 --> 00:25:21,408
我们对于

400
00:25:22,944 --> 00:25:23,712
每一个

401
00:25:24,224 --> 00:25:26,016
类型type

402
00:25:27,040 --> 00:25:28,832
Faker

403
00:25:29,344 --> 00:25:31,648
验证码

404
00:25:40,864 --> 00:25:41,888
刚刚提到

405
00:25:42,144 --> 00:25:44,704
在这么多的输出这么多的

406
00:25:45,728 --> 00:25:49,568
Iterator迭代器的分类category分类里头

407
00:25:50,336 --> 00:25:54,944
有两个很特别一个查询

408
00:25:55,712 --> 00:25:58,784
下一页这个搜寻Twitter

409
00:25:59,040 --> 00:26:02,880
这两个故事很多我们后面会专门来讲

410
00:26:03,136 --> 00:26:08,000
不过这两页那我把它源代码最重要的部分抓出来给你看

411
00:26:09,280 --> 00:26:10,816
这是2.9吧

412
00:26:11,072 --> 00:26:16,704
这是3.3吧这个是4.9吧他们的做法都不太一样我就

413
00:26:16,960 --> 00:26:18,752
一口气也都抓出来给你看

414
00:26:21,312 --> 00:26:24,128
这个是这个东西

415
00:26:26,176 --> 00:26:28,224
这也跟下雨的这两个东西

416
00:26:29,760 --> 00:26:31,296
C标准库

417
00:26:31,552 --> 00:26:32,832
规格书有记载

418
00:26:34,112 --> 00:26:36,672
所以在不同的

419
00:26:37,952 --> 00:26:40,256
标准库的版本地图

420
00:26:41,024 --> 00:26:45,888
我刚刚说他做法都不同但是绝对不可以影响其口

421
00:26:47,936 --> 00:26:50,752
因为这是规格书上有写的你要接口不

422
00:26:51,008 --> 00:26:52,032
一样的话

423
00:26:52,544 --> 00:26:54,080
使用者就头痛了

424
00:26:54,848 --> 00:27:00,480
我们来看一下这个ostream_iterator还有两个模板参数

425
00:27:01,760 --> 00:27:02,784
这个版本呢

426
00:27:03,040 --> 00:27:06,112
四个模板参数接口就不一样了

427
00:27:06,880 --> 00:27:09,440
但是第3根B是有默认值

428
00:27:12,768 --> 00:27:16,352
新版本这个的最新版本的4.9这个呢

429
00:27:16,864 --> 00:27:19,680
非常新的版本他也是四个模板参数

430
00:27:21,728 --> 00:27:23,520
跟3.3一样

431
00:27:24,544 --> 00:27:26,592
他底下的做法又略有不同

432
00:27:27,872 --> 00:27:30,432
最重要的是接口一样

433
00:27:30,688 --> 00:27:33,760
这是必要条件这倒是符合的

434
00:27:35,808 --> 00:27:41,952
好在这里头我想带大家看看就是我们前面看的这个输出结果后面这两个

435
00:27:42,208 --> 00:27:45,280
Input output iterative这个输出结果

436
00:27:45,792 --> 00:27:47,072
是怎么来的

437
00:27:47,328 --> 00:27:50,400
现在才正式extreme iterator

438
00:27:50,656 --> 00:27:54,496
This is treated with a little time

439
00:27:54,752 --> 00:27:56,544
说我的分类

440
00:27:56,800 --> 00:27:57,824
这四种东西

441
00:27:58,592 --> 00:28:01,664
阿里头就明确的定义它自己的分类就是这样

442
00:28:03,456 --> 00:28:05,760
当然输出就是这样了

443
00:28:08,576 --> 00:28:13,184
这是这个版本这个版本也是一样新版本也是一样

444
00:28:14,208 --> 00:28:16,256
这么更新的版本呢

445
00:28:17,024 --> 00:28:23,168
虽然有一点点不同啊你可以看到他这个这个东西先

446
00:28:23,680 --> 00:28:25,216
交给他

447
00:28:25,728 --> 00:28:27,008
绿色的这一个

448
00:28:27,520 --> 00:28:28,800
而这一个呢

449
00:28:29,568 --> 00:28:31,872
我把它的源代码超出来在上头

450
00:28:32,640 --> 00:28:35,200
你只要停止下来沿着

451
00:28:35,712 --> 00:28:37,248
我画的这个虚线

452
00:28:37,504 --> 00:28:38,272
看一遍

453
00:28:40,320 --> 00:28:42,112
你就会感受其实

454
00:28:42,880 --> 00:28:44,672
比较新的这个版本

455
00:28:45,184 --> 00:28:49,280
在这一部分的作为和旧的版本都一样

456
00:28:50,560 --> 00:28:51,584
一样什么

457
00:28:52,352 --> 00:28:54,912
他们都在定义他们自己的

458
00:28:55,936 --> 00:28:57,472
分类category

459
00:28:59,008 --> 00:28:59,776
Category

460
00:29:01,056 --> 00:29:02,080
还有这里呢

461
00:29:02,336 --> 00:29:03,360
这个category

462
00:29:03,616 --> 00:29:04,128
是什么

463
00:29:04,384 --> 00:29:06,688
Input

464
00:29:08,992 --> 00:29:09,760
就是这个输出

465
00:29:14,624 --> 00:29:16,672
这边介绍一个比较奇特的

466
00:29:16,928 --> 00:29:23,072
形势和旺季的第2讲有没有出现过这一类的行

467
00:29:23,328 --> 00:29:24,352
是啊不过

468
00:29:24,608 --> 00:29:28,704
在第3讲后面谈其他的事情也会出现这种形式

469
00:29:30,240 --> 00:29:31,264
什么形式呢

470
00:29:32,544 --> 00:29:33,824
一个继承关系

471
00:29:35,872 --> 00:29:37,408
父类是谁呢

472
00:29:38,176 --> 00:29:40,480
富勒只是一些地方

473
00:29:40,992 --> 00:29:42,272
没有Beta

474
00:29:42,528 --> 00:29:44,064
没有方式

475
00:29:47,136 --> 00:29:50,976
这样的话下面这个继承上面

476
00:29:51,232 --> 00:29:52,768
等同于

477
00:29:53,024 --> 00:29:55,840
等同于下面这个词那

478
00:29:56,864 --> 00:29:58,912
拥有了

479
00:30:01,216 --> 00:30:06,336
这样的继承关系为的就是这个事情他寄存下去

480
00:30:07,616 --> 00:30:09,152
你曾是少打几个字

481
00:30:10,176 --> 00:30:11,456
纯粹只是想

482
00:30:15,040 --> 00:30:18,880
好的也都知道这里这个是S3 Twitter

483
00:30:19,136 --> 00:30:21,952
下一页是一群怎么样

484
00:30:22,464 --> 00:30:28,608
我这个不取正义的布局的商业完全一样看我有三个版本2.93件34.9

485
00:30:30,144 --> 00:30:31,680
这三个版本

486
00:30:32,192 --> 00:30:37,568
重要的事情在目前这一页所中药要谈的事情是他们对于

487
00:30:37,824 --> 00:30:38,592
自己的

488
00:30:39,360 --> 00:30:41,664
Iterator的分类

489
00:30:42,176 --> 00:30:43,200
定义

490
00:30:43,456 --> 00:30:44,736
Support

491
00:30:44,992 --> 00:30:45,760
Office

492
00:30:46,272 --> 00:30:47,040
Open

493
00:30:48,064 --> 00:30:49,344
在这里的输出是

494
00:30:49,600 --> 00:30:50,880
好吧

495
00:30:55,488 --> 00:31:01,632
在这一个输出结果里面前面这一些全部都是容器所提供的迭代

496
00:31:01,888 --> 00:31:08,032
大气的分类只有下面这两个是比较特别的所以我用这两页来谈

497
00:31:08,288 --> 00:31:08,800
他
