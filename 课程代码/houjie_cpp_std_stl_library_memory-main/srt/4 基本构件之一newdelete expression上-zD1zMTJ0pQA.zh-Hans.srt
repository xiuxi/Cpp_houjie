1
00:00:02,048 --> 00:00:04,096
通过这四样东西之后

2
00:00:04,608 --> 00:00:06,400
我们来看看前面那张图

3
00:00:07,168 --> 00:00:07,936
这张图

4
00:00:10,240 --> 00:00:12,288
为什么我敢说

5
00:00:13,312 --> 00:00:14,592
使用宁

6
00:00:15,104 --> 00:00:17,664
或者使用offset那我们刚才用过它

7
00:00:18,688 --> 00:00:22,016
为什么我敢说他其实底下是个有没有

8
00:00:22,528 --> 00:00:27,136
我们刚刚使用过的应用过operator new也用过没老婆

9
00:00:28,672 --> 00:00:32,768
现在我要引导你去看看这些这三者有什么关系

10
00:00:35,584 --> 00:00:36,608
所以刚刚

11
00:00:36,864 --> 00:00:39,680
看到这一画面往下看

12
00:00:41,472 --> 00:00:41,984
宁

13
00:00:43,776 --> 00:00:46,592
你的你又有多少理解父亲一下

14
00:00:47,616 --> 00:00:50,432
你在陆后面应该加上克拉斯

15
00:00:51,968 --> 00:00:55,808
你陆他的意思是现在语言告诉你

16
00:00:56,320 --> 00:00:57,600
你会做什么动作呢

17
00:00:58,624 --> 00:01:00,928
它会先分配一块内存

18
00:01:01,952 --> 00:01:03,488
准备来放extract

19
00:01:05,280 --> 00:01:07,584
分配好之后它会帮你调用

20
00:01:07,840 --> 00:01:10,400
构造函数的构造函数会自动被这样起来

21
00:01:11,168 --> 00:01:13,984
而所谓自动被调用就是被怒调用的

22
00:01:15,008 --> 00:01:20,128
你有做两个动作的一个分片内存分配好之后调用构造函数

23
00:01:21,664 --> 00:01:24,736
这两个动作我现在把表现在这里

24
00:01:25,760 --> 00:01:28,576
我说我要另一个负数

25
00:01:29,600 --> 00:01:35,744
注意这个负数这里是大写的C不是标准库那一个我只是拿来表现着我自己写的一个故事

26
00:01:36,000 --> 00:01:38,048
所以它不是一个模仿

27
00:01:39,328 --> 00:01:42,400
我们也不必看它的源代码这个不重要

28
00:01:43,168 --> 00:01:49,312
我去另外一个这个东西得到一根指针向这一行这个名叫做

29
00:01:49,568 --> 00:01:51,616
表达式

30
00:01:52,640 --> 00:01:58,784
被编译器可以看成什么转化为什么呢这是一个是一个

31
00:01:59,040 --> 00:01:59,552
一个

32
00:02:00,832 --> 00:02:02,880
一个表达方式和他真正

33
00:02:03,136 --> 00:02:09,280
也许他优化了会有其他怎么样不过他所做的事情我们可以用cplusplus语言用作三

34
00:02:11,328 --> 00:02:13,120
由于这里有分配内存

35
00:02:13,376 --> 00:02:19,008
所以他必须Tequila必须是关心到万一失败怎么办所以这里有一个try catch

36
00:02:20,288 --> 00:02:22,592
看看万一有异常发生的话

37
00:02:23,872 --> 00:02:26,688
我们注意看这个123

38
00:02:28,736 --> 00:02:30,528
第1个动作他要分配内存

39
00:02:31,552 --> 00:02:32,320
动作

40
00:02:33,088 --> 00:02:34,112
这是调用

41
00:02:34,368 --> 00:02:35,648
这一个

42
00:02:37,440 --> 00:02:41,280
试着去用过这个函数吗

43
00:02:42,560 --> 00:02:44,352
这个还是就是在分配内存

44
00:02:44,864 --> 00:02:47,424
我刚刚我们家的是全局的那个

45
00:02:48,192 --> 00:02:49,728
有两个双冒号看一下

46
00:02:50,240 --> 00:02:51,008
打开呀

47
00:02:51,520 --> 00:02:52,544
就是这个

48
00:02:54,080 --> 00:02:55,616
而这一个函数

49
00:02:55,872 --> 00:02:58,176
如果再往前看那个表格的话

50
00:02:58,688 --> 00:03:02,528
这一个函数它是可以被重载的

51
00:03:02,784 --> 00:03:03,552
和

52
00:03:05,088 --> 00:03:06,880
现在回到这里来

53
00:03:07,904 --> 00:03:08,672
所以

54
00:03:08,928 --> 00:03:13,280
它调用这个函数万一这个函数被你重新定义了

55
00:03:13,536 --> 00:03:15,328
就会跑到你那边去

56
00:03:16,864 --> 00:03:20,960
一般我们先讲没有没有定义就这个故事

57
00:03:21,472 --> 00:03:22,496
这个类

58
00:03:22,752 --> 00:03:24,544
有没有去重载这一个

59
00:03:25,824 --> 00:03:26,592
所以

60
00:03:27,104 --> 00:03:32,992
飞行一行那就自然然的调用到全局的那个版本萝卜的那个版本

61
00:03:35,040 --> 00:03:37,600
这里我拿了一条线然后处理

62
00:03:38,112 --> 00:03:39,904
其实他是有源代码

63
00:03:40,672 --> 00:03:42,720
这个源代码我是在

64
00:03:42,976 --> 00:03:48,096
这边VC酒吧的crtc runtime Library

65
00:03:48,352 --> 00:03:49,632
里头的source

66
00:03:49,888 --> 00:03:52,704
人在马里面这里找得到

67
00:03:53,472 --> 00:03:55,520
在我整个课程里面帮我在

68
00:03:56,032 --> 00:03:59,616
抓一些关键元在忙的时候我都尽可能的

69
00:03:59,872 --> 00:04:03,456
会跑它是在哪一个文件名成打出来

70
00:04:03,968 --> 00:04:05,760
这样如果你自己要去找

71
00:04:06,016 --> 00:04:07,552
就很容易找得到

72
00:04:08,832 --> 00:04:11,904
好123的一是要分配内存

73
00:04:12,160 --> 00:04:15,488
而这个函数我找到了它的源代码在这里

74
00:04:17,024 --> 00:04:20,095
里头最重要的是我们终于观察到她交流没了

75
00:04:21,887 --> 00:04:26,751
所以我敢说生一个函数其实就等同于没落

76
00:04:27,263 --> 00:04:29,823
真正分配内存是靠没落座

77
00:05:10,015 --> 00:05:11,807
用一个指针把技巧

78
00:05:13,087 --> 00:05:15,903
这个动作是把这个指针转型

79
00:05:17,951 --> 00:05:24,095
不想要转行卖衣服合并使用16的时候是要得到的是这种植

80
00:05:25,375 --> 00:05:26,911
给他做一个短信

81
00:05:28,447 --> 00:05:30,239
就是一根2k合在一起

82
00:05:30,495 --> 00:05:34,079
这个我只是一个表现的形式让你

83
00:05:34,335 --> 00:05:35,615
看得很清楚

84
00:05:37,919 --> 00:05:38,687
之后呢

85
00:05:39,967 --> 00:05:44,319
我们最牛的理解不是再来不是就是要调用构造函数吗

86
00:05:45,087 --> 00:05:45,599
是的

87
00:05:45,855 --> 00:05:47,135
但这个地方

88
00:05:47,647 --> 00:05:49,951
通过这个指针

89
00:05:50,719 --> 00:05:51,999
调用构造函数

90
00:05:52,255 --> 00:05:54,559
这就是构造函数的写法

91
00:05:56,863 --> 00:06:01,983
构造函数的名称要跟类的名称相同你现在是要拧complex

92
00:06:02,239 --> 00:06:04,543
所以就在compass muhammad好看的气

93
00:06:04,799 --> 00:06:06,079
这就是构造函数

94
00:06:08,127 --> 00:06:08,639
这个

95
00:06:08,895 --> 00:06:09,919
充值吗

96
00:06:10,687 --> 00:06:14,527
编译器做了所以他一看你的数字是1298存进了

97
00:06:17,343 --> 00:06:19,903
调用构造函数需要指针

98
00:06:22,463 --> 00:06:24,255
这就是1236的东西

99
00:06:26,815 --> 00:06:28,351
我下面有一句说明

100
00:06:29,375 --> 00:06:33,983
这种直接调用构造函数的动作你是不可以做的

101
00:06:36,543 --> 00:06:37,823
后面我会写一个

102
00:06:38,591 --> 00:06:39,359
测试程序

103
00:06:40,127 --> 00:06:41,663
下下一页就会出现

104
00:06:42,687 --> 00:06:44,735
你看到我想模拟这个动作

105
00:06:47,295 --> 00:06:48,831
我又惊又喜

106
00:06:49,599 --> 00:06:50,879
后来又沮丧

107
00:06:52,415 --> 00:06:54,975
因为一开始竟然通过了

108
00:06:56,255 --> 00:06:57,023
我很高兴

109
00:06:58,303 --> 00:06:59,583
那个星期六

110
00:07:00,095 --> 00:07:02,911
后来在不同的宾利平台上了

111
00:07:03,167 --> 00:07:03,935
失败了

112
00:07:04,959 --> 00:07:05,727
可见

113
00:07:06,239 --> 00:07:07,775
能不能这样写

114
00:07:08,031 --> 00:07:08,799
不一定

115
00:07:09,567 --> 00:07:10,079
确定

116
00:07:11,871 --> 00:07:14,175
好这是后话我先摆着

117
00:07:15,967 --> 00:07:20,319
所以你有74 123或者说重要的是113

118
00:07:20,575 --> 00:07:21,343
13

119
00:07:21,855 --> 00:07:27,999
一次分配内存30个多少数和分配内存这一件事情看到它的原石

120
00:07:31,327 --> 00:07:36,191
让我们终于非常清楚的理解所谓的New expression

121
00:07:37,471 --> 00:07:39,263
行为模式了

122
00:07:42,335 --> 00:07:43,871
这边还有一段说明

123
00:07:44,639 --> 00:07:45,407
如果

124
00:07:46,175 --> 00:07:48,479
不可以这样直接调用吗

125
00:07:49,503 --> 00:07:53,599
PCB下可以那是一个算是他不太严谨吧

126
00:07:56,415 --> 00:07:59,999
可不可以这么做该怎么做呢在下面的说明

127
00:08:00,255 --> 00:08:02,815
这边是用到没什么命

128
00:08:03,327 --> 00:08:04,095
目前

129
00:08:04,607 --> 00:08:07,679
我相信你对person有人会是很陌生

130
00:08:07,935 --> 00:08:09,215
它的形式是这样

131
00:08:10,239 --> 00:08:12,287
这个话题我们的后头上的时候

132
00:08:13,311 --> 00:08:15,103
我们现在才能是一般的命

133
00:08:15,871 --> 00:08:18,687
Chris Monroe是后头加一个括号

134
00:08:18,943 --> 00:08:20,735
这个形式不太一样

135
00:08:23,039 --> 00:08:28,927
所以这里的重点就是另有其实是一个分配和那个天然构造函数

136
00:08:29,183 --> 00:08:30,975
非常清楚

137
00:08:33,023 --> 00:08:35,327
现在我们把重点移到右上角来

138
00:08:37,887 --> 00:08:44,031
从这个源代码有带给你一个观念也许你曾经你已经有过这个观念

139
00:08:44,287 --> 00:08:45,567
这个源代码可以证明

140
00:08:46,335 --> 00:08:47,615
具体的验证到

141
00:08:49,151 --> 00:08:51,455
这一个函数里头

142
00:08:51,967 --> 00:08:53,247
有一个loop

143
00:08:53,759 --> 00:08:56,319
他不断的在调用

144
00:08:56,831 --> 00:08:57,855
做什么事情

145
00:08:58,111 --> 00:08:58,623
他在

146
00:08:58,879 --> 00:09:00,671
近来就调用malloc

147
00:09:01,439 --> 00:09:02,975
如果成功呢

148
00:09:03,231 --> 00:09:04,767
如果成功课就不等于零

149
00:09:05,535 --> 00:09:06,559
这个就跳出来

150
00:09:06,815 --> 00:09:08,351
回到这里就结束了

151
00:09:08,607 --> 00:09:09,887
OK到了一块内存

152
00:09:10,655 --> 00:09:12,447
但如果失败呢

153
00:09:13,983 --> 00:09:15,007
等雨停了

154
00:09:15,775 --> 00:09:17,055
见到下面来了

155
00:09:18,591 --> 00:09:24,735
下面坐什么是70什么作为失败你很难去碰到这个问题你的

156
00:09:24,991 --> 00:09:29,855
电脑里面也许安装的那个内存条啊安装了好几个byte

157
00:09:30,367 --> 00:09:31,391
那么多

158
00:09:32,159 --> 00:09:38,303
所以这种情况是发生在大量耗用内存之后最后终于你有一次要

159
00:09:38,559 --> 00:09:40,863
你有一个东西的时候

160
00:09:41,375 --> 00:09:42,911
跑到里面的跑到这里来

161
00:09:43,423 --> 00:09:44,191
要不到了

162
00:09:44,959 --> 00:09:48,543
这种情况是非这个

163
00:09:49,823 --> 00:09:51,615
不是你平常会碰到的

164
00:09:52,895 --> 00:09:55,455
不过如果真的发生这种事情的话

165
00:09:55,711 --> 00:09:56,991
你还做什么事

166
00:09:58,527 --> 00:10:00,319
Whitby的版本

167
00:10:01,599 --> 00:10:02,879
其实在其他的

168
00:10:03,135 --> 00:10:04,671
平台上

169
00:10:05,951 --> 00:10:10,559
这个crtc runtime library他们的行为都差不多

170
00:10:11,071 --> 00:10:13,375
我们也没有必要把每个版本都能给你看

171
00:10:13,887 --> 00:10:16,191
这个都足够代表笔记

172
00:10:17,727 --> 00:10:19,007
哈里都做什么事呢

173
00:10:19,519 --> 00:10:21,823
他就调用和六h

174
00:10:23,103 --> 00:10:26,687
这个叫做调用New standard

175
00:10:27,967 --> 00:10:32,831
New handler是一种你可以设定的行数

176
00:10:33,343 --> 00:10:35,135
你设定好之后

177
00:10:35,647 --> 00:10:41,791
如果这边malloc失败就会来调用你设定的那个那个叫牛天

178
00:10:43,839 --> 00:10:45,631
这个主题我们的后面会谈

179
00:10:47,167 --> 00:10:52,799
那在你设定那个女孩这里头你现在终于知道原来是这么被使用的

180
00:10:53,055 --> 00:10:55,615
可见你应该在那个地方

181
00:10:56,127 --> 00:10:57,663
去释放内存

182
00:10:58,175 --> 00:11:04,319
为什么那一遍这个路口再回来的时候可以在调用没了吧看看会被成功

183
00:11:06,367 --> 00:11:11,487
也就是说当山穷水尽把内存都用光的时候

184
00:11:11,999 --> 00:11:16,095
他会来调用你设的一个函数时的呢

185
00:11:16,351 --> 00:11:17,631
有机会

186
00:11:18,143 --> 00:11:19,935
释放掉一些你认为

187
00:11:20,191 --> 00:11:21,471
可以释放掉的

188
00:11:21,983 --> 00:11:25,567
然后回到这里来他下一次在该用就会成功

189
00:11:26,847 --> 00:11:30,175
这是他设的一个机制cplusplus的一个机制

190
00:11:31,199 --> 00:11:33,759
后面会去谈什么叫年的了

191
00:11:37,599 --> 00:11:39,391
另外再看看事业

192
00:11:39,647 --> 00:11:42,719
这边可能有一些眼睛很尖的话呢

193
00:11:42,975 --> 00:11:47,327
XP的话你可能会看到

194
00:11:47,839 --> 00:11:51,679
我们在上一页的直接调用情况下

195
00:11:51,935 --> 00:11:54,239
Operation in the city

196
00:11:54,495 --> 00:11:56,287
我们就放一个参数吗

197
00:11:58,335 --> 00:12:02,431
现在这个源代码了它不但有这个参数大小

198
00:12:02,687 --> 00:12:04,223
他还有第2个参数

199
00:12:04,479 --> 00:12:06,783
这个是我刚刚讲的那一个吗

200
00:12:09,855 --> 00:12:10,623
不是

201
00:12:11,647 --> 00:12:12,159
不是

202
00:12:12,927 --> 00:12:13,695
不过

203
00:12:14,207 --> 00:12:15,743
里头做的事情是一样的

204
00:12:16,511 --> 00:12:21,631
我在找人代码准备要认真一些事情的时候我找到了这个我认为足够了

205
00:12:21,887 --> 00:12:23,167
我就没有再往下去

206
00:12:23,935 --> 00:12:27,519
这个第2参数做什么事情他就是no problem

207
00:12:28,799 --> 00:12:30,079
跟一层的

208
00:12:30,335 --> 00:12:32,895
抛出有关他是不抛异常的

209
00:12:33,151 --> 00:12:36,735
关于这个东西的注解的下面这里

210
00:12:38,783 --> 00:12:42,623
意思是说这一个函数是保证不跑一场

211
00:12:44,927 --> 00:12:45,951
在cplusplus

212
00:12:46,207 --> 00:12:52,351
11c家2011或者叫做6Plus 2.0里头对于一个函数不抛射

213
00:12:52,607 --> 00:12:53,375
异常

214
00:12:54,143 --> 00:12:56,191
可以不必这么写换一种

215
00:12:56,703 --> 00:12:57,983
正规的写法

216
00:12:58,239 --> 00:13:00,799
这个都无所谓了这不是我们现在的重点

217
00:13:03,359 --> 00:13:08,479
好这就是我们对牛的理解牛expiration的理解

218
00:13:08,991 --> 00:13:11,807
那么相对应的他的兄弟就是肯定的了

219
00:13:12,063 --> 00:13:14,111
Illustration
