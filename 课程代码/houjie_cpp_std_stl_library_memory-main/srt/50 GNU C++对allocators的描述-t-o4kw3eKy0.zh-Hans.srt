1
00:00:00,256 --> 00:00:06,400
现在我们来进行内存管理的

2
00:00:06,656 --> 00:00:12,800
第5讲我这个病无讲the operations就是其他的主题我们前面谈过了

3
00:00:13,056 --> 00:00:19,200
一些细节的语言层次的然后是分配器然后是malloc最底

4
00:00:19,456 --> 00:00:20,992
然后是

5
00:00:21,248 --> 00:00:24,576
市面上有一个我认为很棒的分配器loki

6
00:00:24,832 --> 00:00:29,952
然后就是这个其他的主题我要谈的是什么呢我其实

7
00:00:30,464 --> 00:00:31,744
主要就是违规

8
00:00:32,000 --> 00:00:35,072
介绍这个人物的笔下的

9
00:00:35,328 --> 00:00:36,864
其他的分配器

10
00:00:37,376 --> 00:00:40,192
可同时提供了很多的分配器给我们

11
00:00:40,448 --> 00:00:46,592
当然怎么去挑选他去吃去挑选一个来用这个重要呢你要去挑选他吗

12
00:00:46,848 --> 00:00:49,920
当然你必须了解你才能够下决定

13
00:00:50,688 --> 00:00:54,528
那么如果你不是在跟61这个平台下gcd

14
00:00:54,784 --> 00:00:58,880
Gcc家家这个平台下的其他的

15
00:00:59,648 --> 00:01:01,440
这个sip平台下

16
00:01:01,952 --> 00:01:08,096
当然你就得不到这些东西不过这个人UC他是免费的说明仍然可以去下载一份这些

17
00:01:08,352 --> 00:01:12,704
且版本学习其中的技巧然后

18
00:01:12,960 --> 00:01:15,008
可以加强在你自己的

19
00:01:15,264 --> 00:01:16,288
云平台上面

20
00:01:17,824 --> 00:01:18,592
好

21
00:01:19,104 --> 00:01:25,248
1首先我们认识这个本公司以下他给我们的这一些额外的

22
00:01:25,504 --> 00:01:31,392
标准之外的这些分配器放在什么地方呢他的源代码放在什么地方

23
00:01:32,160 --> 00:01:33,440
先前我曾经

24
00:01:33,696 --> 00:01:39,840
在美国这样的信息就是在给moussy我给我现在谈的是4.9个非常新的吧

25
00:01:40,096 --> 00:01:41,632
版本

26
00:01:42,144 --> 00:01:44,448
你下你在这个目录之下

27
00:01:44,960 --> 00:01:46,240
这个目录之下

28
00:01:46,496 --> 00:01:50,336
这里面有一个Beats有一个xing extension

29
00:01:50,848 --> 00:01:56,992
那我们谈的主要是exploration之下这个地址之下的就是这些

30
00:01:57,248 --> 00:02:01,344
他的STL的一些容器的算法了

31
00:02:01,600 --> 00:02:02,112
的

32
00:02:02,624 --> 00:02:04,416
重要的头文件在这里头

33
00:02:05,440 --> 00:02:10,816
好xtension这里那我现在拉开了我用比较大的画面告诉各位

34
00:02:13,376 --> 00:02:17,728
Allocator为结尾的这些头文件

35
00:02:17,984 --> 00:02:22,080
有没看到有这一些123456789

36
00:02:22,336 --> 00:02:23,616
九个

37
00:02:23,872 --> 00:02:27,200
九个但我不会全不谈谈我谈

38
00:02:27,456 --> 00:02:32,832
我记得这七个把大会我们进去就会看到我记得我要看的是七个

39
00:02:33,088 --> 00:02:35,648
好我们现在接下去看

40
00:02:35,904 --> 00:02:38,720
所以你也可以到这里了头文件来

41
00:02:38,976 --> 00:02:42,048
找出来我要谈的这一些

42
00:02:42,560 --> 00:02:44,096
这些分配器

43
00:02:46,656 --> 00:02:52,800
首先会看到我在尿液以及我现在很快的翻过好几页你会看到我安排什么东西

44
00:02:53,056 --> 00:02:56,128
下1页下1页下1页下1页

45
00:02:56,384 --> 00:03:02,528
下一页好这些全部都是同样的一个标题我拿个木

46
00:03:02,784 --> 00:03:08,928
下面的对于分配其他有他的官方文件的说明并且加上我的音

47
00:03:09,184 --> 00:03:10,976
哪些事让你更

48
00:03:11,232 --> 00:03:16,608
加上这些解释你更能清楚他在谈什么事情所以我们要把这些文字

49
00:03:16,864 --> 00:03:17,632
走一遍

50
00:03:18,912 --> 00:03:25,056
他是这么想的当你将元素加入容器中间为什么谈到荣幸因为

51
00:03:25,312 --> 00:03:29,152
分配器就是为容器服务的我们钱的早就谈过了太多次

52
00:03:29,408 --> 00:03:34,784
容器必须分配更多的妹子们才能够保存这些元素

53
00:03:35,040 --> 00:03:39,904
于是他们向习模板参数locator发出申请

54
00:03:40,160 --> 00:03:42,464
这里之所以这样讲是相册

55
00:03:42,976 --> 00:03:44,256
这个是三个荣幸

56
00:03:44,512 --> 00:03:47,328
他的的模板参数多少都可以的就是这个

57
00:03:48,352 --> 00:03:51,424
于是要向他发出申请的他就是分配器

58
00:03:51,680 --> 00:03:53,472
这个模板参数

59
00:03:53,728 --> 00:03:55,776
往往被命名为

60
00:03:56,032 --> 00:03:57,056
这一个

61
00:03:57,568 --> 00:03:59,616
名名名名称

62
00:03:59,872 --> 00:04:02,432
北京外也就是说这1

63
00:04:03,712 --> 00:04:06,016
名称乐在这些容器里头

64
00:04:06,528 --> 00:04:12,160
会用他的饭的方式另外换一个名字叫allocated往往会

65
00:04:12,416 --> 00:04:13,184
怎么做

66
00:04:13,696 --> 00:04:15,488
不过这个现在的主题无关

67
00:04:16,256 --> 00:04:22,399
这里提到甚至于你将事物添加到子串字符串的头也是这个样

68
00:04:22,655 --> 00:04:27,007
也就是说字符串也是一个正规的容器

69
00:04:27,775 --> 00:04:33,407
怎么正规的容器就是它提供了容器该有的那些

70
00:04:33,919 --> 00:04:34,687
好处

71
00:04:35,711 --> 00:04:39,807
它的接口对外的接口就是容器的接口

72
00:04:40,319 --> 00:04:42,623
字符串和正义算是一个

73
00:04:43,135 --> 00:04:48,255
我们去往下看每个元素类型为7这一种容器

74
00:04:49,535 --> 00:04:52,607
他的allocator这个参数只是这个

75
00:04:53,375 --> 00:04:58,495
被默认为默认为这个东西所以这个就是标

76
00:04:58,751 --> 00:04:59,519
准的

77
00:05:00,287 --> 00:05:01,311
也就是这里

78
00:05:03,103 --> 00:05:05,151
这个东西它有默认值

79
00:05:05,919 --> 00:05:10,015
我们等下就会看到我会带你去看一看这个东西的实现

80
00:05:11,039 --> 00:05:13,343
这个东西的接口

81
00:05:13,599 --> 00:05:16,415
只有大约20个public声明

82
00:05:16,671 --> 00:05:20,255
这20个public的东西要公开的东西能包括

83
00:05:20,511 --> 00:05:21,791
嵌套式的

84
00:05:22,047 --> 00:05:22,815
他的地方

85
00:05:23,071 --> 00:05:25,375
以及一些成员函数

86
00:05:25,887 --> 00:05:28,703
其中最重要的成员函数就是这样的

87
00:05:29,471 --> 00:05:32,287
这些事情其实我们在地狱

88
00:05:32,799 --> 00:05:36,639
第2讲很标准库的分配器的语言

89
00:05:36,895 --> 00:05:41,759
怎么C标准库的分配器很重要的那一个啊有内存池那个

90
00:05:42,015 --> 00:05:43,295
我已经了解了

91
00:05:43,807 --> 00:05:46,623
这里面其中这个恩主义

92
00:05:47,135 --> 00:05:51,231
指的是客户申请的元素个数而不是空间

93
00:05:51,487 --> 00:05:55,327
总量是空源总量指的就是byte字节

94
00:05:55,583 --> 00:05:56,351
字节

95
00:05:57,631 --> 00:06:03,775
这里是元素个数啊这个比较高混了因为我们在第2讲里面谈到使用的标准

96
00:06:04,031 --> 00:06:09,151
怎么C的那个分配器有一个很棒的那句那个是旧版本

97
00:06:10,175 --> 00:06:14,527
它是以字节为单位的是这个子元素为单位

98
00:06:15,039 --> 00:06:15,807
现在

99
00:06:16,063 --> 00:06:21,439
进入的是标准规格书所说的这个接口

100
00:06:22,207 --> 00:06:25,535
而先前谈的那个是一个旧的风格

101
00:06:27,327 --> 00:06:33,471
我们去看这些空间怎么空间就这些n个元素这些空间是通过调用者

102
00:06:33,727 --> 00:06:34,751
这个东西获得了

103
00:06:35,007 --> 00:06:40,127
这个是什么呢我们再给你讲题过了这就是malloc往下掉有什么

104
00:06:40,639 --> 00:06:41,663
不过你可以

105
00:06:42,431 --> 00:06:43,455
重载它

106
00:06:44,479 --> 00:06:44,991
好

107
00:06:45,503 --> 00:06:51,647
不说是通过这个孩子但是何时调用以及有多么频繁的调用的没有距离

108
00:06:51,903 --> 00:06:52,415
确定

109
00:06:52,927 --> 00:06:53,695
那当然

110
00:06:55,231 --> 00:07:01,375
也就因为这样所以我们才能够发展出内内存池

111
00:07:03,679 --> 00:07:04,703
不要美

112
00:07:04,959 --> 00:07:06,239
不要外泄

113
00:07:06,751 --> 00:07:09,823
需求一个我们就来分配一个不要这样

114
00:07:10,079 --> 00:07:11,103
这个太慢了

115
00:07:12,639 --> 00:07:13,151
好

116
00:07:13,407 --> 00:07:17,759
说这两句黄色的这两个字也就是说我们可以来自己

117
00:07:18,271 --> 00:07:19,551
设计自己的

118
00:07:19,807 --> 00:07:20,831
内存是

119
00:07:21,855 --> 00:07:22,623
我不知道往下看

120
00:07:24,415 --> 00:07:25,183
刚刚说

121
00:07:25,439 --> 00:07:26,975
这个多么频繁的调用

122
00:07:27,743 --> 00:07:29,023
并没有明确规定

123
00:07:29,535 --> 00:07:33,375
据说最容易满足需求的做法就是

124
00:07:33,631 --> 00:07:35,935
每当容器需要的时候就调用

125
00:07:36,447 --> 00:07:37,983
这个这个就是最

126
00:07:38,239 --> 00:07:39,519
直观最

127
00:07:39,775 --> 00:07:40,543
直接的

128
00:07:41,311 --> 00:07:44,383
每当容器释放的时候就调用会的地点

129
00:07:45,151 --> 00:07:48,223
这种做法比起这种做法你看一下

130
00:07:49,759 --> 00:07:51,039
当然是比较慢啊

131
00:07:51,295 --> 00:07:53,599
后面这种做法其实就是

132
00:07:54,111 --> 00:07:54,623
前面

133
00:07:54,879 --> 00:08:00,767
掌掴一大堆的第2讲第3讲一次讲的不同的城市上所做的

134
00:08:01,535 --> 00:08:02,815
内存池

135
00:08:05,119 --> 00:08:06,399
这个

136
00:08:06,655 --> 00:08:12,799
最满最容易满足的是这样的做法这样的做法的优势是可以在极大

137
00:08:13,055 --> 00:08:16,895
大范围内的硬件和操作系统操作能够有效运作

138
00:08:17,663 --> 00:08:20,223
最标准的做法

139
00:08:22,271 --> 00:08:27,903
好现在我们看我刚刚谈到要介绍七个七个

140
00:08:28,415 --> 00:08:32,767
分配器六个后期的其中两个最简单的这两个

141
00:08:33,023 --> 00:08:34,303
这两个的定义

142
00:08:35,839 --> 00:08:37,375
目前的重点

143
00:08:37,631 --> 00:08:41,727
我们所要关注的重点挖出来看的是在右手边

144
00:08:43,007 --> 00:08:47,615
News of Cat has dedicated注意他不是在std之下

145
00:08:48,383 --> 00:08:50,943
20另外一个命名空间最

146
00:08:51,199 --> 00:08:55,295
也就是说我们如果真的要用他的话来会比较麻烦一些

147
00:08:55,807 --> 00:08:59,903
必须写全的命名空间写出来绿色的这个东西

148
00:09:00,159 --> 00:09:02,207
这点的定义

149
00:09:02,975 --> 00:09:05,023
台湾最重要的日子两个函数呢

150
00:09:05,279 --> 00:09:06,815
蓝色的这两个函数

151
00:09:07,327 --> 00:09:09,119
可以看到他做什么事

152
00:09:09,631 --> 00:09:15,519
他没有坐这边三节被我拿掉了不是重要的东西这里面的最重要的是这一个

153
00:09:16,031 --> 00:09:17,055
这个

154
00:09:18,591 --> 00:09:19,359
下面呢

155
00:09:19,615 --> 00:09:24,223
真的是没落格上面是是一家家的六个弟弟

156
00:09:26,015 --> 00:09:30,367
所以这两个基本上就是没有做什么特殊的设计

157
00:09:30,879 --> 00:09:31,647
没有

158
00:09:31,903 --> 00:09:36,767
内存时没有没有什么大挖大块切成小块都没有

159
00:09:37,279 --> 00:09:37,791
都没有

160
00:09:38,303 --> 00:09:44,447
这个就是呼应这句话这是最容易满足需求的做法就是这种做法

161
00:09:45,471 --> 00:09:47,263
你可以选择任选一个

162
00:09:48,543 --> 00:09:54,175
刚刚说有一个默认的那那一个是是哪一个那这个故事等下会衔接起来

163
00:09:54,687 --> 00:09:57,247
现在的有两个出现了

164
00:10:00,063 --> 00:10:01,343
肯定他们都比

165
00:10:01,599 --> 00:10:05,951
比较慢比较慢因为他们没有内存池的事迹

166
00:10:06,719 --> 00:10:09,791
这两个如果要我去评判他呢

167
00:10:10,559 --> 00:10:12,863
我要说上面这个要好一些些

168
00:10:13,631 --> 00:10:17,215
其实这个频段都没有一个全面性

169
00:10:17,471 --> 00:10:19,775
因为上面这一个这个呢

170
00:10:20,031 --> 00:10:22,079
里面会调用malloc

171
00:10:22,335 --> 00:10:25,151
所以上面要比下面慢一些些

172
00:10:25,663 --> 00:10:27,199
这个一些些

173
00:10:27,455 --> 00:10:30,271
我不会影响你的这个很难说

174
00:10:30,527 --> 00:10:31,551
很难说

175
00:10:31,807 --> 00:10:33,087
但是我刚刚提到

176
00:10:34,623 --> 00:10:38,463
从这个逻辑的角度看这上面好一点是

177
00:10:39,999 --> 00:10:40,767
这个是可以

178
00:10:41,535 --> 00:10:42,303
重返

179
00:10:43,327 --> 00:10:44,607
我们在第1讲里面

180
00:10:45,631 --> 00:10:49,727
火车前面的其他讲的都是一个部分震惊

181
00:10:50,239 --> 00:10:56,383
重返过他这个1重载就可以影响整个后头的这个所有的动作就给我们一个

182
00:10:56,639 --> 00:10:57,151
集会

183
00:10:57,407 --> 00:11:00,479
RC developed with不能重载

184
00:11:02,271 --> 00:11:05,855
他们有这样的特性我也不能说谁比谁好

185
00:11:07,135 --> 00:11:07,903
好

186
00:11:09,439 --> 00:11:11,999
好这是两个我们再往下看

187
00:11:12,255 --> 00:11:14,303
最简单的两个分配器

188
00:11:15,839 --> 00:11:21,727
另外一种做法得出来刚刚那种简单的之外就另外这个就是使用智能型的

189
00:11:22,751 --> 00:11:27,103
也就是把分配所得的内存加以缓存cache

190
00:11:28,639 --> 00:11:34,783
也就是把一大块切成一小块慢慢地给出去也就是内存池

191
00:11:35,551 --> 00:11:40,159
这种额外的机制可以用什么树种形式呈现

192
00:11:40,415 --> 00:11:45,791
我们比较奇怪的就是其实我们在第2讲谈过的那个内存是吗那就是这一个

193
00:11:46,815 --> 00:11:47,327
比较

194
00:11:47,583 --> 00:11:53,727
相较之下比较简易是比起上面这个啊其实这个本身已经是算是够复杂的

195
00:11:53,983 --> 00:11:56,287
X80h

196
00:11:56,799 --> 00:11:59,103
还记得为什么这边讲X5吗

197
00:11:59,615 --> 00:12:00,639
固定大小

198
00:12:00,895 --> 00:12:04,479
我们在第2讲一面谈到的那个10条链表

199
00:12:04,735 --> 00:12:09,855
负责的是八个字节的第1条链表是16个字节第2条链表示

200
00:12:10,111 --> 00:12:13,183
当作是八的倍数一直到

201
00:12:13,695 --> 00:12:14,975
16条链表

202
00:12:15,999 --> 00:12:17,279
或者是零到15

203
00:12:17,791 --> 00:12:21,375
最后一条链表负责的是128个自己

204
00:12:22,143 --> 00:12:23,935
也就是这个东西

205
00:12:26,239 --> 00:12:32,383
记得吗当时我曾经说过那个是更新2.9把我还带你去看了源代码

206
00:12:32,639 --> 00:12:38,271
那2.9版行很少了现在到底还在不在那还在呀我当时也讲过了

207
00:12:38,527 --> 00:12:39,295
Outside

208
00:12:39,807 --> 00:12:44,415
好我相较于这一个比较更复杂的操作

209
00:12:44,671 --> 00:12:47,999
Bitmap index做法

210
00:12:48,511 --> 00:12:52,351
这个bitmap你可能会联想到的图图图文件

211
00:12:53,119 --> 00:12:55,679
这个图形有一种格式要bitmap

212
00:12:56,447 --> 00:12:57,983
这个不太一样

213
00:12:58,239 --> 00:13:03,103
这个词就是用0101一个DJ一个bit来表现一些事情

214
00:13:05,151 --> 00:13:07,967
我待会会详细的去谈这个东西

215
00:13:08,735 --> 00:13:10,271
这两个就是智能型的

216
00:13:11,807 --> 00:13:14,367
这里所有的说说看

217
00:13:15,135 --> 00:13:18,975
缓存被曾训练所有的容器所共享

218
00:13:21,791 --> 00:13:22,559
这两个

219
00:13:23,071 --> 00:13:27,679
不会经常地被调用这就是我们希望的也就是内存池吗

220
00:13:28,191 --> 00:13:29,727
不会经常被调用

221
00:13:29,983 --> 00:13:32,799
这可带来速度上的优势

222
00:13:34,591 --> 00:13:36,895
我对这句话打了一个问号

223
00:13:38,175 --> 00:13:42,015
我刚刚提过这个是官方文件里面的说法

224
00:13:42,527 --> 00:13:43,551
可带来

225
00:13:43,807 --> 00:13:45,087
速度上的优势

226
00:13:45,343 --> 00:13:46,367
我们要去想

227
00:13:46,623 --> 00:13:49,183
其实所有的动作最后都跑到没了个去

228
00:13:49,439 --> 00:13:55,583
而我们在第1次颁奖已经非常详细的了解了它的内容它的底

229
00:13:55,839 --> 00:13:59,423
你不动累了个本身的动作也是一个复杂的

230
00:13:59,679 --> 00:14:00,959
内存池

231
00:14:01,471 --> 00:14:07,615
所以一般人认为那个慢其实那个并不慢所以这里的速度上的优势当然是理财

232
00:14:07,871 --> 00:14:14,015
再一次减少对malloc的调用当然是速度会有所提升但是效益已经不明

233
00:14:14,271 --> 00:14:14,783
明显

234
00:14:15,807 --> 00:14:16,831
已经不明显

235
00:14:17,343 --> 00:14:19,647
所以在这边使用这种cache

236
00:14:19,903 --> 00:14:25,023
哇一大块切成一些小块其最大的优势这里反而没有提到

237
00:14:26,047 --> 00:14:26,559
就是

238
00:14:27,583 --> 00:14:28,351
不需要cookie

239
00:14:29,119 --> 00:14:30,143
记得过去吗

240
00:14:30,399 --> 00:14:32,447
1块里面上下回家估计

241
00:14:33,215 --> 00:14:34,751
大战八个字节

242
00:14:35,007 --> 00:14:35,775
可以省掉

243
00:14:37,823 --> 00:14:40,639
圈出来的要注意

244
00:14:42,431 --> 00:14:48,063
使用这一类的技巧的分配器包括什么呢刚才那两个了这两个

245
00:14:48,319 --> 00:14:51,391
变成真正的给你的Class就是

246
00:14:51,647 --> 00:14:53,439
这个这个就是对应的

247
00:14:54,463 --> 00:14:56,255
另外一个就是库locator

248
00:14:56,767 --> 00:14:57,791
也就是这一个

249
00:15:00,863 --> 00:15:07,007
还有一个就是叫MT multithreaded多线程的allocator

250
00:15:07,775 --> 00:15:09,055
我后面

251
00:15:09,567 --> 00:15:12,127
讲个细节里面没有弹出一个

252
00:15:12,639 --> 00:15:14,687
至于边的KTV

253
00:15:14,943 --> 00:15:16,735
非常小气的句子

254
00:15:16,991 --> 00:15:19,551
这一个我们其实在第2讲就谈过了

255
00:15:20,575 --> 00:15:24,415
这一个官方文件在这里其实是行货

256
00:15:24,927 --> 00:15:26,207
因为他这一个

257
00:15:26,719 --> 00:15:31,583
这个Class名称不觉这个样子也许在比较早的版本

258
00:15:32,095 --> 00:15:33,631
是叫这个名字

259
00:15:34,399 --> 00:15:36,191
现在已经不是这个名字

260
00:15:37,471 --> 00:15:38,239
注意这里

261
00:15:39,775 --> 00:15:41,567
他真正的名字带回你没看到

262
00:15:44,127 --> 00:15:45,151
我们再往下

263
00:15:45,407 --> 00:15:48,223
仍然在这里官方文件里面就是说

264
00:15:48,991 --> 00:15:54,111
Class allocator分配器指拥有这三种东西

265
00:15:54,367 --> 00:15:56,927
他自己本身是没有数据的

266
00:15:57,183 --> 00:15:58,463
他只有他的呗

267
00:15:59,231 --> 00:16:02,303
构造函数参数的河岸汗如雨

268
00:16:02,559 --> 00:16:03,071
这些

269
00:16:04,863 --> 00:16:11,007
Refined跟我们现在要谈的内存管理关它是分配器和分配器直接

270
00:16:11,263 --> 00:16:14,335
现在一个一个一个复制的动作

271
00:16:14,847 --> 00:16:19,199
Refined重新绑定是我们不会去谈这一个动作

272
00:16:20,735 --> 00:16:26,367
好继续说分配器继承自一个高速度的

273
00:16:26,623 --> 00:16:29,951
扩充的分配计算面这句话什么意思啊

274
00:16:30,463 --> 00:16:31,231
看看这个图

275
00:16:31,999 --> 00:16:33,791
我抓了两个出来给你看

276
00:16:36,095 --> 00:16:37,631
他们都有一个不累

277
00:16:39,167 --> 00:16:44,799
这就是这里所谓的高速的这一个奇石膏这个会让人联想好像

278
00:16:45,567 --> 00:16:46,079
好像

279
00:16:46,591 --> 00:16:47,359
我们的

280
00:16:47,615 --> 00:16:53,759
我们的眼球深深的被高速锁芯74个地图没有事

281
00:16:54,015 --> 00:16:56,063
什么特殊的意思它只是说

282
00:16:58,111 --> 00:17:04,255
我们以前或者我们想象中的一个分配就是一个Class现在那在

283
00:17:04,511 --> 00:17:09,375
新的做法里头切成父类和子类功能有一些

284
00:17:09,887 --> 00:17:16,031
区分哪些事情让父类做某些事情让努力做不过大部分都是父类在做

285
00:17:18,335 --> 00:17:19,103
只是这样

286
00:17:20,127 --> 00:17:24,479
这个这个切割在在在功效上他其实没有太大的意义

287
00:17:25,247 --> 00:17:31,391
就像我在第2讲明天谈到的那个登录C 2.9的那一刻他只有一个Class我反

288
00:17:31,647 --> 00:17:33,951
看起来源代码看起来还挺舒服的

289
00:17:34,719 --> 00:17:39,327
切成两个也没有功能上的增加多我们会会多不好没有

290
00:17:44,447 --> 00:17:50,591
鱿鱼切成两类和子类也因此所有分配和归还的动作都去

291
00:17:50,847 --> 00:17:52,127
取决于父类

292
00:17:52,895 --> 00:17:56,479
意思就是指其实大部分工作都是交给父那就错了

293
00:17:57,759 --> 00:17:59,039
而这个父类呢

294
00:17:59,295 --> 00:18:00,063
往往是

295
00:18:00,319 --> 00:18:05,183
终端用户我们哪些应用程序的人无法碰触和

296
00:18:05,439 --> 00:18:06,207
操控

297
00:18:07,231 --> 00:18:09,023
看这个是private继承

298
00:18:10,303 --> 00:18:11,071
我们

299
00:18:11,327 --> 00:18:17,471
不能也没有必要去面对这个复那我们面对的是指那这个才是标准库提供的

300
00:18:17,727 --> 00:18:18,751
我带着这种

301
00:18:19,007 --> 00:18:22,335
大家所熟悉的接口的这个函数

302
00:18:25,663 --> 00:18:28,223
不过看你看这个就有点与有趣了

303
00:18:28,479 --> 00:18:32,575
这个继承自它而它本身其实没有那两个函数

304
00:18:32,831 --> 00:18:36,671
我们面对的是这个我们写应用程序的人面对是这一个

305
00:18:36,927 --> 00:18:38,207
她没有那两个函数

306
00:18:39,231 --> 00:18:40,511
那两个函数在负累

307
00:18:42,303 --> 00:18:43,071
这个诱惑

308
00:18:43,583 --> 00:18:45,119
就变成这样

309
00:18:48,191 --> 00:18:54,335
很难挑选出某一个分配器策略有一个七个有九个很难挑出来某一个说

310
00:18:54,591 --> 00:18:56,895
说他就是能提供最大的共同利益

311
00:18:57,407 --> 00:19:00,223
而不伤害某些其他行为

312
00:19:01,503 --> 00:19:02,271
也就是说

313
00:19:03,295 --> 00:19:04,063
其实

314
00:19:04,319 --> 00:19:08,415
该挑选哪一个分配器或者这些都不够我要自己写一个

315
00:19:08,927 --> 00:19:09,951
这件事情

316
00:19:10,207 --> 00:19:13,535
要做决策是相识颇为困难的

317
00:19:15,583 --> 00:19:17,375
因为这句话你自己体会

318
00:19:17,631 --> 00:19:19,935
怎么有点文搜中仔细体会

319
00:19:20,703 --> 00:19:21,471
也就是

320
00:19:23,263 --> 00:19:24,543
余雄

321
00:19:24,799 --> 00:19:26,335
掌不可得兼

322
00:19:26,591 --> 00:19:31,455
你这么做这么设计的话往往可能在不影响另外一些

323
00:19:31,711 --> 00:19:32,479
一些动作

324
00:19:35,295 --> 00:19:36,319
好在我家看

325
00:19:36,831 --> 00:19:39,903
任慕斯加加提供了三项

326
00:19:40,159 --> 00:19:40,927
综合

327
00:19:41,183 --> 00:19:43,743
可是因为刚刚说这个测试

328
00:19:44,511 --> 00:19:49,631
说连挑选怎么样的一个典型测试都是一种困难

329
00:19:49,887 --> 00:19:52,959
然后跟牧师应该给了你三种

330
00:19:53,215 --> 00:19:53,983
测试

331
00:19:58,591 --> 00:20:02,175
那这些测试在哪呢我在哪看的到呢

332
00:20:02,943 --> 00:20:07,295
如果你很完整的安装等IC它会有一个

333
00:20:07,551 --> 00:20:08,319
一个

334
00:20:08,575 --> 00:20:10,623
目录放的都是他的一些

335
00:20:10,879 --> 00:20:12,415
测试的文件

336
00:20:13,183 --> 00:20:14,975
这就是一些

337
00:20:15,487 --> 00:20:17,023
C加加程序

338
00:20:17,279 --> 00:20:19,583
可以找得到它们

339
00:20:19,839 --> 00:20:25,983
这些测试这边也提醒我们如果我们自己要去开发分

340
00:20:26,239 --> 00:20:29,055
分配器我们要测试的角度

341
00:20:29,823 --> 00:20:32,127
这也可以给我们一些暗示

342
00:20:32,383 --> 00:20:38,015
一个是insearch当然这个是最重要的叫安插一些元素的时候的速度有多快

343
00:20:38,527 --> 00:20:39,551
Search

344
00:20:40,575 --> 00:20:46,207
日本人是在多线程现在几乎绕不开多线程这个话题

345
00:20:46,719 --> 00:20:50,047
在多线程里面的insertion and

346
00:20:50,303 --> 00:20:51,071
Official

347
00:20:51,327 --> 00:20:51,839
这个

348
00:20:52,607 --> 00:20:54,655
插入以及删除的动作

349
00:20:55,679 --> 00:21:00,799
13个人都是使用无线城市下的一个一个非常

350
00:21:01,055 --> 00:21:04,127
一个很常见的一种毛豆

351
00:21:04,383 --> 00:21:10,527
The producer and consumer生产者和消费者

352
00:21:11,807 --> 00:21:13,343
应用这种模式来

353
00:21:13,599 --> 00:21:14,367
色

354
00:21:14,879 --> 00:21:19,488
这些六七个七八个分配器的效率

355
00:21:21,024 --> 00:21:24,352
这些都是官方文件刚刚的61

356
00:21:24,608 --> 00:21:28,448
我在带领大家看了这些官方文件

357
00:21:29,728 --> 00:21:30,240
再往下

358
00:21:32,288 --> 00:21:37,408
除了刚刚三个智能智能型的哪三个再看一次

359
00:21:38,176 --> 00:21:39,456
飞跃的商业

360
00:21:40,224 --> 00:21:41,504
Nx的

361
00:21:42,016 --> 00:21:47,392
内存池这种行为已经metatrader 4除了这三种之外

362
00:21:47,648 --> 00:21:51,488
另外还有两种一个叫第8个Hello Kitty

363
00:21:52,512 --> 00:21:54,560
一个叫Eric

364
00:21:55,584 --> 00:22:00,960
这个debug allocator他是一个rapper一个包外不起

365
00:22:01,472 --> 00:22:04,544
可以包覆在任何分配器之上

366
00:22:05,312 --> 00:22:11,456
后头呢看到我在吃饭怎么去使用它你就会看到它的参数里头啊你要

367
00:22:11,712 --> 00:22:13,760
放放一个分配器给他

368
00:22:14,272 --> 00:22:18,368
这个第8个OK的本身是不做分配

369
00:22:19,136 --> 00:22:20,160
规划的动作

370
00:22:20,928 --> 00:22:24,000
他只是在真正要做的那个动作之外

371
00:22:24,512 --> 00:22:25,536
华为监事情

372
00:22:25,792 --> 00:22:28,608
下可以看到他包了什么东西

373
00:22:29,888 --> 00:22:30,400
好

374
00:22:30,656 --> 00:22:32,704
这里其实也说明了

375
00:22:32,960 --> 00:22:36,032
说他把客户的申请量

376
00:22:37,056 --> 00:22:38,592
添加一些

377
00:22:39,360 --> 00:22:40,896
添加一些字节

378
00:22:41,664 --> 00:22:45,248
然后就交给他包的那个分配去去回应

379
00:22:45,504 --> 00:22:47,552
他自己真正是不做事

380
00:22:47,808 --> 00:22:49,344
不做内存分配的事情

381
00:22:49,856 --> 00:22:56,000
那么这天下的这一小亮做什么呢那一小亮记录的就是这一快播

382
00:22:59,584 --> 00:23:05,472
于是相对应的一段回收的时候收到一个指针人就会检查这个大小

383
00:23:06,240 --> 00:23:08,544
检查的时候是用search

384
00:23:10,336 --> 00:23:11,872
如果你不了解释

385
00:23:12,640 --> 00:23:15,456
查一下这个这个这个函数做什么用

386
00:23:17,504 --> 00:23:19,552
可以在运行启时候

387
00:23:20,320 --> 00:23:23,392
告诉你爱这个地方有错它会跳出来

388
00:23:25,952 --> 00:23:30,304
罪在我认为这个其实说实在的没有什么用

389
00:23:30,560 --> 00:23:32,608
没有什么用它煲了一个

390
00:23:32,864 --> 00:23:37,216
分配器然后他家的这一小块子记住它的大小

391
00:23:38,240 --> 00:23:39,264
没什么用

392
00:23:41,824 --> 00:23:42,336
好

393
00:23:42,592 --> 00:23:48,736
另外一种人叫relocate这个是什么允许分配一个一只写

394
00:23:48,992 --> 00:23:53,856
固定大小的内存块就是一大块就是用瑞士取得的

395
00:23:54,880 --> 00:23:55,648
数组

396
00:23:56,160 --> 00:23:57,696
现在家里面的个数

397
00:23:59,488 --> 00:24:00,256
这些内

398
00:24:00,512 --> 00:24:05,120
一大块这一大块来来自哪里人来自于这种东西

399
00:24:06,400 --> 00:24:08,192
标准库里头

400
00:24:08,704 --> 00:24:14,848
从cplusplus Seven 2011年或者成为2现在在2.0之后

401
00:24:15,104 --> 00:24:16,384
有一个这一种容器

402
00:24:17,664 --> 00:24:19,456
这种容器的内部

403
00:24:19,968 --> 00:24:26,112
这里没有说我现在告诉你这种容器内部就是一个极佳的速度

404
00:24:27,392 --> 00:24:28,928
语言上的那个瑞

405
00:24:29,440 --> 00:24:33,792
所以我刚刚才会说这个那其实就是一家叫的数组

406
00:24:34,304 --> 00:24:35,840
这个就是这一个

407
00:24:38,144 --> 00:24:42,240
用上了这个分配器之后的大小固定的容器

408
00:24:42,496 --> 00:24:48,640
什么叫大小布丁的东西指的是比如说我我已经知道我要50万个元素了

409
00:24:49,152 --> 00:24:50,688
我一开始我就知道

410
00:24:51,712 --> 00:24:54,016
这样这个大小固定的东西

411
00:24:56,320 --> 00:24:57,856
就无需再调用

412
00:24:58,112 --> 00:24:59,904
这个红色的这两个动作

413
00:25:00,928 --> 00:25:01,952
因为他

414
00:25:02,208 --> 00:25:04,000
他从一开始他就知道要怎么打

415
00:25:04,256 --> 00:25:05,280
那又何必

416
00:25:06,048 --> 00:25:10,400
何必从由小到大慢慢成长每次成长就很痛苦啊

417
00:25:10,656 --> 00:25:13,216
就要分配就要死就可能还要吃饭

418
00:25:15,008 --> 00:25:17,568
VR一次进了就要怎么办

419
00:25:18,080 --> 00:25:19,872
这个当然是非常的快

420
00:25:20,384 --> 00:25:24,736
非常的快而且这里头的那一大块可以用cplusplus

421
00:25:24,992 --> 00:25:26,528
数组来供应

422
00:25:28,832 --> 00:25:29,856
往下看

423
00:25:30,112 --> 00:25:36,256
因此这就允许我们使用STL的那些抽象性和那些比较高

424
00:25:36,512 --> 00:25:40,864
高层的东西而无需在运行其去

425
00:25:41,376 --> 00:25:44,192
好像搞得乱78糟或者是增加开销

426
00:25:45,984 --> 00:25:47,776
我想你可以理解这句话了

427
00:25:48,032 --> 00:25:54,176
因为这里头所用的那一大块是cplusplus语言里面那个数

428
00:25:55,968 --> 00:25:57,504
可以说他是静态的

429
00:25:58,016 --> 00:25:59,296
不是动态的

430
00:26:01,344 --> 00:26:07,232
甚至于在program Spark情况下也可以使用这句话怎么解释

431
00:26:11,072 --> 00:26:13,120
仍然和这里使用

432
00:26:13,376 --> 00:26:15,168
数组脱离不了关系

433
00:26:16,192 --> 00:26:18,240
这个program start-up

434
00:26:19,008 --> 00:26:25,152
我有另外一门课叫做cplusplus的底层奥秘

435
00:26:25,408 --> 00:26:28,480
奥秘盒子这一类的字眼见了一门课

436
00:26:29,504 --> 00:26:31,296
其中的一张图是这样

437
00:26:35,392 --> 00:26:37,184
这个是一个castec

438
00:26:37,696 --> 00:26:40,000
一个函数调用的次数

439
00:26:40,256 --> 00:26:41,280
Spac

440
00:26:42,816 --> 00:26:48,960
上涨是由下往上调用来看这张图是由下往上看

441
00:26:50,752 --> 00:26:52,288
我们的面在这里

442
00:26:53,056 --> 00:26:54,336
或者admin

443
00:26:55,360 --> 00:26:57,920
走进入程序的这是我们写

444
00:26:58,688 --> 00:27:04,832
在进入之前有这么多动作进入之后离开之后还有这么多动作

445
00:27:05,088 --> 00:27:08,160
这些事情都必须做这些事情

446
00:27:09,440 --> 00:27:12,768
就是鲨鱼头的做事情

447
00:27:14,304 --> 00:27:15,840
在这里指的就是

448
00:27:16,352 --> 00:27:18,912
这句话的意思就是在进入

449
00:27:19,936 --> 00:27:22,240
我们所写的程序之前

450
00:27:22,752 --> 00:27:25,824
就已经可以使用这个分配器

451
00:27:27,616 --> 00:27:28,640
这个是为什么

452
00:27:31,712 --> 00:27:32,224
你看

453
00:27:32,736 --> 00:27:34,528
这边进来之后的

454
00:27:35,296 --> 00:27:37,600
第1个动作就是西北地区

455
00:27:38,112 --> 00:27:40,416
动态分配有关

456
00:27:41,952 --> 00:27:42,464
最

457
00:27:42,976 --> 00:27:46,304
除了这一个之外的其他分配器

458
00:27:47,840 --> 00:27:49,632
他们所要的内存

459
00:27:49,888 --> 00:27:56,032
都是动态分配或的有没落可拿到的用operator new拿到的

460
00:27:56,288 --> 00:27:58,080
动态分配

461
00:27:58,336 --> 00:28:03,968
只有这一个是比不使用是一家家的静态的数组

462
00:28:05,504 --> 00:28:08,320
它是用这个数组来支撑的

463
00:28:09,088 --> 00:28:10,624
所以他的意思是

464
00:28:11,392 --> 00:28:16,768
就算在还没有进入面之前我直接就可以用这一个

465
00:28:19,072 --> 00:28:25,216
这句话的潜台词也就是说这边还没有准备好动态分配的时候我就已经

466
00:28:25,472 --> 00:28:26,240
有这一个

467
00:28:30,336 --> 00:28:30,848
不过

468
00:28:31,872 --> 00:28:34,688
以我们现在我现在这张图告诉你

469
00:28:36,224 --> 00:28:37,504
这个啥啊

470
00:28:38,528 --> 00:28:39,552
里头汽车

471
00:28:41,088 --> 00:28:43,136
这些动作啊

472
00:28:43,392 --> 00:28:45,440
是被写成一个函数

473
00:28:45,952 --> 00:28:49,792
小妹crt staff在VCD下叫这个名称

474
00:28:50,304 --> 00:28:54,912
这里头的第1个重要动作就是做内存管理的初始化

475
00:28:55,424 --> 00:28:56,960
第1个动作

476
00:28:58,496 --> 00:29:03,104
说除非你要在这个第1个动作之前还要做事情

477
00:29:03,360 --> 00:29:05,152
火车都已经是在滞后了

478
00:29:05,408 --> 00:29:08,736
那之后的话呢这句话也就意义不大了

479
00:29:10,016 --> 00:29:16,160
他说甚至于它甚至于在start情况下也可以使用

480
00:29:16,672 --> 00:29:21,792
但我现在告诉你starboard的第1个动作就已经把初始化做好了之后呢

481
00:29:22,816 --> 00:29:25,376
所有其他分配基本来也就可以用了

482
00:29:29,728 --> 00:29:35,360
好所以如果要我来下一个频段的话那这个没什么用

483
00:29:35,872 --> 00:29:37,408
这个用户也很小

484
00:29:38,176 --> 00:29:39,200
回到前面来

485
00:29:40,224 --> 00:29:43,296
12312312现在往前走吧

486
00:29:44,064 --> 00:29:46,112
2345

487
00:29:47,648 --> 00:29:48,160
这个

488
00:29:48,416 --> 00:29:49,440
这很复杂

489
00:29:49,696 --> 00:29:50,720
也许对你有用

490
00:29:51,232 --> 00:29:52,512
我会好好的分析吗

491
00:29:52,768 --> 00:29:58,912
这个也很服也相当复杂也很有用这个在第2讲一下他的非常详细了

492
00:29:59,168 --> 00:30:00,704
这个呢我们不谈

493
00:30:01,216 --> 00:30:03,264
将有五个了再往前看

494
00:30:04,032 --> 00:30:06,592
这里有两个六和七这两个呢

495
00:30:06,848 --> 00:30:08,896
错了是非常阳春动作

496
00:30:44,736 --> 00:30:48,576
他的线索他怎么跟你的应用程序搭在一起
