1
00:00:07,680 --> 00:00:11,008
现在我们已经彻底了解了这个

2
00:00:11,520 --> 00:00:12,800
给大气的

3
00:00:14,080 --> 00:00:14,848
分类

4
00:00:17,408 --> 00:00:18,176
一集

5
00:00:18,688 --> 00:00:21,248
这个所谓的tetris

6
00:00:21,760 --> 00:00:27,904
在算法的效率扮演什么样的重要的角色角色接下来我

7
00:00:28,160 --> 00:00:34,304
挑了几个算法我们真正来看算法内部刚刚我也提过这个

8
00:00:34,816 --> 00:00:40,960
一些比较庞大的算法那我们就还是要以和学校大学教授来去谈我们不在

9
00:00:41,216 --> 00:00:41,984
这一个

10
00:00:42,240 --> 00:00:46,592
可在里面来谈我特别挑了这几个例子呢

11
00:00:46,848 --> 00:00:51,456
要表达一下我想表达的东西好

12
00:00:52,224 --> 00:00:58,368
这张投影片列出来的是在先前主要以就是在第1讲里头的一些例子里

13
00:00:58,624 --> 00:01:01,440
里面用到的一些算法

14
00:01:04,512 --> 00:01:10,656
这里有个quicksort秋瑟瑟秋之快就是binary

15
00:01:10,912 --> 00:01:17,056
二分查找法这两个不是是一家标准的算法它们是11的方

16
00:01:18,592 --> 00:01:21,664
下面是三个这都是前面的一张用过的

17
00:01:22,688 --> 00:01:28,832
我在第2家里没有出现过来看的话应该说这才是是一家标准库的outlet算法

18
00:01:30,368 --> 00:01:36,512
怎么是谁是谁什么谁不是什么呢看这边必须符合前面曾经出现过

19
00:01:36,768 --> 00:01:38,304
我的这个这张图形

20
00:01:39,584 --> 00:01:41,376
这个算法规则

21
00:01:41,632 --> 00:01:45,984
啊首先他一定都是在std这个标准库这个命名空间里头

22
00:01:47,008 --> 00:01:53,152
其次呢他一定前面倒带着两根指针用这一个接口这样的方式来跟

23
00:01:53,408 --> 00:01:56,992
容器做沟通上面这个就不是

24
00:01:57,504 --> 00:02:03,648
这个quicksort qsort它这个是一个起点这个那是元

25
00:02:03,904 --> 00:02:06,976
个数正跟这一个接口就不一致

26
00:02:08,256 --> 00:02:13,888
Quicksort binary Search也是一样不一致这是早先是一的函数

27
00:02:15,424 --> 00:02:21,568
好我们往下看那我选择第1个cplusplus算法第1个就是清妹妹

28
00:02:21,824 --> 00:02:24,896
请问那是什么累计的意思

29
00:02:25,152 --> 00:02:31,296
我们也不要来我们可能会说哪几呀但是在这里不一定是加他可以是

30
00:02:31,552 --> 00:02:36,416
是一个你穿进去的一个运算所以不能说哪一家我们要说的一句

31
00:02:36,672 --> 00:02:37,952
M

32
00:02:39,488 --> 00:02:41,024
Accumulate

33
00:02:41,792 --> 00:02:46,400
前面我提到这是很多的算法都有两个版本

34
00:02:47,936 --> 00:02:50,240
像这样吗这就是第1个版本

35
00:02:51,008 --> 00:02:56,128
他接受了这头为两根指针以及一个初值初值

36
00:02:56,384 --> 00:02:57,920
另外一个版本

37
00:02:58,432 --> 00:03:03,552
这头为两根指针以及一个初值以及一个

38
00:03:03,808 --> 00:03:04,576
运算

39
00:03:05,088 --> 00:03:07,648
Operation is算这个运算了

40
00:03:07,904 --> 00:03:11,744
是binary operations作是一个二元的F

41
00:03:12,000 --> 00:03:18,144
两个操作数的两个操作数好我们看看它里面的动作我选择这些算法

42
00:03:18,400 --> 00:03:24,544
尽量都挑选那个内容相当简单的因为其实然后复杂不是我们的

43
00:03:24,800 --> 00:03:25,312
重点

44
00:03:26,080 --> 00:03:32,224
那就调简单一些大家好能够跟上这个球不累计

45
00:03:32,736 --> 00:03:35,808
在这个第1版本它确实是哪一家

46
00:03:36,832 --> 00:03:41,184
怎么样累呢怎么样家呢他把这一个充值

47
00:03:41,952 --> 00:03:44,768
定一个for loop的所有的元素走一遍

48
00:03:45,280 --> 00:03:50,400
把这个初总是把没出10加上每一个元素

49
00:03:51,424 --> 00:03:53,728
要不断的加起来

50
00:03:55,520 --> 00:03:58,080
第2版本传进来的

51
00:03:58,336 --> 00:04:00,128
这不是家了

52
00:04:01,152 --> 00:04:02,176
他是吧

53
00:04:02,432 --> 00:04:04,992
每一次都把这个数值

54
00:04:05,248 --> 00:04:06,784
汉元素

55
00:04:07,040 --> 00:04:08,832
做一个动作

56
00:04:09,856 --> 00:04:11,648
做完了放到初子去

57
00:04:12,160 --> 00:04:13,952
像这个附录一再的做

58
00:04:14,720 --> 00:04:15,744
现在我们看看

59
00:04:16,256 --> 00:04:17,536
右边我有一个例子

60
00:04:20,095 --> 00:04:20,863
好

61
00:04:21,119 --> 00:04:22,655
我用

62
00:04:23,679 --> 00:04:28,287
C Plus将数组瑞当成容器

63
00:04:29,823 --> 00:04:33,919
下面的有三次的就没有三次了四次

64
00:04:34,175 --> 00:04:37,247
1234

65
00:04:37,503 --> 00:04:38,527
调用四次

66
00:04:40,575 --> 00:04:41,855
我调用了

67
00:04:42,367 --> 00:04:43,391
侯根伟

68
00:04:44,415 --> 00:04:46,207
乐我选的是数组

69
00:04:46,719 --> 00:04:50,047
数组了他们没有什么不见的这样的函数

70
00:04:50,559 --> 00:04:53,631
所以直接拿指针当头为

71
00:04:53,887 --> 00:04:57,727
这次次调用都是数组的头

72
00:04:57,983 --> 00:05:00,031
按数组的无为

73
00:05:00,287 --> 00:05:04,127
为什么呢投加三头的这地方

74
00:05:04,383 --> 00:05:05,407
加三

75
00:05:05,919 --> 00:05:10,015
家一家2 Plus 3 Plus plus plus

76
00:05:10,527 --> 00:05:12,575
教父和前臂后开车间

77
00:05:13,087 --> 00:05:14,367
这项就是同为

78
00:05:14,879 --> 00:05:18,207
四次调用都是这样的口味一样

79
00:05:21,023 --> 00:05:22,815
我第1次调用

80
00:05:23,327 --> 00:05:25,375
初子放的是100

81
00:05:27,167 --> 00:05:28,447
第2次调用

82
00:05:29,471 --> 00:05:33,567
我就不再调用这个版本的国将这个版本我要指定

83
00:05:34,591 --> 00:05:36,383
我这个operation是什么

84
00:05:37,151 --> 00:05:38,943
第3次调用了

85
00:05:39,199 --> 00:05:42,527
我也有一个指定的四次调用了

86
00:05:43,039 --> 00:05:45,087
我又有另外一种实现形式

87
00:05:45,343 --> 00:05:46,367
三种

88
00:05:47,903 --> 00:05:49,695
其中的这一种

89
00:05:50,975 --> 00:05:51,999
这个方程

90
00:05:52,767 --> 00:05:56,095
方雪Funk functions

91
00:05:56,351 --> 00:06:02,495
泛函数它是一种像函数的东西而且是6Plus标准库提供的

92
00:06:02,751 --> 00:06:08,895
这个是我们在算法之后这个在第3章里面算法之后马上就要谈到了这个叫方

93
00:06:09,151 --> 00:06:09,663
Butter

94
00:06:10,175 --> 00:06:11,455
那这个呢

95
00:06:12,479 --> 00:06:14,015
我自己写的方程

96
00:06:14,527 --> 00:06:15,295
这个呢

97
00:06:15,551 --> 00:06:17,343
也是我自己写的方程

98
00:06:17,599 --> 00:06:22,207
我们用这四次的调用分别来看看各种不同的情况

99
00:06:22,975 --> 00:06:23,999
好

100
00:06:24,767 --> 00:06:30,143
这里面的值这个数值是这样100内容是12是30

101
00:06:30,399 --> 00:06:31,679
首先我们看第1种

102
00:06:32,447 --> 00:06:35,263
这个调用的是三个参数所以是这个版本

103
00:06:38,079 --> 00:06:39,871
他所做的事情是哪一家

104
00:06:41,407 --> 00:06:47,551
所以初始100分每一个元素都一直加上去那就100加10然后加20

105
00:06:47,807 --> 00:06:49,855
什么叫30加小就是160

106
00:06:53,695 --> 00:06:54,719
下面这个呢

107
00:06:55,487 --> 00:07:00,351
这个我选择的动作不是第4个参数所以是这个版本

108
00:07:01,119 --> 00:07:04,191
这个minus是减法的意思

109
00:07:04,447 --> 00:07:09,567
没有毒没有就出源代码给你看你也可以用常规格

110
00:07:10,847 --> 00:07:12,127
哈士奇

111
00:07:12,383 --> 00:07:18,527
所以传进来之后等于相当于什么相当于这个初值总是

112
00:07:18,783 --> 00:07:20,319
是作茧的动作

113
00:07:21,087 --> 00:07:26,207
减肥减每个元素间完之后又作出值然后再减再减

114
00:07:26,463 --> 00:07:28,511
因此这个

115
00:07:29,535 --> 00:07:30,559
Cabinet

116
00:07:31,839 --> 00:07:32,863
是一个

117
00:07:33,119 --> 00:07:34,143
不断地讲

118
00:07:34,655 --> 00:07:36,447
那本来充值是100

119
00:07:36,703 --> 00:07:37,727
检时

120
00:07:37,983 --> 00:07:39,007
这别人就死了

121
00:07:39,263 --> 00:07:43,103
再减20减70再减30减40

122
00:07:43,359 --> 00:07:44,639
34

123
00:07:47,711 --> 00:07:52,575
下面这两个我就吃饭我们自己来写一个

124
00:07:52,831 --> 00:07:54,111
操作放进去

125
00:07:54,879 --> 00:07:57,183
我不再用标准库的

126
00:07:57,439 --> 00:07:59,999
现有的东西我自己来写

127
00:08:00,511 --> 00:08:03,071
我们要传进去到底是什么东西呢

128
00:08:03,327 --> 00:08:07,423
我们传进去的东西只要能够被你看这个钱蓝色的

129
00:08:08,191 --> 00:08:14,335
只要能够被小括号作用起来现在这个小括号小括号加的芳心

130
00:08:14,591 --> 00:08:17,919
Cooperative函数调用的操作符

131
00:08:18,175 --> 00:08:19,967
作用在这个浅蓝色的上面

132
00:08:21,503 --> 00:08:26,879
你穿什么东西进去只要他能够被小括号作用起来就可以

133
00:08:29,695 --> 00:08:32,767
这一种的所以我们就把这个蓝色的这种东西

134
00:08:33,023 --> 00:08:33,791
叫做

135
00:08:34,047 --> 00:08:35,327
Callable

136
00:08:35,839 --> 00:08:36,607
Entity

137
00:08:36,863 --> 00:08:39,167
可被调用的东西

138
00:08:39,679 --> 00:08:41,727
什么是可悲的东西呢

139
00:08:41,983 --> 00:08:43,519
我现在这边吃饭的两个

140
00:08:44,031 --> 00:08:44,799
我现在上

141
00:08:46,847 --> 00:08:52,991
一般的函数当然是可以调用所以我写一个就是一般的函数我可以放

142
00:08:53,247 --> 00:08:56,831
近来买饭买饭去

143
00:08:57,855 --> 00:08:59,647
或者我写一个

144
00:08:59,903 --> 00:09:06,047
方薰update函数对象作为函数对象就是长这样子

145
00:09:07,583 --> 00:09:08,863
它是一个类

146
00:09:09,375 --> 00:09:10,655
我只是一个结构体

147
00:09:11,679 --> 00:09:13,471
他有重载小括号

148
00:09:14,495 --> 00:09:18,335
因此传进去之后这一个小括号

149
00:09:20,127 --> 00:09:22,943
就相当于在调用这个地方

150
00:09:26,783 --> 00:09:30,879
所以我整理一下我也可以写一个一般的函数

151
00:09:31,647 --> 00:09:34,719
或者我也可以写一个像函数的东西

152
00:09:37,023 --> 00:09:39,839
上海做的东西就是这样的写法

153
00:09:42,143 --> 00:09:44,191
东西就是对象

154
00:09:44,959 --> 00:09:46,239
说这一种

155
00:09:47,007 --> 00:09:48,543
做出来的对象

156
00:09:49,055 --> 00:09:52,127
他的行为像函数我们叫芳轩

157
00:09:52,383 --> 00:09:53,151
Object

158
00:09:53,663 --> 00:09:55,455
或者叫father

159
00:09:55,967 --> 00:09:57,247
反函数

160
00:09:58,271 --> 00:10:00,575
放魔法类似

161
00:10:01,855 --> 00:10:07,999
所以现在的这三个字当都编译通过了所以就示范给你看这些东西都

162
00:10:08,255 --> 00:10:09,023
可以传进来

163
00:10:09,279 --> 00:10:10,815
传到kubernetes

164
00:10:11,839 --> 00:10:12,863
这个地址呢

165
00:10:13,119 --> 00:10:15,167
买饭给我做什么事情

166
00:10:15,423 --> 00:10:20,031
我把x加二乘以外这里的x y在这地方

167
00:10:21,823 --> 00:10:23,615
所以x是充值

168
00:10:24,639 --> 00:10:25,407
桌子

169
00:10:25,663 --> 00:10:26,687
数值是100

170
00:10:27,199 --> 00:10:33,343
所以这意思是说我这个函数传进去意思是什么呢出此每次要加都是家

171
00:10:33,599 --> 00:10:35,135
元素的两倍

172
00:10:38,719 --> 00:10:39,999
武汉自行结果

173
00:10:40,255 --> 00:10:42,815
数字是100人数的两倍呢

174
00:10:43,583 --> 00:10:44,095
所以

175
00:10:44,351 --> 00:10:46,399
100加上二乘以20

176
00:10:46,655 --> 00:10:47,679
然后再加上

177
00:10:48,703 --> 00:10:54,335
稍微再来一次190家这个参加这个成语在家的成语

178
00:10:54,591 --> 00:10:55,359
加起来

179
00:10:55,871 --> 00:10:56,639
220

180
00:11:02,527 --> 00:11:03,807
那么这一个呢

181
00:11:05,087 --> 00:11:07,647
我设计的这一个我所做的事情是

182
00:11:08,415 --> 00:11:11,487
每次都加上元素的三倍

183
00:11:13,791 --> 00:11:15,327
所以存进去之后

184
00:11:15,583 --> 00:11:18,911
100加上这个成语三这个成语上这个城市

185
00:11:20,959 --> 00:11:22,239
加起来就是280

186
00:11:26,335 --> 00:11:29,663
好这是我觉得第1个算法的例子出门了

187
00:11:30,687 --> 00:11:32,223
我在这边可以学习到

188
00:11:33,247 --> 00:11:34,783
同场算法有两个版本

189
00:11:35,039 --> 00:11:40,927
其中的第2版本往往允许我们加上一个额外的原则

190
00:11:41,183 --> 00:11:45,023
Criteria或者一个操作一个operation

191
00:11:45,535 --> 00:11:47,327
让让

192
00:11:48,095 --> 00:11:51,423
原先的版本是比较阳春的让他能够更

193
00:11:51,679 --> 00:11:54,751
更广泛一些版本

194
00:11:57,055 --> 00:12:00,127
好色小姨下一个算法

195
00:12:00,383 --> 00:12:02,175
我选的是for_each

196
00:12:02,943 --> 00:12:05,503
所以取的意思就是在一个

197
00:12:05,759 --> 00:12:11,903
一段区间一段范围里头对每一个元素做一件事情

198
00:12:12,159 --> 00:12:14,719
建你所指定的事情

199
00:12:15,743 --> 00:12:17,023
它的源代码地址

200
00:12:18,047 --> 00:12:19,327
接受first

201
00:12:19,583 --> 00:12:20,607
Context

202
00:12:21,119 --> 00:12:23,935
以及一个函数一个动作

203
00:12:25,471 --> 00:12:26,495
F是什么呢

204
00:12:26,751 --> 00:12:29,567
无所谓只要能够被小括号

205
00:12:30,079 --> 00:12:30,847
调用起来

206
00:12:34,431 --> 00:12:40,319
阿里头做什么是Forest就把这个头尾头就一直走一直走在家一直走

207
00:12:40,575 --> 00:12:41,855
走到尾巴为止

208
00:12:42,367 --> 00:12:44,415
每一个过程里面都调用

209
00:12:44,671 --> 00:12:45,951
F这个数

210
00:12:46,975 --> 00:12:51,583
放的是元素元素的值

211
00:12:54,399 --> 00:12:55,679
好我们来看看

212
00:12:57,471 --> 00:13:00,799
我现在的位置是这样我有一个容器

213
00:13:01,311 --> 00:13:03,359
换了三个元素进去

214
00:13:03,615 --> 00:13:05,663
三个元素进去

215
00:13:06,175 --> 00:13:10,271
我这边有几次的调用foreach一次两次

216
00:13:11,039 --> 00:13:12,063
此调用

217
00:13:14,367 --> 00:13:16,927
第1次调用我传了

218
00:13:17,183 --> 00:13:21,279
方选择上面这个第2次我传的是这一个

219
00:13:22,559 --> 00:13:27,935
这两个方式所做的事情那这个方向是把元素打印出来

220
00:13:28,447 --> 00:13:29,727
这个方显示

221
00:13:29,983 --> 00:13:32,287
把音速打印出来都一样

222
00:13:33,055 --> 00:13:35,103
都一样一个是放血

223
00:13:36,383 --> 00:13:37,663
一个是Object

224
00:13:37,919 --> 00:13:38,943
钢琴App

225
00:13:40,991 --> 00:13:41,759
所以

226
00:13:42,015 --> 00:13:44,575
这两次发射器的调用输出结果

227
00:13:45,087 --> 00:13:48,415
这很单纯的是23次打印出来

228
00:13:52,255 --> 00:13:58,399
说你在面对一个容器你想对每个元素做一件事情同样的1

229
00:13:58,655 --> 00:14:00,447
这件事情你就可以带我去

230
00:14:05,311 --> 00:14:08,127
对于这个4G取在这里的用法

231
00:14:09,151 --> 00:14:15,295
C加加语言问有个新东西我都这边简单提一下非常好用的东西叫range-based for statement

232
00:14:16,831 --> 00:14:22,207
而他的语法技术在第1讲有提过这位在复习一下这样子

233
00:14:24,255 --> 00:14:30,399
IPhone 6 Plus现在就以前是什么三个分号把两个分号区隔出三段东西

234
00:14:30,655 --> 00:14:32,703
现在是一个冒号

235
00:14:33,727 --> 00:14:38,591
左手边是一个变量的声明右手边是一堆东西

236
00:14:39,871 --> 00:14:40,639
这样

237
00:14:40,895 --> 00:14:44,479
这个新的这个语法就会自动的

238
00:14:45,247 --> 00:14:49,087
遍历右边的这一堆东西

239
00:14:50,623 --> 00:14:52,671
举例子来看吧下面这个

240
00:14:53,183 --> 00:14:53,951
4

241
00:14:54,463 --> 00:14:55,487
还是各种树

242
00:14:56,511 --> 00:15:01,887
右手边的是一堆东西右手边的可以直接放一个容器去或者放

243
00:15:02,143 --> 00:15:04,191
想想也是一个容器红色的这个

244
00:15:05,471 --> 00:15:11,615
这是一个现在以列问题一个新的形式直接就这边给定的一贯

245
00:15:13,919 --> 00:15:15,199
于是这个ID

246
00:15:15,455 --> 00:15:17,247
就在这个语法里头了

247
00:15:18,015 --> 00:15:19,295
A11的

248
00:15:19,807 --> 00:15:21,855
你可以说指向不说代表吧

249
00:15:23,135 --> 00:15:29,279
这些元素因此我们在下面的动作这个statement可以好几个好几个语句

250
00:15:29,535 --> 00:15:34,399
句号这一句我就把每得到的每一个人出去

251
00:15:38,239 --> 00:15:42,591
好学习的这一种新的form的我们在右手边

252
00:15:42,847 --> 00:15:47,967
我也是犯了这边有特别奖中睡觉一天开始我就写了这两个

253
00:15:50,015 --> 00:15:55,903
当然了右边的这两个就不再是使用算法所以去了解决无关了

254
00:15:56,415 --> 00:15:59,487
我现在示范一下

255
00:15:59,999 --> 00:16:01,535
这是4s

256
00:16:03,839 --> 00:16:07,167
我觉得第2个例子

257
00:16:07,423 --> 00:16:10,239
第3个例子日price

258
00:16:10,495 --> 00:16:14,335
汉replace it with copy

259
00:16:15,103 --> 00:16:19,967
我用这个地址来让大家体会期80个算法

260
00:16:21,759 --> 00:16:22,271
有一种

261
00:16:22,527 --> 00:16:23,807
命名方式

262
00:16:24,319 --> 00:16:28,415
象征一个函数叫瑞Christian

263
00:16:29,695 --> 00:16:35,327
那这一个取代取代是什么意思呢你可以想象它必然是把容器全部走一遍

264
00:16:36,351 --> 00:16:38,911
他会指定一个词进去

265
00:16:39,167 --> 00:16:43,775
每一个元素如果跟这个原子相同就把它取代表

266
00:16:44,031 --> 00:16:48,127
徐大为心之所以他接受投喂两根

267
00:16:48,383 --> 00:16:49,151
来气

268
00:16:49,663 --> 00:16:50,431
以及

269
00:16:51,967 --> 00:16:53,503
就只跟仙子

270
00:16:54,783 --> 00:16:58,367
元素如果跟舅子相同就替换为叶子

271
00:17:00,415 --> 00:17:01,951
写代码非常简单

272
00:17:02,207 --> 00:17:04,255
这个循序的查找

273
00:17:09,119 --> 00:17:13,215
如果跟舅子相同红色的这一块

274
00:17:13,727 --> 00:17:17,055
就把这个元素值改为新值

275
00:17:21,407 --> 00:17:24,735
他有一个兄弟叫做

276
00:17:25,503 --> 00:17:31,647
你只要看到算法后面带着一副这个名称就表示你要给他一个提

277
00:17:31,903 --> 00:17:32,415
小姐

278
00:17:33,695 --> 00:17:35,487
所以这1

279
00:17:35,743 --> 00:17:40,095
调函数的参数那就是侯伟

280
00:17:41,375 --> 00:17:42,143
以及一个

281
00:17:42,399 --> 00:17:43,423
条件

282
00:17:43,679 --> 00:17:47,519
Freescale请注意这些全部都是模板参数

283
00:17:48,799 --> 00:17:51,359
所以他们叫什么名字

284
00:17:52,127 --> 00:17:53,663
但是这边我提过

285
00:17:53,919 --> 00:17:54,431
在

286
00:17:54,687 --> 00:18:00,063
The new Series一个源代码里头很好看的一个地方就是很容易看

287
00:18:00,319 --> 00:18:05,439
就是他都用暗示的方式他会告诉你你存

288
00:18:05,695 --> 00:18:07,743
他要求的第3参数

289
00:18:08,511 --> 00:18:10,815
应该要是一个PK

290
00:18:11,839 --> 00:18:17,983
其实较低也可以让他觉得是什么呢我好像的第1讲也提过就是一个判断

291
00:18:18,239 --> 00:18:21,055
是一个事他会传回真会讲

292
00:18:21,311 --> 00:18:24,383
驾照A3 decay

293
00:18:25,151 --> 00:18:29,503
哦然后那一四个参数是一个新子要替换吗

294
00:18:30,015 --> 00:18:36,159
说我这边事情都要注意如果你的后面带着一副就表示要传一个条件一个条件

295
00:18:36,415 --> 00:18:37,439
给他

296
00:18:38,975 --> 00:18:41,791
那你什么做法呢你可以比对一下左手边

297
00:18:42,559 --> 00:18:44,607
左手边的是

298
00:18:44,863 --> 00:18:46,143
元素指按

299
00:18:46,655 --> 00:18:50,495
就只相同这代表一种条件在右手边的

300
00:18:50,751 --> 00:18:54,591
自如果元素之父母和这个判断是

301
00:18:55,359 --> 00:19:00,223
什么叫佛和范城市也就是他从未来是真货假这个两种情况

302
00:19:00,479 --> 00:19:01,503
来做这个

303
00:19:02,271 --> 00:19:03,039
准则

304
00:19:05,599 --> 00:19:07,647
还有的三个兄弟

305
00:19:08,159 --> 00:19:09,951
瑞prestashop

306
00:19:11,231 --> 00:19:12,255
意思是

307
00:19:14,303 --> 00:19:18,399
他不是取得他我还得看一下这个

308
00:19:19,423 --> 00:19:20,191
没有注解

309
00:19:21,471 --> 00:19:27,615
等同于就职的这些元素都以新子取代而且不是

310
00:19:27,871 --> 00:19:32,479
不是取代这放到新的区间距所以这个名字叫copy

311
00:19:34,527 --> 00:19:38,111
你说你有没有这边有一段东西

312
00:19:39,135 --> 00:19:45,279
那比较相等之后它不会取代它它会把它开辟了新的地方去

313
00:19:46,047 --> 00:19:48,095
这个函数的作用

314
00:19:51,679 --> 00:19:55,007
好价

315
00:19:55,263 --> 00:19:59,103
更是让大家认识一个命名的方式

316
00:20:00,127 --> 00:20:01,151
下一页

317
00:20:02,687 --> 00:20:03,455
Count

318
00:20:04,479 --> 00:20:06,271
看着就是剂量了

319
00:20:06,527 --> 00:20:11,135
计算在一个范围里面符合条件有多少有几个元素

320
00:20:11,391 --> 00:20:13,183
看这里

321
00:20:13,695 --> 00:20:19,839
参数为一个叫汤的一个家康师傅一定是后面带着一个条件你要指定义

322
00:20:20,095 --> 00:20:20,863
那个条件进去

323
00:20:22,143 --> 00:20:23,679
在这一夜

324
00:20:24,959 --> 00:20:26,751
汉下一页方案

325
00:20:27,263 --> 00:20:29,567
以及更下一首

326
00:20:31,871 --> 00:20:34,431
这三页右手边

327
00:20:35,455 --> 00:20:36,991
再看一次试射

328
00:20:37,247 --> 00:20:39,039
下一页下一页

329
00:20:39,551 --> 00:20:40,319
我都

330
00:20:41,343 --> 00:20:42,623
帮你整理了

331
00:20:42,879 --> 00:20:48,511
在所有的容器里面有没有带着这种同名称的

332
00:20:48,767 --> 00:20:49,791
成员函数

333
00:20:51,839 --> 00:20:53,119
我没看

334
00:20:53,887 --> 00:20:55,167
现在回家看看来

335
00:20:57,471 --> 00:20:59,775
注意左手边是

336
00:21:00,799 --> 00:21:02,591
标准库的算法

337
00:21:03,103 --> 00:21:05,151
右手边是告诉你

338
00:21:05,919 --> 00:21:10,271
这些容器里面有没有一个同名的成员函数

339
00:21:10,783 --> 00:21:14,879
左手边是全局的右手边是成员函数

340
00:21:15,647 --> 00:21:18,976
我们来分析这个事情首先看看

341
00:21:21,024 --> 00:21:25,632
那你要你可以自己想象的向你要把一堆元素

342
00:21:26,400 --> 00:21:29,984
找找看有没有跟某个值相等

343
00:21:30,240 --> 00:21:33,056
香港的话那那个counter就加1

344
00:21:34,080 --> 00:21:35,104
做法就是这样

345
00:21:39,712 --> 00:21:41,248
Outlook走一遍

346
00:21:41,504 --> 00:21:42,784
看看等不等

347
00:21:43,040 --> 00:21:45,344
冷的话呢n加一

348
00:21:46,112 --> 00:21:47,392
最后传回恩

349
00:21:50,720 --> 00:21:52,512
康的衣服是什么呢

350
00:21:53,280 --> 00:21:55,584
上面相比其他多了一个条件

351
00:21:56,864 --> 00:21:59,168
所以说日本走一遍

352
00:22:00,192 --> 00:22:01,984
走的每一个元素中

353
00:22:03,008 --> 00:22:05,312
有没有符合这种条件的

354
00:22:07,360 --> 00:22:08,384
如果符合

355
00:22:08,640 --> 00:22:09,664
钢材加一

356
00:22:12,992 --> 00:22:14,784
这是这两个函数

357
00:22:21,440 --> 00:22:24,256
我在第1讲里面提过我习惯

358
00:22:24,512 --> 00:22:30,144
常常会到当我在写程序的时候我回到三个网页上去网站上面去

359
00:22:30,656 --> 00:22:31,680
找这个资料

360
00:22:32,704 --> 00:22:34,240
我早了结果呢

361
00:22:35,008 --> 00:22:41,152
这个是全局还是将全局也不对了他其实在St的这个命名空

362
00:22:41,408 --> 00:22:42,176
空间里头

363
00:22:42,432 --> 00:22:44,992
地位差不多等等于全局函数

364
00:22:46,528 --> 00:22:47,808
右边这些事

365
00:22:48,064 --> 00:22:49,856
这些容器里

366
00:22:50,112 --> 00:22:53,952
只有这些容器它本身带有抗

367
00:22:55,744 --> 00:22:59,584
意思就是说当你在使用这些容器的时候

368
00:23:00,352 --> 00:23:06,496
如果你要去看你要用它自己的成员做你不要用左边这个

369
00:23:08,032 --> 00:23:11,104
左边这个你可以想象是泛化

370
00:23:11,616 --> 00:23:17,760
右边这个是有针对性的特别针对着这些这18个容器的123

371
00:23:18,016 --> 00:23:20,832
345678针对着吧

372
00:23:21,088 --> 00:23:22,624
纵容器了

373
00:23:22,880 --> 00:23:26,976
他们自己有他们比较快的胖子的做法

374
00:23:29,024 --> 00:23:35,168
至于上面这一些如果你选择的是这种容器你要去看了你就要他自己没有

375
00:23:35,424 --> 00:23:37,216
那你就要用左手边的这个

376
00:23:38,240 --> 00:23:39,776
要出国的算法来做

377
00:23:42,336 --> 00:23:46,432
等下的另外那两页也都是你会看到

378
00:23:46,688 --> 00:23:52,832
某一些含算法呢原来在容器里头自己有一个版本那你当然就要

379
00:23:53,088 --> 00:23:54,368
要用自己的那个

380
00:23:55,392 --> 00:23:56,160
专属版本

381
00:24:00,000 --> 00:24:00,768
分析一下

382
00:24:01,280 --> 00:24:02,560
为什么是这八个

383
00:24:06,144 --> 00:24:07,424
我想看下一页

384
00:24:08,704 --> 00:24:11,008
这八个又变成自己就形成一处

385
00:24:13,312 --> 00:24:14,080
再下1页

386
00:24:14,848 --> 00:24:16,384
这八个优秀的艺术

387
00:24:17,152 --> 00:24:19,456
好像这八个就比较特立独行

388
00:24:20,480 --> 00:24:21,248
为什么呢

389
00:24:22,272 --> 00:24:23,040
这里来

390
00:24:24,064 --> 00:24:29,952
这八个就是我们前面在第2讲讲容器里面的Sa

391
00:24:30,208 --> 00:24:34,304
我说a container关联式容器

392
00:24:34,816 --> 00:24:36,608
它是可以用一个器

393
00:24:37,120 --> 00:24:38,400
去找到一个

394
00:24:39,424 --> 00:24:40,192
Zeta

395
00:24:41,472 --> 00:24:43,264
Excel行数据库

396
00:24:44,032 --> 00:24:47,104
它不像其他的好像是

397
00:24:47,616 --> 00:24:49,152
可以任意的话

398
00:24:50,944 --> 00:24:52,480
还有自己人体的结构

399
00:24:52,992 --> 00:24:54,784
它内部使用红黑树根

400
00:24:55,040 --> 00:24:57,344
散列表哈希表做出来的

401
00:24:57,856 --> 00:24:58,624
所以

402
00:24:59,136 --> 00:25:00,672
这八个

403
00:25:01,184 --> 00:25:01,952
煤炭

404
00:25:02,208 --> 00:25:05,280
你要看这个话那你可以想象

405
00:25:06,560 --> 00:25:08,608
他有自己比较快速的做法

406
00:25:13,728 --> 00:25:15,776
下一页这个方案

407
00:25:17,056 --> 00:25:19,104
查找搜寻搜寻

408
00:25:19,360 --> 00:25:20,640
这八个

409
00:25:20,896 --> 00:25:23,200
也有他自己比较快的做法

410
00:25:26,272 --> 00:25:28,064
在下一页这个数

411
00:25:30,112 --> 00:25:31,136
这八个

412
00:25:31,904 --> 00:25:33,440
没有受

413
00:25:34,208 --> 00:25:40,352
为什么呢因为这八个本身在便利你一个月住家家他本身就形成了

414
00:25:42,912 --> 00:25:47,776
他不他不在自己的时候你也不要对它调用锁

415
00:25:49,056 --> 00:25:52,128
我的意思是说比如说你有一个map

416
00:25:54,432 --> 00:26:00,576
你要给他排序他已经排序拟人元素放进去它就形成一个排序状态你不要

417
00:26:00,832 --> 00:26:04,160
要再拿这个数字的元素去调用

418
00:26:04,416 --> 00:26:10,560
你不要再拿这个Map里面的元素去要用sort

419
00:26:10,816 --> 00:26:11,840
想要排斥他

420
00:26:15,936 --> 00:26:20,544
啊回到前面来就是三叶是一个故事了所以我们刚刚的夜讲完了

421
00:26:21,056 --> 00:26:22,592
Ps5

422
00:26:23,360 --> 00:26:26,944
Find是一个多么厉害的查找方式吗

423
00:26:27,456 --> 00:26:30,272
一点都不厉害他是一个循序

424
00:26:30,528 --> 00:26:31,552
手续

425
00:26:32,064 --> 00:26:33,600
循序查找

426
00:26:34,112 --> 00:26:35,904
说你看用OneNote

427
00:26:36,672 --> 00:26:37,696
投喂一直走

428
00:26:37,952 --> 00:26:39,232
一直走到头

429
00:26:39,488 --> 00:26:40,256
东伟

430
00:26:41,280 --> 00:26:44,096
不是一直走到有没有找到元素为止

431
00:26:44,608 --> 00:26:45,632
风险这一块

432
00:26:46,400 --> 00:26:47,936
没找到就一直加加

433
00:26:48,960 --> 00:26:51,008
找到了就退出来

434
00:26:51,776 --> 00:26:57,920
好了你可以想象没有100万个元素很不幸地你的运气很差你要找的那个

435
00:26:58,176 --> 00:27:00,992
在地999999

436
00:27:01,504 --> 00:27:02,272
那么

437
00:27:03,040 --> 00:27:08,928
根据这一个算法呢他没有任何特殊的方式它就是一个一个闷着头子找

438
00:27:10,208 --> 00:27:15,584
连那个在最坏的情况之下来必须全部走一遍才找得到

439
00:27:19,168 --> 00:27:20,960
Find me福呢

440
00:27:21,472 --> 00:27:27,616
就是这个早啊有一个条件你要把条件告诉他什么叫他找到了这样

441
00:27:27,872 --> 00:27:29,408
我这一个predicate

442
00:27:30,688 --> 00:27:31,712
判断是

443
00:27:39,392 --> 00:27:41,952
这边机组

444
00:27:44,512 --> 00:27:46,560
用红黑树根散列表

445
00:27:46,816 --> 00:27:49,632
做出来的差异组织八个容器

446
00:27:49,888 --> 00:27:51,680
自己有自己的发音

447
00:27:52,960 --> 00:27:56,032
可以想象因为它有严谨的结构

448
00:27:56,288 --> 00:27:57,568
所以

449
00:27:58,080 --> 00:28:01,920
你用这些容器你不需要去调用左边的翻译

450
00:28:03,968 --> 00:28:05,504
你要是用他自己的

451
00:28:10,112 --> 00:28:12,672
我们再往下看

452
00:28:21,376 --> 00:28:25,984
做菜的学问就大了我所以我并没有把它的源代码出来

453
00:28:27,008 --> 00:28:28,288
好几百

454
00:28:29,824 --> 00:28:31,616
我现在只吃饭

455
00:28:31,872 --> 00:28:33,920
Sort的用法

456
00:28:36,992 --> 00:28:39,040
在这一个例子里头

457
00:28:39,552 --> 00:28:42,112
我们一行一行来看我有义

458
00:28:42,368 --> 00:28:44,928
个数组内容是这样

459
00:28:46,720 --> 00:28:49,280
我以这个速度为初值

460
00:28:50,048 --> 00:28:51,328
Hellotalk

461
00:28:51,840 --> 00:28:53,376
但他认为

462
00:28:53,632 --> 00:28:58,752
Array的名称就是array的头这个大家要去有这个观念

463
00:29:00,032 --> 00:29:00,800
家吧

464
00:29:01,312 --> 00:29:03,872
走到了这个位置那就是伪

465
00:29:04,384 --> 00:29:07,712
把这个头尾当成这个容器

466
00:29:07,968 --> 00:29:08,736
充值

467
00:29:09,760 --> 00:29:15,904
那是因为我去查了啊这个容器有一个构造函数是接收两个参数这样的人

468
00:29:19,744 --> 00:29:22,816
后面的注解就列出目前的

469
00:29:23,072 --> 00:29:24,096
内容是这样

470
00:29:28,192 --> 00:29:30,496
下面这个那啥

471
00:29:32,032 --> 00:29:34,080
我要从头

472
00:29:34,592 --> 00:29:37,920
一直到头加四的位置做一次排序

473
00:29:38,432 --> 00:29:39,456
投在这里

474
00:29:40,736 --> 00:29:43,296
家一家2 Plus 3

475
00:29:43,552 --> 00:29:44,320
下次

476
00:29:44,832 --> 00:29:45,856
这个位置

477
00:29:46,112 --> 00:29:47,136
后面都不算

478
00:29:48,928 --> 00:29:50,464
非要把这四个

479
00:29:50,976 --> 00:29:52,000
做一次排序

480
00:29:52,768 --> 00:29:53,792
找到了结果在这里

481
00:29:54,816 --> 00:29:58,144
3271 12045排去玩家

482
00:30:00,192 --> 00:30:01,216
这个并没有输出

483
00:30:01,984 --> 00:30:08,128
没有输出到屏幕上这个指示是表现那个状态给你看所以括号括起来

484
00:30:08,384 --> 00:30:10,432
表示这四个数的排序

485
00:30:14,016 --> 00:30:15,040
下一个动作

486
00:30:16,832 --> 00:30:17,856
又拿头

487
00:30:18,112 --> 00:30:20,672
下一个动作

488
00:30:22,208 --> 00:30:24,256
这头家是这个位置

489
00:30:24,512 --> 00:30:28,096
字一直到尾巴所以就是后面的四个元素

490
00:30:29,120 --> 00:30:30,912
后面的四个元素

491
00:30:31,168 --> 00:30:31,680
要

492
00:30:31,936 --> 00:30:32,960
排序

493
00:30:33,216 --> 00:30:33,728
这个

494
00:30:34,752 --> 00:30:39,104
准则会计准则是什么人卖方式

495
00:30:39,360 --> 00:30:40,640
比大小的准则

496
00:30:40,896 --> 00:30:43,456
我这个买方选定义在哪里

497
00:30:48,064 --> 00:30:50,880
IPhone SE的大小是这样子来比

498
00:30:51,136 --> 00:30:51,904
还小一些

499
00:30:52,160 --> 00:30:55,744
这是一般的涨幅排序的时候就是这么做的

500
00:30:56,768 --> 00:30:59,072
由小到大排

501
00:31:01,120 --> 00:31:07,264
所以在这一个第3次受的时候我是饭的是要用我自己写的一个

502
00:31:08,288 --> 00:31:09,056
放学

503
00:31:11,360 --> 00:31:12,384
他其实

504
00:31:13,152 --> 00:31:16,992
在前面没有这个第3参数用的是什么

505
00:31:17,504 --> 00:31:18,784
用的就是默认的

506
00:31:20,064 --> 00:31:21,344
默认是什么

507
00:31:21,600 --> 00:31:22,880
就是像这样

508
00:31:25,440 --> 00:31:27,232
从小到大排

509
00:31:28,000 --> 00:31:34,144
所以现在的我也是由小到大排只不过我自己写的我不用默认的那个

510
00:31:36,448 --> 00:31:40,800
现在排序的结果是后面这三个四个要排一次序

511
00:31:43,872 --> 00:31:45,152
侧行

512
00:31:47,200 --> 00:31:49,760
我要从头到尾排序

513
00:31:51,808 --> 00:31:54,368
我的排列的准则是什么呢

514
00:31:54,880 --> 00:31:59,232
They are often margitsziget Center

515
00:32:00,256 --> 00:32:03,072
方可的写法就像这样预言上的写法

516
00:32:03,840 --> 00:32:06,400
需要重返这个操作

517
00:32:09,216 --> 00:32:12,800
而我从法国是怎么定义他那也是由小到大

518
00:32:15,872 --> 00:32:17,152
所以

519
00:32:17,664 --> 00:32:23,808
这四个一个两个三个三个这三个数的

520
00:32:24,064 --> 00:32:26,624
都是由小到大排列

521
00:32:29,952 --> 00:32:31,488
台湾之后

522
00:32:32,000 --> 00:32:35,328
我用这一个for loop

523
00:32:36,096 --> 00:32:37,376
这个刚才提过

524
00:32:38,400 --> 00:32:40,704
一种新的form形式

525
00:32:43,008 --> 00:32:44,800
Rm1便的结果

526
00:32:45,312 --> 00:32:49,152
因为刚刚已经全部重排便了所以打印一遍结果漂亮

527
00:32:50,176 --> 00:32:51,968
从由小到大排

528
00:32:54,528 --> 00:32:56,832
这个是我的错的示范

529
00:33:03,744 --> 00:33:07,328
继续往下我要示范一种特殊情况

530
00:33:07,584 --> 00:33:09,888
我还是要用数的排序

531
00:33:11,680 --> 00:33:13,728
我传进去的头尾

532
00:33:14,240 --> 00:33:16,288
是一种特殊的东西

533
00:33:17,056 --> 00:33:22,432
Our begin和end而不是一般的begin end

534
00:33:24,480 --> 00:33:26,784
这个2代表如inverse

535
00:33:27,296 --> 00:33:29,088
逆向反向

536
00:33:30,624 --> 00:33:33,440
下一页马上要告诉你这个东西的

537
00:33:33,696 --> 00:33:34,976
一些概念

538
00:33:35,232 --> 00:33:41,376
它是你现在可以想像啊好像排序我这本来从见到你的曲牌

539
00:33:41,632 --> 00:33:42,912
现在呢

540
00:33:43,424 --> 00:33:48,800
我是逆向的病根逆向的and最看起来是一个反向排序

541
00:33:49,824 --> 00:33:51,616
那应该得到了结果是

542
00:33:53,152 --> 00:33:53,920
想象一下

543
00:33:57,504 --> 00:33:58,784
所以这个输出呢

544
00:34:02,368 --> 00:34:05,440
这个排完之后下面就做一次的

545
00:34:05,696 --> 00:34:06,464
苏苏

546
00:34:06,720 --> 00:34:09,792
说出这本来是由小到大排

547
00:34:10,560 --> 00:34:12,864
现在就变成由大到小排

548
00:34:16,192 --> 00:34:18,240
这是一个逆向的投喂

549
00:34:21,568 --> 00:34:24,128
马上就要来看一下什么叫都摄像头尾

550
00:34:25,152 --> 00:34:26,432
注意右手边

551
00:34:26,944 --> 00:34:27,968
刚刚提过了

552
00:34:28,992 --> 00:34:31,040
有八个容器

553
00:34:31,296 --> 00:34:35,392
他们是一种关联式的容器它本身就已经排序了

554
00:34:36,416 --> 00:34:36,928
所以

555
00:34:37,184 --> 00:34:40,256
他自己也不提供受到这个数

556
00:34:41,280 --> 00:34:45,632
你也不要用了这个容器然后还去排序

557
00:34:45,888 --> 00:34:46,656
我需要

558
00:34:49,216 --> 00:34:50,752
右手边还告诉你

559
00:34:51,008 --> 00:34:57,152
只有这两个容器一个双向链表和单向链表他们自带着一个说

560
00:34:58,944 --> 00:35:05,088
所以一定要小心一定要小心当你使用这两种容器的时候排序千万不要调用做

561
00:35:05,344 --> 00:35:08,928
左边这个算法所你要调用它的成员

562
00:35:10,720 --> 00:35:11,744
为什么呢

563
00:35:13,024 --> 00:35:15,328
因为算法素

564
00:35:15,840 --> 00:35:19,936
他要求的是random access iterator

565
00:35:20,192 --> 00:35:21,472
Skip跳

566
00:35:21,728 --> 00:35:25,056
但是这两种容器都不能跳

567
00:35:26,336 --> 00:35:29,152
你如果拿这两个容器

568
00:35:29,664 --> 00:35:32,480
去调用set这个算法

569
00:35:37,088 --> 00:35:37,856
要小心

570
00:35:41,952 --> 00:35:44,000
所以呢

571
00:35:45,024 --> 00:35:46,304
不要有一个误解

572
00:35:47,072 --> 00:35:47,840
不要觉得

573
00:35:48,096 --> 00:35:52,448
标准化的算法可以通吃所有的容器类型

574
00:35:52,960 --> 00:35:53,984
这个不成立

575
00:35:59,872 --> 00:36:02,176
刚刚提到了逆向的

576
00:36:02,688 --> 00:36:03,456
定远

577
00:36:04,736 --> 00:36:06,272
这是一个很大的故事

578
00:36:06,528 --> 00:36:10,624
他怎么做出来的这不是蛮大的我们要放到后头就讲

579
00:36:10,880 --> 00:36:13,952
这一张合影片先让大家一个

580
00:36:14,208 --> 00:36:17,792
给一种印象一个简单的印象

581
00:36:18,560 --> 00:36:23,680
这是一个容器它不一定是连续的所以看我爸的话给我开了

582
00:36:23,936 --> 00:36:26,240
在内存里面他怎么排列不管他

583
00:36:27,520 --> 00:36:30,080
帮我调用电的时候

584
00:36:31,104 --> 00:36:33,664
我得到了指针在得到了迭代器在这里

585
00:36:35,200 --> 00:36:39,296
我这边有个浅色的这个箭头符号意思是说

586
00:36:39,552 --> 00:36:40,832
指针在这里

587
00:36:41,088 --> 00:36:42,368
别着急在这里

588
00:36:42,624 --> 00:36:45,440
它如果你对它取自取的是这块

589
00:36:47,488 --> 00:36:48,512
And在这边

590
00:36:49,024 --> 00:36:50,304
取的是这一块

591
00:36:50,560 --> 00:36:55,424
这个是灰色的意思是因为钱币后开区间所有

592
00:36:55,680 --> 00:36:57,728
后面是一根指针

593
00:36:57,984 --> 00:36:59,520
他是最后一个元素的

594
00:36:59,776 --> 00:37:01,056
下一个位置

595
00:37:02,848 --> 00:37:08,992
所以你其实不能对最后这个指针这个别担心去制有个不可以因为其他这一块

596
00:37:12,576 --> 00:37:15,392
Realme相思考怎么思考呢

597
00:37:17,696 --> 00:37:19,488
不能够违反

598
00:37:20,000 --> 00:37:22,816
所有已经成立的规则

599
00:37:25,376 --> 00:37:27,936
那么我们如果把这张图

600
00:37:29,472 --> 00:37:32,032
佳佳是这个方向

601
00:37:32,544 --> 00:37:34,336
佳佳是这个方向

602
00:37:34,592 --> 00:37:38,432
我现在订一下我希望变成佳佳是这一个方向

603
00:37:41,760 --> 00:37:43,040
那怎么办呢

604
00:37:44,320 --> 00:37:46,112
如果你把这个图

605
00:37:46,368 --> 00:37:47,392
折过来

606
00:37:48,672 --> 00:37:51,232
上下颠倒在左右颠倒

607
00:37:52,000 --> 00:37:54,816
上下不必真的就左右颠倒

608
00:37:58,144 --> 00:37:59,168
他会变成这样子

609
00:38:01,472 --> 00:38:02,240
下面这样

610
00:38:03,776 --> 00:38:05,056
你看这个字是反的

611
00:38:07,360 --> 00:38:12,480
我刻意就把这个图呢在这个拖影片操作里面把他把他弄成反的

612
00:38:14,016 --> 00:38:18,368
这样的话这个家家就是从右往左了不能是游族网络

613
00:38:21,696 --> 00:38:27,840
实现这一件事情这个事这个方向这样因此这一根也在

614
00:38:28,096 --> 00:38:28,608
大气

615
00:38:28,864 --> 00:38:31,424
他说拿的元素应该是这一个

616
00:38:32,960 --> 00:38:34,496
只因为这里面成几点了

617
00:38:35,520 --> 00:38:39,360
这个方向夹是这个方向所以这里是起点这里变成笔电

618
00:38:40,896 --> 00:38:45,760
他拿了一个人这一个线程结束点的他拿了应该是这一个

619
00:38:46,784 --> 00:38:50,368
我们应该要实现出这样的一种状况

620
00:38:52,416 --> 00:38:53,952
这就是一个逆向的

621
00:38:54,208 --> 00:38:54,976
迭代器

622
00:38:55,232 --> 00:38:59,840
怎么实现在还是没有提把这个学问比较大方的厚度来

623
00:39:00,352 --> 00:39:01,888
这是我们的目标

624
00:39:03,424 --> 00:39:05,984
所以如果把这两张图整合一下

625
00:39:06,752 --> 00:39:08,544
变成下面这张图

626
00:39:10,080 --> 00:39:12,640
这张图怎么看那就是begin

627
00:39:13,664 --> 00:39:14,688
指向这一块

628
00:39:15,456 --> 00:39:17,248
佳佳

629
00:39:17,504 --> 00:39:18,528
End

630
00:39:19,040 --> 00:39:20,064
则是这一块

631
00:39:21,600 --> 00:39:23,136
Arbequina

632
00:39:23,648 --> 00:39:25,440
BBQ Johnny相的否定

633
00:39:25,696 --> 00:39:28,256
是这个得到的是这个蓝色的人是谁

634
00:39:29,280 --> 00:39:30,304
这个迭代器

635
00:39:30,816 --> 00:39:33,120
他所拿的东西是这一块

636
00:39:34,400 --> 00:39:35,424
R and

637
00:39:36,960 --> 00:39:38,496
他说那东西是这个

638
00:39:40,288 --> 00:39:43,872
上面两张图整合在一起下面这种图

639
00:39:44,896 --> 00:39:48,992
而这个App并跟这个R &怎么写的代码在这里

640
00:39:54,112 --> 00:39:55,648
而begin

641
00:39:55,904 --> 00:39:57,952
而begin这个位置

642
00:39:58,464 --> 00:40:00,000
其实他

643
00:40:01,280 --> 00:40:02,816
就是and

644
00:40:03,584 --> 00:40:04,864
是同一个位置

645
00:40:05,632 --> 00:40:07,936
所以R1

646
00:40:08,192 --> 00:40:11,008
他应该去调用and首先拿到

647
00:40:11,264 --> 00:40:12,288
那一根

648
00:40:12,544 --> 00:40:13,056
迭代器

649
00:40:13,824 --> 00:40:15,872
拿到之后由于这个

650
00:40:16,128 --> 00:40:18,176
拿取元素的

651
00:40:18,432 --> 00:40:20,224
方式是不一样的

652
00:40:20,480 --> 00:40:21,248
所以呀

653
00:40:21,504 --> 00:40:24,320
好价一个东西这个价

654
00:40:24,832 --> 00:40:25,856
调试器

655
00:40:26,112 --> 00:40:29,440
测试适配器

656
00:40:29,952 --> 00:40:30,976
适配器

657
00:40:33,792 --> 00:40:36,864
这个就是大学我刚说我们要放到后台去讲

658
00:40:38,144 --> 00:40:41,984
所以这个我再讲一次这个源代码这边呢

659
00:40:42,240 --> 00:40:44,288
Hobbyking跟R and

660
00:40:45,056 --> 00:40:46,336
Ar15

661
00:40:46,592 --> 00:40:48,384
Hundred

662
00:40:48,640 --> 00:40:54,784
他们要拿的指针应该就是分别这里的and Big

663
00:40:56,576 --> 00:40:57,088
所以

664
00:40:57,344 --> 00:40:59,136
通过这两个来拿

665
00:40:59,392 --> 00:41:02,720
阿森那晚之后要改变一下他的行为

666
00:41:03,488 --> 00:41:04,256
改变什么

667
00:41:04,512 --> 00:41:06,560
Amanda说起来是不是这一块

668
00:41:06,816 --> 00:41:09,120
现在要变成他去年就是这一款

669
00:41:11,168 --> 00:41:12,960
费用此设这个东西把它

670
00:41:13,216 --> 00:41:14,240
靠换下

671
00:41:17,056 --> 00:41:17,568
我的

672
00:41:17,824 --> 00:41:20,384
得奖人的另外一个主题

673
00:41:25,760 --> 00:41:30,368
好算法我再取最后一个例子就是binary search

674
00:41:30,624 --> 00:41:31,392
二分

675
00:41:31,648 --> 00:41:32,416
收取

676
00:41:33,696 --> 00:41:36,000
Binary Search一定要先排序

677
00:41:36,256 --> 00:41:37,536
你的缺点

678
00:41:38,816 --> 00:41:40,608
你如果去看规格书

679
00:41:40,864 --> 00:41:42,400
他也一定告诉你

680
00:41:42,656 --> 00:41:44,960
而且这样子在我查到的资料却这样

681
00:41:45,472 --> 00:41:48,032
Tests if value is it

682
00:41:48,544 --> 00:41:50,592
X86

683
00:41:51,104 --> 00:41:53,151
你要去使用这个

684
00:41:53,407 --> 00:41:54,943
必须条件是

685
00:41:55,967 --> 00:41:58,015
在一个排序状态之下

686
00:42:00,319 --> 00:42:00,831
好

687
00:42:01,087 --> 00:42:03,903
这个binary Search所做的事情

688
00:42:06,719 --> 00:42:07,743
其实他是

689
00:42:07,999 --> 00:42:11,583
把工作都交给了lowerbound所

690
00:42:12,351 --> 00:42:15,423
我们在第3讲我记得有一个地方谈到

691
00:42:15,935 --> 00:42:18,239
源代码有讲到比较后期

692
00:42:18,495 --> 00:42:24,639
第2讲现在是第3讲我们在第2讲后勤的有提到

693
00:42:24,895 --> 00:42:25,663
Lefun

694
00:42:26,431 --> 00:42:30,015
是在什么场合出现我也忘记我有出现这一个

695
00:42:31,295 --> 00:42:36,415
所以等下我会用图形的方式让你理解lower棒子

696
00:42:36,671 --> 00:42:38,207
结果是什么

697
00:42:38,975 --> 00:42:43,327
Urban research所做的事情其实就是让Rover棒的去处

698
00:42:45,119 --> 00:42:48,447
播放在做二分搜寻了

699
00:42:48,959 --> 00:42:51,263
Lower_bound的源代码在这里

700
00:42:52,543 --> 00:42:56,383
他有一个对应的兄弟叫upper_bound

701
00:42:57,407 --> 00:42:58,175
再一个是

702
00:42:58,687 --> 00:43:00,223
你可以想象一个是

703
00:43:00,479 --> 00:43:04,831
比较的比较低的边界一个是比较高的边界

704
00:43:05,087 --> 00:43:08,159
一根高指示什么的

705
00:43:09,439 --> 00:43:11,999
这张图可以非常非常好的帮你理解

706
00:43:14,047 --> 00:43:17,631
假设现在元素的内容是排列是这样

707
00:43:18,399 --> 00:43:24,543
他可能是个红黑树啊不过他家这个叫群续走过之后是这样的一个次序

708
00:43:27,359 --> 00:43:29,151
必须是排序过的

709
00:43:32,479 --> 00:43:34,271
如果我现在要

710
00:43:34,783 --> 00:43:36,575
我调用lower_bound

711
00:43:36,831 --> 00:43:38,111
肉棒

712
00:43:38,879 --> 00:43:43,487
我指定这个整块人整块区间

713
00:43:44,767 --> 00:43:47,071
我要安插20

714
00:43:49,119 --> 00:43:53,215
那么lowerbound帮我找出来的是什么呢注意听

715
00:43:53,471 --> 00:43:54,495
就是

716
00:43:55,519 --> 00:44:01,663
在不违反排序的状态之下这个20能够安插进去的最低

717
00:44:01,919 --> 00:44:02,687
第1点

718
00:44:03,455 --> 00:44:05,247
另外一个子最高点

719
00:44:06,015 --> 00:44:12,159
你看现在有三个20岁我要把一个新的20放进去最

720
00:44:12,415 --> 00:44:13,951
第一点不是在这里吗

721
00:44:15,743 --> 00:44:18,047
这个安插进去就推开了

722
00:44:19,071 --> 00:44:20,607
这样是不会

723
00:44:20,863 --> 00:44:23,167
破坏掉原来的排列

724
00:44:24,703 --> 00:44:26,751
Rubberband

725
00:44:27,007 --> 00:44:33,151
Upper bound就是20安插进去的最高点那不就是这么

726
00:44:35,967 --> 00:44:37,247
最低点的治理

727
00:44:37,759 --> 00:44:39,039
最高检的这里

728
00:44:42,367 --> 00:44:48,255
前提都是阿哥用这两个函数的前提是那一堆数据已经排好序了

729
00:44:51,071 --> 00:44:52,863
Lower bound

730
00:44:53,119 --> 00:44:55,935
源代码的这边有兴趣你可以看一看

731
00:44:56,447 --> 00:45:02,591
由于这已经排过雪所以它是一个二分搜寻你可以看到这里有一个出

732
00:45:02,847 --> 00:45:03,359
除以2

733
00:45:03,871 --> 00:45:04,639
Count

734
00:45:05,407 --> 00:45:06,431
看你是什么

735
00:45:06,687 --> 00:45:07,455
Distance

736
00:45:07,711 --> 00:45:13,855
喉医生就距离我们最早还看过这个算法的源代码的头跟尾的距离相

737
00:45:14,111 --> 00:45:15,903
切出来

738
00:45:16,159 --> 00:45:16,671
Test

739
00:45:18,975 --> 00:45:20,511
抗的要出12

740
00:45:20,767 --> 00:45:22,559
一瓣一瓣的早

741
00:45:23,071 --> 00:45:25,119
这个角二分搜寻法

742
00:45:28,703 --> 00:45:29,983
罪犯

743
00:45:30,239 --> 00:45:33,823
找到在这里头的话了再切一半再去洗澡

744
00:45:34,335 --> 00:45:36,383
没找到了换另外一半的早

745
00:45:36,639 --> 00:45:38,431
速度就会非常多

746
00:45:40,223 --> 00:45:41,503
所以

747
00:45:42,015 --> 00:45:44,831
回到左边来花and search

748
00:45:45,599 --> 00:45:51,487
他里头的动作其实都可以让lower放的去把它完成它就这么完成了

749
00:45:51,999 --> 00:45:54,559
等到找出来之后

750
00:45:55,839 --> 00:46:00,191
看看到底找到了werbung最低点是不是落在这个范围内

751
00:46:00,447 --> 00:46:02,239
说不定找到了是在这

752
00:46:04,031 --> 00:46:05,311
请看啊

753
00:46:06,079 --> 00:46:07,615
找到的如果如果

754
00:46:07,871 --> 00:46:11,199
得到lower_bound得到的结果是在这里

755
00:46:14,271 --> 00:46:15,551
如果在这里

756
00:46:16,831 --> 00:46:18,111
要是有找到

757
00:46:20,415 --> 00:46:21,439
如果在这里

758
00:46:21,695 --> 00:46:22,719
要是没找到

759
00:46:23,743 --> 00:46:24,255
因为

760
00:46:25,023 --> 00:46:28,863
能够安插进去的最低点竟然在这个地方

761
00:46:29,119 --> 00:46:29,631
表示

762
00:46:30,655 --> 00:46:32,703
你这里面根本就没有那个元素

763
00:46:33,727 --> 00:46:34,495
没找到

764
00:46:36,543 --> 00:46:38,079
因此这个

765
00:46:38,335 --> 00:46:43,455
Covid-19进来的是可安插的位置

766
00:46:45,503 --> 00:46:50,111
左手边binarysearch还要根据得到的这个位置

767
00:46:50,623 --> 00:46:53,951
去判断是不是找到了

768
00:46:57,023 --> 00:46:59,071
这个判断就是靠这一块

769
00:46:59,839 --> 00:47:01,375
这边我就不讲解了

770
00:47:01,887 --> 00:47:03,167
慢慢体会

771
00:47:03,679 --> 00:47:04,703
很简单

772
00:47:09,311 --> 00:47:13,151
因为这个binary Search要的只是一个真假

773
00:47:14,431 --> 00:47:18,527
到底在不在这个元素在不在这个范围内真假期

774
00:47:20,319 --> 00:47:21,599
说他要判断

775
00:47:25,183 --> 00:47:26,975
好这里会有一个新的

776
00:47:28,255 --> 00:47:29,279
我认为

777
00:47:29,535 --> 00:47:32,607
要在NOVA放之前

778
00:47:33,119 --> 00:47:34,143
之前

779
00:47:34,655 --> 00:47:36,191
做一些动作

780
00:47:36,703 --> 00:47:38,495
效率会更快

781
00:47:41,055 --> 00:47:47,199
如果没有先检查而像他这样先调用如果报就开始他找了

782
00:47:47,455 --> 00:47:53,599
二分查找开始在找虽然也可能还蛮快100万个月100万个元素后

783
00:47:53,855 --> 00:47:55,903
10000000个元素为要多少次

784
00:47:56,671 --> 00:47:57,439
搜寻呢

785
00:47:59,231 --> 00:48:00,511
总也要一些时间

786
00:48:03,327 --> 00:48:09,471
倒不如在这个之前先做一个非常简单的检查这块

787
00:48:09,983 --> 00:48:12,799
我认为这样的话呢会更快一些

788
00:48:14,079 --> 00:48:15,615
这是我的想法

789
00:48:21,247 --> 00:48:23,551
好这是我安排的最后一个

790
00:48:24,063 --> 00:48:25,343
算法的

791
00:48:25,599 --> 00:48:28,671
源代码或者其他精神的展示给他

792
00:48:29,439 --> 00:48:33,791
那算法我们前面提过有主要版本跟

793
00:48:34,047 --> 00:48:39,423
次要版本文较第2版本其中第2版本就要接受

794
00:48:39,679 --> 00:48:44,543
写东西一些夸t v的一些准则这些准则就是用

795
00:48:45,567 --> 00:48:49,663
方式显示出来

796
00:48:50,687 --> 00:48:54,783
这个就是六大部件的另外一个部件

797
00:48:55,039 --> 00:48:55,807
方程

798
00:48:56,575 --> 00:48:59,135
接下去就要谈这个主题
