1
00:00:07,424 --> 00:00:10,240
我要介绍的第2个容器是Master

2
00:00:11,776 --> 00:00:14,336
这个之前呢我来谈一下

3
00:00:14,592 --> 00:00:17,920
我们每个人写程序都会有一些自己的习惯

4
00:00:20,224 --> 00:00:25,600
我把一些我觉得蛮不错的我个人的习惯了也介绍给你

5
00:00:26,624 --> 00:00:32,768
我在写测试程序的时候写正规程序有可能可能不是这样但我在写

6
00:00:33,024 --> 00:00:36,608
写测试程序的时候我很希望每一段单元

7
00:00:37,632 --> 00:00:39,168
在一个独立的空间里头

8
00:00:40,192 --> 00:00:43,008
当然如果说每一个测试把它分成一个程序

9
00:00:43,520 --> 00:00:49,664
那是最独立的但是这样子又会很麻烦我还是很多测试放在同一个程序可是哪一部

10
00:00:49,920 --> 00:00:56,064
部分我希望非常独立比如说它的遍数我也许在十个测试以后我用的变速明天都一样

11
00:00:56,320 --> 00:00:57,600
我现在方便吗

12
00:00:57,856 --> 00:01:04,000
你告诉我们都一样我可能要include含入一些头文件我都尽量

13
00:01:04,256 --> 00:01:06,304
因此

14
00:01:06,560 --> 00:01:07,328
我会

15
00:01:07,584 --> 00:01:11,680
怎么没断测试像这样子放一个namespace

16
00:01:11,936 --> 00:01:18,080
我们我们开始上来看上也因为现在这个better他分两页最不太容易看得出来

17
00:01:18,336 --> 00:01:19,616
桑叶好了

18
00:01:20,384 --> 00:01:20,896
喂

19
00:01:21,664 --> 00:01:27,808
我会把整个程序整个测试放在namespace的55号看的84号

20
00:01:28,064 --> 00:01:29,600
夹起来最快

21
00:01:30,112 --> 00:01:32,160
因此在这里面的任何定义

22
00:01:32,672 --> 00:01:34,208
任何变量

23
00:01:34,464 --> 00:01:37,792
等等等都跟其他的namespace不会重

24
00:01:39,072 --> 00:01:40,864
这是我的第1个做法

25
00:01:41,120 --> 00:01:44,704
而且在这个namespace的没断因此我这个程序

26
00:01:44,960 --> 00:01:51,104
你拿到你就会看到20个namespace每个namespace上头会有

27
00:01:51,360 --> 00:01:54,176
这一个namespace的所需要的

28
00:01:54,944 --> 00:01:55,712
头文件

29
00:01:55,968 --> 00:02:00,064
这里的前面51到5次需要这一些头文件

30
00:02:00,576 --> 00:02:02,112
他也许在

31
00:02:02,880 --> 00:02:05,952
这是第1个单元的第5个单元呢

32
00:02:06,208 --> 00:02:10,048
我也要引入一些头文件跟这个是重复的

33
00:02:10,304 --> 00:02:15,424
没有关系因为头文件本身有一个保护机制引入两次无所谓

34
00:02:15,936 --> 00:02:18,752
那我们就可以再看也许你

35
00:02:19,264 --> 00:02:25,408
也许你一个月以后再看一次这个测试程序你这么每一段半圆它需要哪些投降就会非常清楚

36
00:02:25,664 --> 00:02:26,688
而不是

37
00:02:26,944 --> 00:02:29,248
大部分人习惯是把所有的

38
00:02:51,008 --> 00:02:51,776
定义

39
00:02:53,568 --> 00:02:54,592
很多人

40
00:02:54,848 --> 00:02:58,432
包括自己也是不会在韩集中在函数的最前面

41
00:02:59,968 --> 00:03:01,504
在写正规程序的时候是这样

42
00:03:02,272 --> 00:03:07,904
分析测试的程序测试程序有时候为了方便能够知道我在哪里

43
00:03:08,416 --> 00:03:09,696
定义了一个变量

44
00:03:09,952 --> 00:03:12,000
声明一个变量

45
00:03:12,256 --> 00:03:14,816
我不会做说牌的动作

46
00:03:15,072 --> 00:03:16,352
说你看这个地方

47
00:03:17,120 --> 00:03:19,424
这个函数里头的61行

48
00:03:19,936 --> 00:03:21,984
这是一个变量的声明

49
00:03:22,496 --> 00:03:23,520
电力

50
00:03:23,776 --> 00:03:25,568
63行又是一个变量

51
00:03:26,592 --> 00:03:28,128
73行又是一个

52
00:03:28,384 --> 00:03:30,176
这就是另外一个

53
00:03:32,992 --> 00:03:36,832
我知道大部分为习惯就是把这四个那先集中到

54
00:03:37,344 --> 00:03:38,880
函数一开始的地方

55
00:03:39,392 --> 00:03:40,672
这三个系统做法

56
00:03:41,184 --> 00:03:47,328
但我的习惯是在我要用到这个变量中我才去定义它

57
00:03:49,632 --> 00:03:51,168
所以就会散开来

58
00:03:51,680 --> 00:03:54,496
上开了我又不好找所以我就利用这种

59
00:03:56,288 --> 00:04:00,384
没有说白就突然这种形式就很好找

60
00:04:00,896 --> 00:04:07,040
这是我觉得还对我在线测试程序的时候方便的一些手法

61
00:04:07,808 --> 00:04:13,440
好我现在接下来我要介绍的就是vector这个容器

62
00:04:16,256 --> 00:04:22,143
在如今我提过了以后也许有十来种容器的

63
00:04:22,399 --> 00:04:27,519
我都分别在不同的函数不同的namespace的都不同的函数去测试它

64
00:04:28,799 --> 00:04:34,943
那么在面程序的我会问他问说你要多少个元素我这部分就没有

65
00:04:35,199 --> 00:04:41,343
没有表现在芯片上然后那个数字才会存进来所以他的96号会存进来

66
00:04:41,599 --> 00:04:42,367
哪一个词

67
00:04:42,879 --> 00:04:44,159
这就是我们要的

68
00:04:44,415 --> 00:04:45,439
元素的个数

69
00:04:45,951 --> 00:04:49,791
我现在吃了是吧他的长相是这样

70
00:04:50,047 --> 00:04:51,583
一端开口

71
00:04:52,095 --> 00:04:52,863
好

72
00:04:53,119 --> 00:04:56,191
我们怎么做呢104附录

73
00:04:57,471 --> 00:04:57,983
嗨

74
00:04:58,751 --> 00:04:59,775
从零

75
00:05:00,031 --> 00:05:01,567
到小于六

76
00:05:02,079 --> 00:05:05,151
这个就是问答是的了这是我的执行结果

77
00:05:05,407 --> 00:05:06,431
我选了2

78
00:05:06,687 --> 00:05:08,991
29进入vector的这一个

79
00:05:09,247 --> 00:05:10,271
范例

80
00:05:10,783 --> 00:05:13,599
要多少元素那我输入100万

81
00:05:14,623 --> 00:05:16,671
1000000于是这个for-loop

82
00:05:17,183 --> 00:05:20,255
104号洛克就从零到100万豪

83
00:05:20,767 --> 00:05:22,303
做什么事情

84
00:05:23,327 --> 00:05:25,375
108行push back

85
00:05:25,887 --> 00:05:32,031
Hbase master这个容器放元素的动作不许再放到无味

86
00:05:32,287 --> 00:05:33,055
尾巴的意思

87
00:05:33,311 --> 00:05:35,103
他没有不舒服了

88
00:05:35,871 --> 00:05:42,015
非常可以理解因为vector只有向后增长如果他提供一个不需

89
00:05:42,271 --> 00:05:43,039
Front给你

90
00:05:43,295 --> 00:05:48,159
你从这边插一个元素进去不得了他要全部往后推

91
00:05:49,695 --> 00:05:51,999
100万个元素要推100万次

92
00:05:52,511 --> 00:05:54,559
100万个考试

93
00:05:54,815 --> 00:05:55,583
构造函数

94
00:05:55,839 --> 00:05:58,655
1000000个destructor期关注要做

95
00:05:59,167 --> 00:06:00,191
很花时间

96
00:06:00,959 --> 00:06:01,983
所以他只有

97
00:06:04,543 --> 00:06:05,567
他几乎

98
00:06:07,359 --> 00:06:13,503
不是说所有了我不要讲所有的讲几乎所有大部分的容器的

99
00:06:13,759 --> 00:06:16,063
欧洲不是back这个合作

100
00:06:16,575 --> 00:06:20,415
从尾巴放远处进去谁在后面你会看到

101
00:06:20,671 --> 00:06:21,695
其他的

102
00:06:21,951 --> 00:06:22,975
10几个地址

103
00:06:23,231 --> 00:06:23,743
否

104
00:06:23,999 --> 00:06:28,607
大部分都是呼叫不具备但是有些不能回校不具备到时候再说

105
00:06:30,143 --> 00:06:31,423
所以

106
00:06:31,679 --> 00:06:33,727
100万个元素的空间

107
00:06:34,495 --> 00:06:35,263
那不是

108
00:06:35,775 --> 00:06:41,919
一开始到底多大呢100行这里没有指定大小啊所以他一开始你可以假设它是0没有

109
00:06:42,175 --> 00:06:42,687
没有元素

110
00:06:42,943 --> 00:06:44,991
然后放入粉100万次

111
00:06:45,759 --> 00:06:47,295
100万次地不需配合

112
00:06:47,807 --> 00:06:51,647
你就可以想象这个容器的就不断地成长了

113
00:06:51,903 --> 00:06:56,511
我在这边可以告诉各位图上没有表现出来的我可以告诉各位

114
00:06:56,767 --> 00:07:00,351
他这个master的增长两倍增长

115
00:07:00,863 --> 00:07:07,007
你可以这样想象一开始的明你放的一个元素进去分配去就是那种一个空间出来

116
00:07:07,519 --> 00:07:10,079
放第2个的时候那那空间不够了

117
00:07:10,591 --> 00:07:12,383
就两倍就变成两个

118
00:07:13,151 --> 00:07:16,735
放第3个的时候那个空间在两臂就变四个

119
00:07:17,247 --> 00:07:23,135
最空间是个人数但是放了只是因为但是只是放第3个元素为

120
00:07:24,159 --> 00:07:27,743
然后你放弃四个当你放第5个的时候

121
00:07:28,255 --> 00:07:29,023
又不够了

122
00:07:29,791 --> 00:07:32,863
雨势的空间会同四面城吧

123
00:07:34,143 --> 00:07:37,471
就这样两倍两倍的增长

124
00:07:38,495 --> 00:07:42,079
好放进去之后我们现在看一下执行结果

125
00:07:44,383 --> 00:07:49,503
放完之后呢我有呼叫一个函数叫做

126
00:07:50,527 --> 00:07:51,295
Site

127
00:07:52,063 --> 00:07:54,879
在的117号

128
00:07:55,391 --> 00:07:57,951
还有一个函数叫capacity

129
00:07:58,207 --> 00:08:02,047
Size就是真正元素的个数

130
00:08:02,303 --> 00:08:08,447
真正的元素个数competitive容量就是它到底目前空间有多大我们来看

131
00:08:08,703 --> 00:08:09,727
看看执行结果

132
00:08:14,079 --> 00:08:14,847
嘿

133
00:08:15,103 --> 00:08:16,639
黑色这个画面上

134
00:08:16,895 --> 00:08:18,943
Vector的size是1000000

135
00:08:19,199 --> 00:08:21,503
没错因为我们放了100万个元素

136
00:08:22,271 --> 00:08:24,063
The capacity呢

137
00:08:24,575 --> 00:08:26,111
1048576

138
00:08:27,391 --> 00:08:29,183
我刚刚提过他是两倍增长

139
00:08:29,439 --> 00:08:32,255
所以这个capacity一定要比赛吧

140
00:08:33,791 --> 00:08:38,655
这个数字初看之下对合理想和符合逻辑

141
00:08:43,007 --> 00:08:44,799
好回到程式吗这边来

142
00:08:45,823 --> 00:08:47,103
请注意这边

143
00:08:47,359 --> 00:08:49,919
在push back这个动作的外头

144
00:08:50,943 --> 00:08:54,271
我加了一个try catch

145
00:08:54,783 --> 00:08:57,599
Trident H是在抓取

146
00:08:58,879 --> 00:09:00,927
一场XXXX发生

147
00:09:01,439 --> 00:09:03,231
我为什么会特别这样设计呢

148
00:09:03,999 --> 00:09:04,767
因为

149
00:09:06,047 --> 00:09:06,815
我放了

150
00:09:07,071 --> 00:09:08,863
我要做100万次的不去呗

151
00:09:09,375 --> 00:09:11,167
翻译空间不够了

152
00:09:11,679 --> 00:09:13,471
他们100万个

153
00:09:14,751 --> 00:09:15,519
子串

154
00:09:16,287 --> 00:09:19,103
100行之理由器每个元素是个子字符串

155
00:09:19,359 --> 00:09:21,663
100万个字符串到底多大

156
00:09:23,199 --> 00:09:28,063
我先可以告诉你一个字符串的大小只是一个指针的大爷

157
00:09:29,599 --> 00:09:31,135
这是另外的话题

158
00:09:31,391 --> 00:09:32,415
是你不知道

159
00:09:32,671 --> 00:09:36,511
或者假设你放的变数很大因此100万个那个元素

160
00:09:37,023 --> 00:09:40,095
可能造成你跟本机的内存不够了

161
00:09:41,119 --> 00:09:43,935
所以我这边出来CAD试图去抓取

162
00:09:44,447 --> 00:09:47,007
尤其这个100万是我打进去的呀

163
00:09:48,031 --> 00:09:50,335
他说问我我就会打11呢

164
00:09:50,591 --> 00:09:51,871
中国有11人口

165
00:09:52,127 --> 00:09:54,431
我打11进去

166
00:09:55,455 --> 00:09:56,735
那能够复合吗

167
00:09:58,015 --> 00:10:01,855
不能付款的话它是会怎么样所以我用try catch去抓

168
00:10:03,647 --> 00:10:06,975
你现在看到我的话就是100万所以就是

169
00:10:07,231 --> 00:10:08,511
我的内存

170
00:10:08,767 --> 00:10:09,279
不多

171
00:10:09,791 --> 00:10:11,327
没有发生异常

172
00:10:12,095 --> 00:10:13,375
可是我这边有个注解

173
00:10:15,935 --> 00:10:22,079
曾经最高在这样的数量之后发出了一场Battle Kitty

174
00:10:24,127 --> 00:10:26,431
Battle cats就是他要不然内存

175
00:10:26,687 --> 00:10:32,831
每一次放元素进去分配器都要两倍增长的时候都要去挖内存要挖不到了

176
00:10:33,087 --> 00:10:33,855
我就会发出

177
00:10:34,111 --> 00:10:35,135
8k

178
00:10:37,183 --> 00:10:37,951
多少次

179
00:10:38,207 --> 00:10:41,023
个拾佰仟万是万千万

180
00:10:41,535 --> 00:10:47,423
28千万十万百万千万1800

181
00:10:47,679 --> 00:10:49,727
38万次的时候

182
00:10:51,263 --> 00:10:52,031
为什么不够

183
00:10:53,567 --> 00:10:57,663
这是我之所以这边要包装一个try catch的原因

184
00:10:58,687 --> 00:11:00,991
我想多少了解一下到底在

185
00:11:01,759 --> 00:11:03,551
容量可以达到多少

186
00:11:04,319 --> 00:11:09,183
万一发生异常的话题外话万一发生异常的话呢

187
00:11:09,439 --> 00:11:10,207
一定要

188
00:11:10,463 --> 00:11:11,231
破晓

189
00:11:11,999 --> 00:11:14,303
利用这个方式退出程序

190
00:11:16,351 --> 00:11:19,935
这次完全在我们的掌握之中的方法

191
00:11:21,727 --> 00:11:23,519
好所以现在的

192
00:11:23,775 --> 00:11:25,823
我就放了100万个什么

193
00:11:26,079 --> 00:11:29,663
随机数而且这个数把它变成了字符串

194
00:11:29,919 --> 00:11:30,943
放进去

195
00:11:31,711 --> 00:11:33,759
怎么样变成是不算107号

196
00:11:35,295 --> 00:11:37,343
AMD就是随机数码

197
00:11:37,599 --> 00:11:40,671
电池放到一个字符串联去

198
00:11:42,463 --> 00:11:46,303
好几页的下面我吃饭了

199
00:11:47,327 --> 00:11:50,399
呼叫哪些函数不止这些但是

200
00:11:50,655 --> 00:11:52,959
我找了几个对现在对大家有用的

201
00:11:57,311 --> 00:12:03,455
106行和前面的103行这两个就是夹住那个时间点刚刚

202
00:12:03,711 --> 00:12:04,735
也是过了

203
00:12:04,991 --> 00:12:09,343
这100万个元素分配以及放置发到多少时间呢

204
00:12:09,599 --> 00:12:10,623
花掉了

205
00:12:13,439 --> 00:12:15,487
3063

206
00:12:15,743 --> 00:12:16,511
好了

207
00:12:16,767 --> 00:12:18,303
三秒钟左右

208
00:12:19,071 --> 00:12:19,839
这么多时间

209
00:12:20,607 --> 00:12:25,215
后面所呼叫的东西这边都有输出我们来看一下一个

210
00:12:25,727 --> 00:12:26,495
目前

211
00:12:26,751 --> 00:12:28,799
这个容器的大小100万

212
00:12:30,079 --> 00:12:36,223
他的最前面那一个只是多少4047最后面那一个多少2877

213
00:12:38,527 --> 00:12:39,551
它的起始点

214
00:12:40,319 --> 00:12:43,391
这个呼叫data得到整个数组

215
00:12:44,415 --> 00:12:44,927
这个

216
00:12:45,439 --> 00:12:49,023
不是说vector set of vector的气

217
00:12:50,047 --> 00:12:53,887
这是一个连续空间它的起始点在什么位置这边可以打印出来

218
00:12:54,911 --> 00:12:55,935
Capacitor

219
00:12:56,447 --> 00:12:57,983
也打印出来了刚刚解释过了

220
00:12:59,775 --> 00:13:01,823
好使就是这夜的

221
00:13:02,079 --> 00:13:03,871
状况我们看下一页

222
00:13:04,383 --> 00:13:05,663
这个函数比较大

223
00:13:06,687 --> 00:13:08,479
这个很好是接续过来的

224
00:13:09,247 --> 00:13:11,039
现在124号

225
00:13:13,087 --> 00:13:14,879
Ssak3

226
00:13:15,135 --> 00:13:19,743
当前试过了一个辅助函数还要问我我想找找什么呀

227
00:13:20,255 --> 00:13:21,535
我就打进去了

228
00:13:21,791 --> 00:13:24,095
这个吧我打进去的只是多少呢

229
00:13:24,351 --> 00:13:26,143
23456

230
00:13:26,399 --> 00:13:32,543
我后面的每一次测试我都这么早我这他发给你之乱是谁技术让我总是

231
00:13:32,799 --> 00:13:33,823
123456

232
00:13:34,847 --> 00:13:37,919
有没有什么特殊意义就是作文我临时想到的一个字

233
00:13:38,175 --> 00:13:44,063
这样打进去之后他开始找了我们看看成是吗这边这边怎么找啊

234
00:13:44,831 --> 00:13:45,855
127号

235
00:13:46,623 --> 00:13:47,391
换

236
00:13:48,415 --> 00:13:49,695
这里就是吃饭的

237
00:13:49,951 --> 00:13:50,975
算法

238
00:13:51,231 --> 00:13:52,255
运用

239
00:13:53,791 --> 00:13:56,351
Cplusplus标准库有

240
00:13:56,607 --> 00:14:02,751
七80个吧90个算法其中有一个算法就会它是一个模板函数

241
00:14:03,007 --> 00:14:07,103
那是你在用无法看书的时候用法跟一般的函数是一样的

242
00:14:08,639 --> 00:14:09,663
叫唤

243
00:14:09,919 --> 00:14:11,967
打开查一查的规格需要

244
00:14:12,735 --> 00:14:14,527
需要你告诉他什么你就这么写

245
00:14:15,807 --> 00:14:20,159
这个翻译前面我刻意加了这个不好冒号双冒号

246
00:14:20,927 --> 00:14:23,743
这就是表示是一个全局的东西

247
00:14:24,511 --> 00:14:25,535
一切啊

248
00:14:26,047 --> 00:14:29,375
所有的算法都是一些全局的函数

249
00:14:29,887 --> 00:14:32,191
模板函数全局的模板

250
00:14:32,959 --> 00:14:37,567
所以虽然我127号如果没有写这个双冒号的话

251
00:14:38,335 --> 00:14:39,359
定义气

252
00:14:40,383 --> 00:14:46,527
找不到发在这个score把这个作用域怎么找不到饭他也会到全局去找

253
00:14:47,295 --> 00:14:48,063
找得到

254
00:14:48,831 --> 00:14:52,415
只是我这边120期把它写得更明白一些

255
00:14:54,719 --> 00:14:56,767
好我要找这个数值

256
00:14:57,023 --> 00:14:57,791
找到了吗

257
00:14:59,071 --> 00:14:59,839
100

258
00:15:00,607 --> 00:15:01,375
30号

259
00:15:02,399 --> 00:15:08,543
如果找到了他不等于他没有走到最伟发表什么找到了我就把它印出来

260
00:15:11,359 --> 00:15:12,895
没找到也应出来

261
00:15:13,151 --> 00:15:14,943
执行的结果是什么在右手边

262
00:15:16,223 --> 00:15:17,503
找到了fine

263
00:15:17,759 --> 00:15:20,063
23456我要找这个词

264
00:15:20,831 --> 00:15:22,367
花掉多少时间呢

265
00:15:22,879 --> 00:15:26,463
花掉了276毫秒

266
00:15:27,999 --> 00:15:31,583
每次执行行都不一样给大家一一次的感受

267
00:15:31,839 --> 00:15:33,631
花掉这么多时间

268
00:15:36,447 --> 00:15:38,495
我们仔细看一下这个城市吗

269
00:15:40,543 --> 00:15:41,311
爱吗

270
00:15:42,079 --> 00:15:43,103
127号

271
00:15:44,639 --> 00:15:48,479
这个帆船回来的其实是个

272
00:15:49,759 --> 00:15:55,903
但是前面我介绍过iterator那个类型学起来很长我不想写了

273
00:15:56,415 --> 00:15:58,463
所以我这边就用Auto

274
00:16:00,767 --> 00:16:03,327
440 Auto用法给你看

275
00:16:04,095 --> 00:16:07,423
这个iterator如果找到

276
00:16:08,191 --> 00:16:11,263
如果找到了这个你要的目标的话

277
00:16:11,775 --> 00:16:15,359
这个iterator在131号

278
00:16:16,127 --> 00:16:17,663
我叫价参考

279
00:16:18,175 --> 00:16:20,223
曲直

280
00:16:21,247 --> 00:16:22,783
所以

281
00:16:23,551 --> 00:16:25,343
右边这个执行结果

282
00:16:26,111 --> 00:16:28,159
放找到了

283
00:16:29,183 --> 00:16:31,999
123456这个值

284
00:16:32,511 --> 00:16:34,815
不是我前面打进去认识

285
00:16:35,327 --> 00:16:40,191
是他找到了之后根据那个iterator去取值取出来的

286
00:16:44,799 --> 00:16:46,335
确认这一点

287
00:16:48,895 --> 00:16:51,711
好啊他这个存这一个

288
00:16:52,735 --> 00:16:58,879
韩束的这夜有没有两页啊在这一页的上半部分下班

289
00:16:59,135 --> 00:17:02,207
我做了两次两个不同的动作

290
00:17:02,463 --> 00:17:03,999
下班不做了什么动作呢

291
00:17:04,511 --> 00:17:07,071
138号我做了一次手

292
00:17:08,351 --> 00:17:09,119
还有呢

293
00:17:09,887 --> 00:17:11,679
做了一次binary search

294
00:17:12,959 --> 00:17:14,239
也就是说

295
00:17:15,519 --> 00:17:18,591
我上下两段用不同的

296
00:17:18,847 --> 00:17:19,871
查找的方式

297
00:17:20,127 --> 00:17:22,175
我想看看速度怎么样

298
00:17:22,431 --> 00:17:24,991
上面这一种我用的是bind

299
00:17:26,015 --> 00:17:30,367
标准库的算法方案他告诉你他是循序查找

300
00:17:31,135 --> 00:17:32,415
那就看运气了

301
00:17:32,671 --> 00:17:34,463
没有100万个元素

302
00:17:35,231 --> 00:17:37,535
他是在的林格还是在的

303
00:17:37,791 --> 00:17:39,327
100万根的地方了

304
00:17:39,583 --> 00:17:40,607
看运气

305
00:17:40,863 --> 00:17:42,911
我们刚刚花掉的事

306
00:17:44,191 --> 00:17:45,471
拔掉多少秒啊

307
00:17:45,983 --> 00:17:47,263
花掉了

308
00:17:48,287 --> 00:17:50,335
找不到了

309
00:17:55,199 --> 00:17:55,967
0

310
00:17:57,503 --> 00:18:01,343
花掉零个号表示他一下就找到了运气很好

311
00:18:01,599 --> 00:18:02,111
0

312
00:18:04,415 --> 00:18:06,207
下面这个打法是怎么样呢

313
00:18:07,743 --> 00:18:13,631
早早早早是在这个地139号发音的research in search

314
00:18:14,655 --> 00:18:16,447
这个不是标准库提供的

315
00:18:17,727 --> 00:18:23,615
打错了这不是是一家家标准提供了这是基本身以前就有了

316
00:18:23,871 --> 00:18:26,943
This original research他应该说比较快

317
00:18:27,711 --> 00:18:29,759
按理说它比较快

318
00:18:30,015 --> 00:18:32,575
但是他早之前要显瘦

319
00:18:33,087 --> 00:18:34,879
所以在这个的上扬

320
00:18:36,927 --> 00:18:41,279
副教授的这个数是11加加标准库

321
00:18:41,535 --> 00:18:45,119
提供的吧90个算法里面的一个数

322
00:18:46,911 --> 00:18:49,727
所以我先说了一遍然后二分查找

323
00:18:50,239 --> 00:18:51,519
花了多少时间呢

324
00:18:57,407 --> 00:18:59,967
2765个毫秒

325
00:19:01,503 --> 00:19:03,295
这个有没有颠覆你的印象

326
00:19:04,831 --> 00:19:05,599
什么印象

327
00:19:06,111 --> 00:19:09,951
我这里有两次的早的方法第1个着法式

328
00:19:10,207 --> 00:19:15,071
循序查找按理说他比较慢但是他花了零秒

329
00:19:15,839 --> 00:19:21,983
后面是二分查找按理说他比较快但是他花掉了2760

330
00:19:22,239 --> 00:19:23,263
毫秒

331
00:19:25,311 --> 00:19:30,431
黑价是因为后面这个人找比较快的是早之前他要说

332
00:19:30,943 --> 00:19:33,247
所以时间都花在受到的造句

333
00:19:35,295 --> 00:19:36,063
这这边

334
00:19:36,319 --> 00:19:37,087
子

335
00:19:38,111 --> 00:19:44,255
算是提醒我已经把在押注一件事情不要总是觉得纤瘦的然后binaries

336
00:19:44,511 --> 00:19:45,535
设计比较快

337
00:19:45,791 --> 00:19:47,839
也许说的本身就很慢

338
00:19:49,375 --> 00:19:53,215
当然只是这么一个例子并不注意表现

339
00:19:53,471 --> 00:19:55,263
太多的遗憾

340
00:19:56,031 --> 00:19:57,311
反正有这么一次结果

341
00:19:57,823 --> 00:19:59,103
我要做提醒

342
00:20:00,895 --> 00:20:04,223
好这就是我的第2个中兴

343
00:20:05,759 --> 00:20:08,063
Vector的特性是什么

344
00:20:08,575 --> 00:20:10,623
就是在内存里面呢

345
00:20:10,879 --> 00:20:12,159
他是可以往

346
00:20:12,671 --> 00:20:13,695
火葬

347
00:20:14,207 --> 00:20:19,327
只能往后扩展而扩展的方式是两倍或者

348
00:20:23,935 --> 00:20:24,959
好的是我们

349
00:20:25,215 --> 00:20:26,495
这个容器
