<!DOCTYPE html>
<!-- saved from url=(0047)https://www.cnblogs.com/yan1345/p/13928915.html -->
<html lang="zh-cn" style="--olcb-folder-code-block-max-height:80vh;"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="referrer" content="origin-when-cross-origin">
    <meta name="description" content="C++面向对象开发上 培养正规的、大气的编程习惯 0. 面向对象三大特征 —— 封装、继承、多态 封装 把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信">
    <meta property="og:description" content="C++面向对象开发上 培养正规的、大气的编程习惯 0. 面向对象三大特征 —— 封装、继承、多态 封装 把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信">
    <meta http-equiv="Cache-Control" content="no-transform">
    <meta http-equiv="Cache-Control" content="no-siteapp">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>C++面向对象笔记_上（侯捷老师视频） - yzhu798 - 博客园</title>
    <link id="favicon" rel="shortcut icon" href="https://common.cnblogs.com/favicon.svg" type="image/svg+xml">
    
    <style>:not(.cnblogs_code):not(.cnblogs_Highlighter)>pre:not([highlighted]):not([class*="brush:"]) code:not(.hljs) {background: rgb(245, 245, 245);
        padding: 12px;
        border: 1px solid rgb(204, 204, 204);
        border-radius: 3px;
        border-color: transparent;
        color: rgb(68, 68, 68);
        font-family: "Courier New", sans-serif;
        font-size: 12px}</style><link rel="stylesheet" href="./C++面向对象笔记_上（侯捷老师视频） - yzhu798 - 博客园_files/blog-common.min.css">
    <link id="MainCss" rel="stylesheet" href="./C++面向对象笔记_上（侯捷老师视频） - yzhu798 - 博客园_files/bundle-simplememory.min.css">
    <link id="highlighter-theme-cnblogs" type="text/css" rel="stylesheet" href="./C++面向对象笔记_上（侯捷老师视频） - yzhu798 - 博客园_files/cnblogs.css">
    <link type="text/css" rel="stylesheet" href="./C++面向对象笔记_上（侯捷老师视频） - yzhu798 - 博客园_files/custom.css">
    <link id="mobile-style" media="only screen and (max-width: 767px)" type="text/css" rel="stylesheet" href="./C++面向对象笔记_上（侯捷老师视频） - yzhu798 - 博客园_files/bundle-SimpleMemory-mobile.min.css">
    
    
    
    <link type="application/rss+xml" rel="alternate" href="https://www.cnblogs.com/yan1345/rss">
    <link type="application/rsd+xml" rel="EditURI" href="https://www.cnblogs.com/yan1345/rsd.xml">
    <link type="application/wlwmanifest+xml" rel="wlwmanifest" href="https://www.cnblogs.com/yan1345/wlwmanifest.xml">
    <script type="text/javascript" async="" src="./C++面向对象笔记_上（侯捷老师视频） - yzhu798 - 博客园_files/analytics.js.下载"></script><script>
        var currentBlogId = 165136;
        var currentBlogApp = 'yan1345';
        var isLogined = false;
        var isBlogOwner = false;
        var skinName = 'SimpleMemory';
        var visitorUserId = '';
        var hasCustomScript = false;
        try {
            if (hasCustomScript && document.referrer && document.referrer.indexOf('baidu.com') >= 0) {
                Object.defineProperty(document, 'referrer', { value: '' });
                Object.defineProperty(Document.prototype, 'referrer', { get: function(){ return ''; } });
            }
        } catch(error) { }
        window.cb_enable_mathjax = false;
        window.mathEngine = 0;
        window.codeHighlightEngine = 1;
        window.enableCodeLineNumber = false;
        window.codeHighlightTheme = 'cnblogs';
        window.isDarkCodeHighlightTheme = false;
        window.isDisableCodeHighlighter = false;
    </script>
        <script>
            var currentPostDateAdded = '2020-11-04 21:54';
        </script>
    <script src="./C++面向对象笔记_上（侯捷老师视频） - yzhu798 - 博客园_files/jquery-2.2.0.min.js.下载"></script>
    <script src="./C++面向对象笔记_上（侯捷老师视频） - yzhu798 - 博客园_files/blog-common.min.js.下载"></script><style>.medium-zoom-overlay {
  position: fixed;
  top: 0;
  right: 0;
  bottom: 0;
  left: 0;
  opacity: 0;
  transition: opacity 300ms;
  will-change: opacity;
}

.medium-zoom--opened .medium-zoom-overlay {
  cursor: pointer;
  cursor: zoom-out;
  opacity: 1;
}

.medium-zoom-image {
  cursor: pointer;
  cursor: zoom-in;
  /*
    The `transition` is marked as "!important" for the animation to happen
    even though it's overriden by another inline `transition` style attribute.

    This is problematic with frameworks that generate inline styles on their
    images (e.g. Gatsby).

    See https://github.com/francoischalifour/medium-zoom/issues/110
   */
  transition: transform 300ms cubic-bezier(0.2, 0, 0.2, 1) !important;
}

.medium-zoom-image--hidden {
  visibility: hidden;
}

.medium-zoom-image--opened {
  position: relative;
  cursor: pointer;
  cursor: zoom-out;
  will-change: transform;
}
</style><script id="hljs-script" src="./C++面向对象笔记_上（侯捷老师视频） - yzhu798 - 博客园_files/highlight.min.js.下载" type="text/javascript" defer=""></script>    
    
</head>
<body class="skin-simplememory no-navbar hljs-engine">
<a name="top"></a>
<div id="top_nav" class="navbar forpc navbar-custom">
    <nav id="nav_main" class="navbar-main">
        <ul id="nav_left" class="navbar-list navbar-left">
            <li class="navbar-branding">
                <a href="https://www.cnblogs.com/" title="开发者的网上家园" role="banner">
                    <img src="./C++面向对象笔记_上（侯捷老师视频） - yzhu798 - 博客园_files/logo.svg" alt="博客园Logo">
                </a>
            </li>
            <li>
                <a href="https://www.cnblogs.com/" onclick="countClicks(&#39;skin-navbar-sitehome&#39;)">首页</a>
            </li>
            <li>
                <a href="https://news.cnblogs.com/" onclick="countClicks(&#39;nav&#39;, &#39;skin-navbar-news&#39;)">新闻</a>
            </li>
            <li>
                <a href="https://q.cnblogs.com/" onclick="countClicks(&#39;nav&#39;, &#39;skin-navbar-q&#39;)">博问</a>
            </li>
            <li>
                <a id="nav_brandzone" href="https://brands.cnblogs.com/" onclick="countClicks(&#39;nav&#39;, &#39;skin-navbar-brands&#39;)">专区</a>
            </li>
            <li>
                <a href="https://ing.cnblogs.com/" onclick="countClicks(&#39;nav&#39;, &#39;skin-navbar-ing&#39;)">闪存</a>
            </li>
            <li>
                <a href="https://edu.cnblogs.com/" onclick="countClicks(&#39;nav&#39;, &#39;skin-navbar-edu&#39;)">班级</a>
            </li>
        </ul>
        <ul id="nav_right" class="navbar-list navbar-right">
            <li>
                <form id="zzk_search" class="navbar-search" action="https://zzk.cnblogs.com/s" method="get" role="search">
                    <input name="w" id="zzk_search_input" placeholder="代码改变世界" type="search" tabindex="3">
                    <button type="submit" id="zzk_search_button">
                        <img src="./C++面向对象笔记_上（侯捷老师视频） - yzhu798 - 博客园_files/search.svg" alt="搜索">
                    </button>
                </form>
            </li>
            <li id="navbar_login_status" class="navbar-list">
                <a class="navbar-user-info navbar-blog" href="https://i.cnblogs.com/EditPosts.aspx?opt=1" alt="写随笔" title="写随笔" style="display: none;">
                    <img id="new_post_icon" class="navbar-icon" src="./C++面向对象笔记_上（侯捷老师视频） - yzhu798 - 博客园_files/newpost.svg" alt="写随笔">
                </a>
                <a id="navblog-myblog-icon" class="navbar-user-info navbar-blog" href="https://passport.cnblogs.com/GetBlogApplyStatus.aspx" alt="我的博客" title="我的博客" style="display: none;">
                    <img id="myblog_icon" class="navbar-icon" src="./C++面向对象笔记_上（侯捷老师视频） - yzhu798 - 博客园_files/myblog.svg" alt="我的博客">
                </a>
                <a class="navbar-user-info navbar-message navbar-icon-wrapper" href="https://msg.cnblogs.com/" alt="短消息" title="短消息" style="display: none;">
                    <img id="msg_icon" class="navbar-icon" src="./C++面向对象笔记_上（侯捷老师视频） - yzhu798 - 博客园_files/message.svg" alt="短消息">
                    <span id="msg_count" style="display: none"></span>
                </a>
                <a id="navbar_lite_mode_indicator" data-current-page="blog" style="display: none" href="javascript:void(0)" alt="简洁模式" title="简洁模式启用，您在访问他人博客时会使用简洁款皮肤展示">
                    <img class="navbar-icon" src="./C++面向对象笔记_上（侯捷老师视频） - yzhu798 - 博客园_files/lite-mode-on.svg" alt="简洁模式">
                </a>
                <div id="user_info" class="navbar-user-info dropdown" style="display: none;">
                    <a class="dropdown-button" href="https://home.cnblogs.com/">
                        <img id="user_icon" class="navbar-avatar" src="./C++面向对象笔记_上（侯捷老师视频） - yzhu798 - 博客园_files/avatar-default.svg" alt="用户头像">
                    </a>
                    <div class="dropdown-menu">
                        <a id="navblog-myblog-text" href="https://passport.cnblogs.com/GetBlogApplyStatus.aspx">我的博客</a>
                        <a href="https://home.cnblogs.com/">我的园子</a>
                        <a href="https://account.cnblogs.com/settings/account">账号设置</a>
                        <a href="javascript:void(0)" id="navbar_lite_mode_toggle" title="简洁模式会使用简洁款皮肤显示所有博客">
    简洁模式 <img id="navbar_lite_mode_on" src="./C++面向对象笔记_上（侯捷老师视频） - yzhu798 - 博客园_files/lite-mode-check.svg" class="hide"><span id="navbar_lite_mode_spinner" class="hide">...</span>
</a>
                        <a href="javascript:void(0)" onclick="account.logout();">退出登录</a>
                    </div>
                </div>
                <a class="navbar-anonymous" href="https://account.cnblogs.com/signup" style="display: inline;">注册</a>
                <a class="navbar-anonymous" href="javascript:void(0);" onclick="account.login()" style="display: inline;">登录</a>
            </li>
        </ul>
    </nav>
</div>

<div id="page_begin_html">

<div>
<a href="https://github.com/yzhu798">
<img id="githubRibbon" width="149" height="149" src="https://github.blog/wp-content/uploads/2008/12/forkme_right_darkblue_121621.png?resize=149%2C149" class="attachment-full size-full" alt="Fork me on GitHub" data-recalc-dims="1" style="cursor: pointer; position: fixed; top: 0; right: 0; border: 0; z-index: 9999">
</a>
</div>

</div>

<!--done-->
<div id="home">
<div id="header">
	<div id="blogTitle">
        <a id="lnkBlogLogo" href="https://www.cnblogs.com/yan1345/"><img id="blogLogo" src="./C++面向对象笔记_上（侯捷老师视频） - yzhu798 - 博客园_files/logo.gif" alt="返回主页"></a>		
		
<!--done-->
<h1><a id="Header1_HeaderTitle" class="headermaintitle HeaderMainTitle" href="https://www.cnblogs.com/yan1345/">yzhu798</a>
</h1>
<h2></h2>




		
	</div><!--end: blogTitle 博客的标题和副标题 -->
	<div id="navigator">
		
<ul id="navList">
<li><a id="blog_nav_sitehome" class="menu" href="https://www.cnblogs.com/">
博客园</a>
</li>
<li>
<a id="blog_nav_myhome" class="menu" href="https://www.cnblogs.com/yan1345/">
首页</a>
</li>
<li>

<a id="blog_nav_newpost" class="menu" href="https://i.cnblogs.com/EditPosts.aspx?opt=1">
新随笔</a>
</li>
<li>
<a id="blog_nav_contact" class="menu" href="https://msg.cnblogs.com/send/yzhu798">
联系</a></li>
<li>
<a id="blog_nav_rss" class="menu" href="javascript:void(0)" data-rss="https://www.cnblogs.com/yan1345/rss/">
订阅</a>
<!--<partial name="./Shared/_XmlLink.cshtml" model="Model" /></li>--></li>
<li>
<a id="blog_nav_admin" class="menu" href="https://i.cnblogs.com/">
管理</a>
</li>
</ul>


		<div class="blogStats">
			<span id="stats_post_count">随笔 - 25&nbsp; </span>
<span id="stats_article_count">文章 - 1&nbsp; </span>
<span id="stats-comment_count">评论 - 0&nbsp; </span>
<span id="stats-total-view-count">阅读 - 
<span title="总阅读数: 5959">
5959</span></span>

		</div><!--end: blogStats -->
	</div><!--end: navigator 博客导航栏 -->
</div><!--end: header 头部 -->
<div id="main">
	<div id="mainContent">
	<div class="forFlow">
		<div id="post_detail">
    <!--done-->
    <div id="topics">
        <div class="post">
            <h1 class="postTitle">
                
<a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/yan1345/p/13928915.html">
    <span role="heading" aria-level="2">C++面向对象笔记_上（侯捷老师视频）</span>
    
</a><button class="cnblogs-toc-button" title="显示目录导航" aria-expanded="false"></button>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h1 id="c面向对象开发上">C++面向对象开发上<button class="cnblogs-toc-button" title="显示目录导航" aria-expanded="false"></button></h1>
<blockquote>
<p>培养正规的、大气的编程习惯</p>
</blockquote>
<h2 id="0-面向对象三大特征--封装继承多态">0. 面向对象三大特征 —— 封装、继承、多态<button class="cnblogs-toc-button" title="显示目录导航" aria-expanded="false"></button></h2>
<h3 id="封装">封装<button class="cnblogs-toc-button" title="显示目录导航" aria-expanded="false"></button></h3>
<ul>
<li>把客观事物封装成抽象的类，并且类可以把自己的<strong>数据和方法</strong>只让<strong>可信的类或者对象操作</strong>，对<strong>不可信的进行信息隐藏</strong>。</li>
</ul>
<h3 id="继承">继承<button class="cnblogs-toc-button" title="显示目录导航" aria-expanded="false"></button></h3>
<ul>
<li>基类（父类）——&gt; 派生类（子类）</li>
</ul>
<h3 id="多态">多态<button class="cnblogs-toc-button" title="显示目录导航" aria-expanded="false"></button></h3>
<ul>
<li>多态，是<strong>以封装和继承为基础</strong>，使得消息可以<strong>多种形式显示</strong>。</li>
</ul>
<h4 id="0-c-多态分类及实现">0) C++ 多态分类及实现：<button class="cnblogs-toc-button" title="显示目录导航" aria-expanded="false"></button></h4>
<ol>
<li><strong>重载多态</strong>（Ad-hoc Polymorphism，编译期）：<strong>函数、运算符</strong>重载</li>
<li><strong>子类型多态</strong>（Subtype Polymorphism，运行期）：<strong>虚函数</strong></li>
<li><strong>参数多态性</strong>（Parametric Polymorphism，编译期）：<strong>类模板、函数模板</strong></li>
<li><strong>强制多态</strong>（Coercion Polymorphism，编译期/运行期）：基本<strong>类型转换</strong>、自定义类型转换<br>
The Four Polymorphisms in C++</li>
</ol>
<h4 id="1-静态多态编译期早绑定-函数重载">1) 静态多态（编译期/早绑定） 函数重载<button class="cnblogs-toc-button" title="显示目录导航" aria-expanded="false"></button></h4>
<pre class="highlighter-hljs" highlighted="true" has-selection="true"><code class="language-cpp highlighter-hljs hljs"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>
{
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">do</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span></span>;
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">do</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span>;
};
<span class="hljs-comment">//参数多态性</span>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Complex</span>{
	T re, im;
<span class="hljs-keyword">public</span>:
    <span class="hljs-built_in">Complex</span>(T re, T im) {}
};
<span class="hljs-built_in">Complex</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">5</span>, <span class="hljs-number">4</span>);
<span class="hljs-built_in">Complex</span>&lt;<span class="hljs-type">float</span>&gt;(<span class="hljs-number">5.0</span>, <span class="hljs-number">4.0</span>);
</code></pre>
<h4 id="2-动态多态运行期期晚绑定虚函数">2) 动态多态（运行期期/晚绑定）虚函数<button class="cnblogs-toc-button" title="显示目录导航" aria-expanded="false"></button></h4>
<ul>
<li>
<p>虚函数：</p>
<p>用 virtual 修饰<strong>成员函数（含基类的虚构函数）</strong>，使其成为虚函数.</p>
</li>
<li>
<p>非虚函数：</p>
</li>
</ul>
<blockquote>
<ol>
<li>普通（全局）函数（非类成员函数）</li>
<li>静态函数（static）</li>
<li>构造函数（因为在调用构造函数时，虚表指针并没有在对象的内存空间中，必须要<strong>构造函数调用完成后才会形成虚表指针</strong>）</li>
<li><strong>内联函数</strong>不能是表现多态性时的虚函数，解释见：虚函数（virtual）可以是内联函数（inline）吗？</li>
</ol>
</blockquote>
<h2 id="一c编程简介">一、C++编程简介<button class="cnblogs-toc-button" title="显示目录导航" aria-expanded="false"></button></h2>
<h3 id="基础知识">基础知识<button class="cnblogs-toc-button" title="显示目录导航" aria-expanded="false"></button></h3>
<blockquote>
<p>曾学过procedural language (C 语言最佳)，知道如何对程序编译、链接、执行。</p>
<p>变量(variables)</p>
<p>类型(types) : int, float, char, struct …</p>
<p>作用域(scope)</p>
<p>循环(loops) : while, for,</p>
<p>流程控制: if-else, switch-case</p>
</blockquote>
<h4 id="基于对象分类">基于对象分类：<button class="cnblogs-toc-button" title="显示目录导航" aria-expanded="false"></button></h4>
<ol>
<li>
<p>基于对象：一个class的编程 object based</p>
</li>
<li>
<p>面向对象：几个class的编程 object oriented</p>
</li>
</ol>
<h4 id="class的经典分类">class的经典分类：<button class="cnblogs-toc-button" title="显示目录导航" aria-expanded="false"></button></h4>
<ol>
<li>class without pointer members&nbsp;——&gt;e.g: <strong>complex 复数</strong></li>
<li>class with pointer members&nbsp; ——&gt;e.g: <strong>string 字符串</strong></li>
</ol>
<h4 id="class之间的关系">class之间的关系：<button class="cnblogs-toc-button" title="显示目录导航" aria-expanded="false"></button></h4>
<ol>
<li>继承inheritance、</li>
<li>复合composition</li>
<li>委托delegation</li>
</ol>
<h4 id="c书籍stl是标准库的前身">C++书籍（STL是标准库的前身）<button class="cnblogs-toc-button" title="显示目录导航" aria-expanded="false"></button></h4>
<p>基础：Language<br>
《C++Primer》<br>
《C++programming Language》<br>
提高：Standard Library<br>
《Effective C++ Third Edition》及中文<br>
《The C++ Standard Library》<br>
《STL源码剖析》</p>
<h2 id="二头文件与类的声明">二、头文件与类的声明<button class="cnblogs-toc-button" title="显示目录导航" aria-expanded="false"></button></h2>
<pre class="highlighter-hljs" highlighted="true"><code class="language-cpp highlighter-hljs hljs">
<span class="hljs-comment">//flie XXX.h</span>
<span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> __complex__</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span>&nbsp;__complex__</span>


<span class="hljs-meta">#program once <span class="hljs-comment">//编译器宏</span></span>


<span class="hljs-comment">// class的布局：</span>

<span class="hljs-keyword">class</span> <span class="hljs-title class_">base</span>; <span class="hljs-comment">//前置声明</span>

<span class="hljs-keyword">class</span> <span class="hljs-title class_">header</span>{<span class="hljs-comment">// class header</span>
    <span class="hljs-comment">// class body</span>
     ...
}

<span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">//XXX.h end</span></span>

<span class="hljs-comment">// XXX.cpp</span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">"XXX.h"</span>   <span class="hljs-comment">//c</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span>  <span class="hljs-comment">//C++ </span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span>
</code></pre>
<h2 id="三构造函数">三、构造函数<button class="cnblogs-toc-button" title="显示目录导航" aria-expanded="false"></button></h2>
<h3 id="1inline内联函数">（1）inline内联函数：<button class="cnblogs-toc-button" title="显示目录导航" aria-expanded="false"></button></h3>
<blockquote>
<p>特征（程序员期望能inline，编译器决定是否inline）</p>
<ol>
<li>相当于把内联函数里面的内容<strong>写在调用内联函数处</strong>；</li>
<li>相当于不用执行进入函数的步骤，<strong>直接执行函数体</strong>；</li>
<li>相当于宏，却比宏多了类型检查，真正<strong>具有函数特性</strong>；</li>
<li>编译器一般<strong>不内联</strong>包含<strong>循环、递归、switch</strong> 等复杂操作的内联函数；</li>
<li>在类声明中定义的函数，<strong>除了虚函数</strong>的其他函数都会自动隐式地当成内联函数。</li>
</ol>
</blockquote>
<pre class="highlighter-hljs" highlighted="true"><code class="language-cpp highlighter-hljs hljs"><span class="hljs-comment">//--------------------------声明-----------------------------------------------</span>
<span class="hljs-comment">// 声明1（加 inline，建议使用）</span>
<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">functionName</span><span class="hljs-params">(<span class="hljs-type">int</span> first, <span class="hljs-type">int</span> second,...)</span></span>;
<span class="hljs-comment">// 声明2（不加 inline）</span>
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">functionName</span><span class="hljs-params">(<span class="hljs-type">int</span> first, <span class="hljs-type">int</span> second,...)</span></span>;’

<span class="hljs-comment">//--------------------------定义-----------------------------------------------</span>
<span class="hljs-comment">// 类内定义并实现，隐式内联</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> {
    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">doA</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; }         <span class="hljs-comment">// 隐式内联</span>
}
<span class="hljs-comment">// 类外定义，需要显式内联</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> {
    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">doA</span><span class="hljs-params">()</span></span>;
    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">functionName</span><span class="hljs-params">(<span class="hljs-type">int</span> first, <span class="hljs-type">int</span> second,...)</span></span>;
}
<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">A::doA</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; }   <span class="hljs-comment">// 需要显式内联</span>
<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">functionName</span><span class="hljs-params">(<span class="hljs-type">int</span> first, <span class="hljs-type">int</span> second,...)</span> </span>{<span class="hljs-comment">/** ...**/</span>};<span class="hljs-comment">// 需要显式内联</span>
</code></pre>
<h4 id="编译器对-inline-函数的处理步骤">编译器对 <code>inline</code> 函数的处理步骤<button class="cnblogs-toc-button" title="显示目录导航" aria-expanded="false"></button></h4>
<blockquote>
<ol>
<li>将 <code>inline</code> 函数体<strong>复制</strong>到 <code>inline</code> 函数<strong>调用点处</strong>；</li>
<li>为所用<code>inline</code>函数中的局部变量<strong>分配内存</strong>空间；</li>
<li>将<code>inline</code>函数的输入<strong>参数和返回值映射到调用方法的局部变量</strong>空间中；</li>
<li>如果<code>inline</code>函数有多个返回点，将其转变为<code>inline</code>函数代码块末尾的分支（使用GOTO）</li>
</ol>
</blockquote>
<h4 id="优缺点-主要与宏定义比较">优缺点 <strong>主要与宏定义</strong>比较<button class="cnblogs-toc-button" title="显示目录导航" aria-expanded="false"></button></h4>
<blockquote>
<p>优点</p>
<ol>
<li>内联函数同宏函数一样将在被调用处进行代码展开，省去了参数压栈、栈帧开辟与回收，结果返回等，从而<strong>提高程序运行速度</strong>。</li>
<li>内联函数相比宏函数来说，在代码展开时，会做<strong>安全检查或自动类型转换</strong>（同普通函数），而宏定义则不会。</li>
<li>在类中声明同时定义的成员函数，自动转化为内联函数，因此内联函数<strong>可以访问类的成员变量</strong>，宏定义则不能。</li>
<li>内联函数在运行时<strong>可调试</strong>，而宏定义不可以。</li>
</ol>
</blockquote>
<blockquote>
<p>缺点</p>
<ol>
<li><strong>代码膨胀</strong>。内联是以代码膨胀（复制）为代价，消除函数调用带来的开销。如果执行函数体内代码的时间，相比于函数调用的开销较大，那么效率的收获会很少。另一方面，每一处内联函数的调用都要复制代码，将使程序的<strong>总代码量增大，消耗更多的内存空间</strong>。</li>
<li>inline 函数<strong>无法随着函数库升级</strong>而升级。inline函数的改变需要重新编译，不像 non-inline 可以直接链接。</li>
<li>是否内联，<strong>程序员不可控</strong>。内联函数只是对编译器的建议，是否对函数内联，决定权在于编译器。</li>
</ol>
</blockquote>
<h3 id="2access-level-访问级别">（2）access level 访问级别<button class="cnblogs-toc-button" title="显示目录导航" aria-expanded="false"></button></h3>
<blockquote>
<p><code>public</code> 成员：可以被任意实体访问<br>
<code>private</code> 成员：只允许被<strong>本类</strong>的成员函数访问<br>
<code>protected</code> 成员：只允许被<strong>子类</strong>及本类的成员函数访问（虚函数使用较多）</p>
<p><code>private</code>：数据的部分用尽量用<code>private</code><br>
<code>public</code>：函数的部分，大部分用<code>public</code></p>
</blockquote>
<h3 id="3构造函数">（3）构造函数<button class="cnblogs-toc-button" title="显示目录导航" aria-expanded="false"></button></h3>
<p>创建一个对象的时候，构造函数自动被调用，构造函数可设置默认参数，并设置参数初始化列表：</p>
<pre class="highlighter-hljs" highlighted="true"><code class="language-cpp highlighter-hljs hljs"><span class="hljs-built_in">pair</span>(<span class="hljs-type">const</span> T1&amp; a, <span class="hljs-type">const</span> T2&amp; b) : <span class="hljs-built_in">first</span>(a), <span class="hljs-built_in">second</span>(b) {}
</code></pre>
<p>参数<code>initializition list</code>和在<code>body</code>里对参数赋值的区别：</p>
<blockquote>
<p>一个是参数初始化；<br>
一个是赋值，是一个执行的过程，多了计算量；</p>
</blockquote>
<p>创建一个对象，可以有参数，也可以无参数，也可动态创建：</p>
<pre class="highlighter-hljs" highlighted="true"><code class="language-cpp highlighter-hljs hljs"><span class="hljs-keyword">class</span> <span class="hljs-title class_">complex</span> *p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">complex</span>(<span class="hljs-number">4</span>); <span class="hljs-comment">//动态创建</span>
</code></pre>
<p>class定义了多个构造函数，就是重载<code>overloading</code></p>
<h3 id="4friend-友元类和友元函数">（4）friend 友元类和友元函数：<button class="cnblogs-toc-button" title="显示目录导航" aria-expanded="false"></button></h3>
<blockquote>
<ol>
<li><strong>能访问私有成员</strong></li>
<li>破坏封装性</li>
<li>友元关系不可传递</li>
<li>友元关系的单向性</li>
<li>友元声明的形式及数量不受限制</li>
<li>相同class 的各objects 互friends (友元)</li>
</ol>
<pre class="highlighter-hljs" highlighted="true"><code class="language-cpp highlighter-hljs hljs"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span> </span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> { 
  	<span class="hljs-keyword">friend</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>; <span class="hljs-comment">// Friend Class </span>
  }; 
  
  <span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> { 
  <span class="hljs-keyword">public</span>: 
  	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">showA</span><span class="hljs-params">(A&amp; x)</span> </span>{ 
  		std::cout &lt;&lt; <span class="hljs-string">"A::a="</span> &lt;&lt; x.a; 
  	} 
  }; 
  <span class="hljs-comment">//OR </span>
  <span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>; 
  <span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> { 
  <span class="hljs-keyword">public</span>: 
  	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">showB</span><span class="hljs-params">(B&amp;)</span></span>; 
  }; 
  
  <span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> { 
  	<span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-type">void</span> <span class="hljs-title">A::showB</span><span class="hljs-params">(B&amp; x)</span></span>; <span class="hljs-comment">// Friend function </span>
  }; 
  
  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">A::showB</span><span class="hljs-params">(B&amp; x)</span> </span>{ 
  	std::cout &lt;&lt; <span class="hljs-string">"B::b = "</span> &lt;&lt; x.b; 
  } 
</code></pre>
</blockquote>
<p>item23.	宁以 non-member、non-friend 替换 member 函数（可增加封装性、包裹弹性（packaging flexibility）、机能扩充性）</p>
<pre class="highlighter-hljs" highlighted="true"><code class="language-cpp highlighter-hljs hljs"><span class="hljs-comment">//member</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">WebBrowser</span> {
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">clearCache</span><span class="hljs-params">()</span></span>;
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">clearHistory</span><span class="hljs-params">()</span></span>;
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">removeCookies</span><span class="hljs-params">()</span></span>;

    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">clearEverything</span><span class="hljs-params">()</span></span>;  <span class="hljs-comment">//调用上述的三个函数</span>
};
<span class="hljs-comment">//non-member</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">clearBrowser</span> <span class="hljs-params">(WebBrowser&amp; wb)</span>
</span>{
    wb.<span class="hljs-built_in">clearCache</span>();
    wb.<span class="hljs-built_in">clearHistory</span>();
    wb.<span class="hljs-built_in">removeCookies</span>();
}
</code></pre>
<h3 id="5static-">（5）static ：<button class="cnblogs-toc-button" title="显示目录导航" aria-expanded="false"></button></h3>
<pre class="highlighter-hljs" highlighted="true"><code class="language-cpp highlighter-hljs hljs"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Account</span> {
<span class="hljs-keyword">public</span>:
    <span class="hljs-type">static</span> <span class="hljs-type">double</span> m_rate;
    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">set_rate</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">double</span>&amp; x)</span> </span>{ m_rate = x; }
};
<span class="hljs-type">double</span> Account::m_rate = <span class="hljs-number">8.0</span>; <span class="hljs-comment">//static value</span>

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    Account::<span class="hljs-built_in">set_rate</span>(<span class="hljs-number">5.0</span>);
    Account a;
    a.<span class="hljs-built_in">set_rate</span>(<span class="hljs-number">7.0</span>);
}
</code></pre>
<h3 id="利用static实现单例模式singleton">利用static实现单例模式（Singleton）<button class="cnblogs-toc-button" title="显示目录导航" aria-expanded="false"></button></h3>
<pre class="highlighter-hljs" highlighted="true"><code class="language-cpp highlighter-hljs hljs"><span class="hljs-comment">// Meyers Singleton</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> {
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">static</span> A&amp; <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span>;
    <span class="hljs-built_in">setup</span>() { ... }
    <span class="hljs-built_in">A</span>() = <span class="hljs-keyword">delete</span>;    <span class="hljs-comment">// c++ 11</span>
	<span class="hljs-built_in">A</span>(<span class="hljs-type">const</span> A&amp; rhs) = <span class="hljs-keyword">delete</span>;  <span class="hljs-comment">// c++ 11</span>
<span class="hljs-keyword">private</span>:
    <span class="hljs-built_in">A</span>();   <span class="hljs-comment">//before c++ 11</span>
    <span class="hljs-built_in">A</span>(<span class="hljs-type">const</span> A&amp; rhs);  <span class="hljs-comment">//before c++ 11</span>
};
<span class="hljs-function">A&amp; <span class="hljs-title">A::getInstance</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-type">static</span> A a;
    <span class="hljs-keyword">return</span> a;
}

<span class="hljs-comment">// Singleton</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> {
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">static</span> A&amp; <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span>{ <span class="hljs-keyword">return</span> a;} <span class="hljs-comment">//???? 猜测结果</span>
    <span class="hljs-function"><span class="hljs-type">static</span> A&amp; <span class="hljs-title">getInstance</span><span class="hljs-params">( <span class="hljs-keyword">return</span> a; )</span></span>; <span class="hljs-comment">//???? ppt中</span>
    <span class="hljs-built_in">setup</span>() { ... }
<span class="hljs-keyword">private</span>:
    <span class="hljs-built_in">A</span>();
    <span class="hljs-built_in">A</span>(<span class="hljs-type">const</span> A&amp; rhs);
    <span class="hljs-type">static</span> A a;
};


<span class="hljs-comment">//call  多线程中不安全.</span>
A::<span class="hljs-built_in">getInstance</span>().<span class="hljs-built_in">setup</span>();

A&amp; p = A::<span class="hljs-built_in">getInstance</span>();
p.<span class="hljs-built_in">setup</span>();

</code></pre>
<h2 id="四参数传递和返回值以及const">四、参数传递和返回值以及const<button class="cnblogs-toc-button" title="显示目录导航" aria-expanded="false"></button></h2>
<p><strong>尽量使用</strong>传引用的方式才传递参数，因为引用的底层是指针（C语言中指针作为参数传递类似），传递的数据大小为4个字节，速度会很快。同样，<strong>值的返回也尽量返回引用</strong>（如果可以的话）。</p>
<blockquote>
<ol>
<li>数据放在<code>private</code>里</li>
<li>参数用<code>reference</code>，是否用<code>const</code></li>
<li>在类的<code>body</code>里的函数是否加<code>const</code></li>
<li>构造函数的 <code>initial list</code></li>
<li>return by reference,不能为local object.</li>
</ol>
</blockquote>
<h4 id="指针引用">指针&amp;引用：<button class="cnblogs-toc-button" title="显示目录导航" aria-expanded="false"></button></h4>
<blockquote>
<ol>
<li>都是地址的概念；指针是一个实体,指向一块内存，它的内容是所指内存的地址；引用则是某块内存的别名。</li>
<li>使用sizeof指针本身大小一般是（4），而引用则是被引用对象的大小；</li>
<li>引用不能为空，指针可以为空；指针可以被初始化为NULL，而引用必须被初始化且必须是一个已有对象的引用,之后不可变；指针可变；引用“从一而终”，指针可以“见异思迁”；</li>
<li>作为参数传递时，指针需要被解引用才可以对对象进行操作，而直接对引用的修改都会改变引用所指向的对象；</li>
<li>引用没有<code>const</code>，指针有<code>const</code>，<code>const</code>的指针不可变；<br>
具体指没有<code>int&amp; const a</code>这种形式，而<code>const int&amp; a</code>是有的，前者指引用本身即别名不可以改变，这是当然的，所以不需要这种形式，后者指引用所指的值不可以改变）</li>
<li>指针在使用中可以指向其它对象，但是引用只能是一个对象的引用，不能 被改变；</li>
<li>指针可以有多级指针（**p），而引用至于一级；</li>
<li>指针和引用使用自增(++)运算符的意义不一样；</li>
<li>如果返回动态内存分配的对象或者内存，必须使用指针，引用可能引起内存泄露。</li>
<li>引用是类型安全的，而指针不是 (引用比指针多了类型检查）</li>
</ol>
</blockquote>
<h4 id="const作用">const作用<button class="cnblogs-toc-button" title="显示目录导航" aria-expanded="false"></button></h4>
<p>当一个方法不会对数据进行修改时，尽量将方法指定为const。细分顶层const、底层const</p>
<blockquote>
<p>"effective c++"第三条讲到： 只需要判断const是在 * 的左边还是右边即可。左边则是修饰被指物，即被指物是常量，不可以修改它的值；右边则是修饰指针，即指针是常量，不可以修改它的指向；在左右两边，则被指物和指针都是常量，都不可以修改。</p>
</blockquote>
<blockquote>
<ol>
<li>修饰变量，说明该变量不可以被改变；</li>
<li>修饰指针，分为指向常量的指针和指针常量；</li>
<li>常量引用，经常用于形参类型，即避免了拷贝，又避免了函数对值的修改；</li>
<li>修饰成员函数，说明该成员函数内不能修改成员变量。</li>
</ol>
</blockquote>
<pre class="highlighter-hljs" highlighted="true"><code class="language-cpp highlighter-hljs hljs"> <span class="hljs-comment">//const 使用</span>
 <span class="hljs-comment">// 类</span>
 <span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>
 {
 <span class="hljs-keyword">private</span>:
     <span class="hljs-type">const</span> <span class="hljs-type">int</span> a;                <span class="hljs-comment">// 常对象成员，只能在初始化列表赋值</span>
 <span class="hljs-keyword">public</span>:
     <span class="hljs-comment">// 构造函数</span>
     <span class="hljs-built_in">A</span>() : <span class="hljs-built_in">a</span>(<span class="hljs-number">0</span>) { };	        <span class="hljs-comment">// 初始化列表</span>
     <span class="hljs-built_in">A</span>(<span class="hljs-type">int</span> x) : <span class="hljs-built_in">a</span>(x) { };        <span class="hljs-comment">// 初始化列表</span>
     <span class="hljs-comment">// const可用于对重载函数的区分</span>
     <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getValue</span><span class="hljs-params">()</span></span>;             <span class="hljs-comment">// 普通成员函数</span>
     <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getValue</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;       <span class="hljs-comment">// 常成员函数，不得修改类中的任何数据成员的值</span>
     <span class="hljs-comment">// 可以供常对象使用，否则报错，调用有可能被改变值，编译器报错。</span>
 };
 
 <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">function</span><span class="hljs-params">()</span>
 </span>{
     <span class="hljs-comment">// 对象</span>
     A b;                        <span class="hljs-comment">// 普通对象，可以调用全部成员函数</span>
     <span class="hljs-type">const</span> A a;                  <span class="hljs-comment">// 常对象，只能调用常成员函数、更新常成员变量</span>
     <span class="hljs-type">const</span> A *p = &amp;a;            <span class="hljs-comment">// 常指针</span>
     <span class="hljs-type">const</span> A &amp;q = a;             <span class="hljs-comment">// 常引用</span>
     <span class="hljs-comment">// 指针</span>
     <span class="hljs-type">char</span> greeting[] = <span class="hljs-string">"Hello"</span>;   
     <span class="hljs-type">char</span>* p1 = greeting;                <span class="hljs-comment">// 指针变量，指向字符数组变量</span>
     <span class="hljs-type">const</span> <span class="hljs-type">char</span>* p2 = greeting;          <span class="hljs-comment">// 指针变量，指向字符数组常量</span>
     <span class="hljs-type">char</span>* <span class="hljs-type">const</span> p3 = greeting;          <span class="hljs-comment">// 常指针，指向字符数组变量</span>
     <span class="hljs-type">const</span> <span class="hljs-type">char</span>* <span class="hljs-type">const</span> p4 = greeting;    <span class="hljs-comment">// 常指针，指向字符数组常量</span>
 }
 <span class="hljs-comment">// 函数</span>
 <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">function1</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> Var)</span></span>;           <span class="hljs-comment">// 传递过来的参数在函数内不可变</span>
 <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">function2</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* Var)</span></span>;         <span class="hljs-comment">// 参数指针所指内容为常量</span>
 <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">function3</span><span class="hljs-params">(<span class="hljs-type">char</span>* <span class="hljs-type">const</span> Var)</span></span>;         <span class="hljs-comment">// 参数指针为常指针</span>
 <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">function4</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; Var)</span></span>;          <span class="hljs-comment">// 引用参数在函数内为常量</span>
 <span class="hljs-comment">// 函数返回值</span>
 <span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">int</span> <span class="hljs-title">function5</span><span class="hljs-params">()</span></span>;      <span class="hljs-comment">// 返回一个常数</span>
 <span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">int</span>* <span class="hljs-title">function6</span><span class="hljs-params">()</span></span>;     <span class="hljs-comment">// 返回一个指向常量的指针变量，使用：const int *p = function6();</span>
 <span class="hljs-function"><span class="hljs-type">int</span>* <span class="hljs-type">const</span> <span class="hljs-title">function7</span><span class="hljs-params">()</span></span>;     <span class="hljs-comment">// 返回一个指向变量的常指针，使用：int* const p = function7();</span>
 
</code></pre>
<h2 id="五操作符重载与临时对象">五、操作符重载与临时对象<button class="cnblogs-toc-button" title="显示目录导航" aria-expanded="false"></button></h2>
<blockquote>
<p>1、成员函数带有<strong>隐藏的参数<code>this</code></strong>，谁调用这个函数谁就是 this.<strong>临时对象</strong> complex() -&gt;typename()；<br>
2、在类外Complex Complex::operator+=(complex &amp;c2)  这个是成员函数&nbsp;<code>operator+=</code> 的实现，所以需要&nbsp;Complex:: 具有this指针。例如：</p>
</blockquote>
<p>返回&amp; 为了链式连续操作，在stream流的类中非常常见</p>
<h3 id="运算符重载成员函数">运算符重载——成员函数<button class="cnblogs-toc-button" title="显示目录导航" aria-expanded="false"></button></h3>
<pre class="highlighter-hljs" highlighted="true"><code class="language-cpp highlighter-hljs hljs"><span class="hljs-keyword">inline</span> complex&amp;
__doapl(complex* ths, <span class="hljs-type">const</span> complex&amp; r)
{ <span class="hljs-comment">//第一參數將會被改動   //第二參數不會被改動</span>
   ths-&gt;re += r.re;
   ths-&gt;im += r.im;
<span class="hljs-keyword">return</span> *ths;
}

<span class="hljs-keyword">inline</span> complex&amp;
<span class="hljs-keyword">class</span> <span class="hljs-title class_">complex</span>::<span class="hljs-keyword">operator</span> += (<span class="hljs-type">const</span> complex&amp; r) <span class="hljs-comment">//成员函数 this</span>
{
&nbsp; <span class="hljs-keyword">return</span> __doapl (<span class="hljs-keyword">this</span>, r);
}
</code></pre>
<h3 id="运算符重载全局函数">运算符重载——全局函数<button class="cnblogs-toc-button" title="显示目录导航" aria-expanded="false"></button></h3>
<pre class="highlighter-hljs" highlighted="true"><code class="language-cpp highlighter-hljs hljs"><span class="hljs-comment">//而下面属于运算符重载，不是成员函数的时候，就没有Complex:: 。</span>
<span class="hljs-keyword">inline</span> complex
<span class="hljs-keyword">operator</span> - (<span class="hljs-type">const</span> complex&amp; x, <span class="hljs-type">double</span> y)
{
&nbsp; <span class="hljs-keyword">return</span> <span class="hljs-built_in">complex</span> (<span class="hljs-built_in">real</span> (x) - y, <span class="hljs-built_in">imag</span> (x));
}
</code></pre>
<h2 id="六总结">六、总结<button class="cnblogs-toc-button" title="显示目录导航" aria-expanded="false"></button></h2>
<p>1.使用<strong>初始化列表</strong>，构造函数中，Complex(double r = 0, double i = 0) : re(r), im(i) {}</p>
<p>2.成员函数是否指明const，若不修改数据，则尽可能指明const。<strong>const对象无法调用非const成员方法</strong>。</p>
<p>3.<strong>参数传递和结果返回，尽量使用传递和返回引用</strong>。效率更高（不要返回局部变量的引用）。</p>
<p>4.<strong>数据private，对外接口public，内部方法private</strong>（注意封装来隐藏数据）。</p>
<p>5.同一个类衍生出的<strong>对象之间都互为友元</strong>，可以直接调用对方的私有变量。</p>
<p>6.<strong>操作符重载</strong>都是作用在左边的变量上的（即调用该操作符函数的对象），注意<strong>连续调用</strong>的情况，操作符重载可以是成员方法，也可全局方法。</p>
<p>7.成员方法在类定义中实现，默认声明为inline方法（视编译器的决定）。若为全局函数，需加inline关键字，让编译器尽量的将其变为inline函数。</p>
<h2 id="七三大函数拷贝构造拷贝赋值析构">七、三大函数：拷贝构造，拷贝赋值，析构<button class="cnblogs-toc-button" title="显示目录导航" aria-expanded="false"></button></h2>
<p>构造函数（可以重载，类内创建private，C++11有delete）<br>
拷贝构造函数<br>
拷贝赋值函数<br>
析构函数</p>
<p><em>常量成员函数 const修饰成员函数，防止常量对象进行调用出错。</em></p>
<p>class with pointer members 必須有copy ctor 和copy op=</p>
<p>一定要在operator= 中檢查是否self assignment</p>
<pre class="highlighter-hljs" highlighted="true"><code class="language-cpp highlighter-hljs hljs"><span class="hljs-keyword">inline</span> String&amp; String::<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> String&amp; str) <span class="hljs-comment">//后面有String的整体代码</span>
{
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == &amp;str)
        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;
    <span class="hljs-keyword">delete</span>[] m_data;
    m_data = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[ <span class="hljs-built_in">strlen</span>(str.m_data) + <span class="hljs-number">1</span> ];
    <span class="hljs-built_in">strcpy</span>(m_data, str.m_data);
    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;
}

<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream.h&gt;</span></span>
<span class="hljs-comment">//定义成员方法，获取m_data指针，不修改数据，加上const</span>
<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">char</span> * <span class="hljs-title">String::get_c_str</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;m_data;
}
<span class="hljs-comment">//重载操作符&lt;&lt;</span>
ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(ostream&amp; os, <span class="hljs-type">const</span> String&amp; str)
{
    os &lt;&lt; str.<span class="hljs-built_in">get_c_str</span>();
    <span class="hljs-keyword">return</span> os;
}
</code></pre>
<p>——》<strong>类含指针</strong>，就需要 <strong>拷贝构造、 拷贝赋值函数</strong></p>
<blockquote>
<p>浅拷贝——》拷贝构造函数 ，浅拷贝的影响：<br>
1、造成内存泄漏；	<br>
2、造成有两个指针 指向同一块内存</p>
</blockquote>
<blockquote>
<p>深拷贝——》拷贝赋值函数<br>
步骤：delete ;new; strcpy;<br>
class里面有默认的拷贝构造和拷贝赋值函数。如果自己不定义一个拷贝构造函数，在调用拷贝构造函数的时候，就会调用<strong>默认的浅拷贝构造函数</strong>，就会造成问题，所以一定要自己定义拷贝构造函数——深拷贝。</p>
<p><img src="./C++面向对象笔记_上（侯捷老师视频） - yzhu798 - 博客园_files/构造函数浅拷贝.png" alt="img" loading="lazy"></p>
</blockquote>
<h2 id="八堆栈与内存管理">八、堆，栈与内存管理<button class="cnblogs-toc-button" title="显示目录导航" aria-expanded="false"></button></h2>
<p>1、static local objects的生命周期</p>
<blockquote>
<ul>
<li>static的生命周期 ：object的对象在scope结束以后仍然存在，直到整个程序结束；</li>
<li>非static 的生命周期：object的对象在在scope结束以后就结束了。</li>
<li>global objects的生命周期：对象 objects 生命结束，就是什么时候析构函数被调用。</li>
</ul>
</blockquote>
<p>2、new——》operator new。</p>
<p>new动态创建对象，分三步：</p>
<blockquote>
<ol>
<li>先转化为operator new 函数，申请分配内存。</li>
<li>做类型转化。</li>
<li>调用构造函数</li>
</ol>
</blockquote>
<p>delete ——》operator delete。删除对象，分两步：</p>
<blockquote>
<ol>
<li>先调用析构函数，</li>
<li>再调用operator delete函数。</li>
</ol>
</blockquote>
<p>3、带中括号[ ]的new[ ]叫做array new，带中括号[ ]的delete[ ]&nbsp; 叫做array delete。</p>
<blockquote>
<p>动态分配所得到的数组array：complex *p = new complex[3];</p>
<p>new [] &nbsp;——》delete[] ——》表示调用几次析构函数<br>
&nbsp;new 字符串 ——》delete 指针</p>
<p>delete[n] :array new一定要调用array delete，delete[n]会调用n次析构函数，而delete仅调用一次。</p>
</blockquote>
<p><strong>Stack</strong>，是存在于某作用域(scope) 的一块内存空间(memory space)。例如当你调用函数，函数本身即会形成一个stack 用来放置它所接收的<strong>参数</strong>，以及<strong>返回地址</strong>。在函数本体(function body) <strong>内声明的任何变量</strong>，其所使用的内存块都取自上述stack。</p>
<p><strong>Heap</strong>，是指由操作系统提供的一块<strong>global 内存空间</strong>，程序可动态分配(dynamic allocated) 从某中获得若干区块(blocks),记得释放，尽量用RAII管理。</p>
<h3 id="new和delete关键字的工作流程">new和delete关键字的工作流程<button class="cnblogs-toc-button" title="显示目录导航" aria-expanded="false"></button></h3>
<pre class="highlighter-hljs" highlighted="true"><code class="language-cpp highlighter-hljs hljs">{
    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Complex</span>* p = <span class="hljs-keyword">new</span> Complex;
    ...
    <span class="hljs-keyword">delete</span> p; <span class="hljs-comment">//若未删除，内存泄露，再也无法删除了，p退出作用域，作用域外无法看到p。</span>
    
    <span class="hljs-comment">//编译器实现如下</span>
    Complex *pc;
    <span class="hljs-type">void</span>* mem = <span class="hljs-keyword">operator</span> <span class="hljs-built_in">new</span>( <span class="hljs-built_in">sizeof</span>(Complex) ); <span class="hljs-comment">//分配内存</span>
    pc = <span class="hljs-built_in">static_cast</span>&lt;Complex*&gt;(mem); <span class="hljs-comment">//转型，static_cast多了类型检查</span>
    pc-&gt;Complex::<span class="hljs-built_in">Complex</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>); <span class="hljs-comment">//构造函数</span>
    
    Complex::~<span class="hljs-built_in">Complex</span>(pc); <span class="hljs-comment">// 析构函數</span>
    <span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(pc)</span></span>; <span class="hljs-comment">// 释放內存</span>
}
</code></pre>
<pre class="highlighter-hljs" highlighted="true"><code class="language-cpp highlighter-hljs hljs">{
    String* ps = <span class="hljs-keyword">new</span> <span class="hljs-built_in">String</span>(<span class="hljs-string">"Hello"</span>); 
    <span class="hljs-comment">//编译器实现如下</span>
    String* ps;
    <span class="hljs-type">void</span>* mem = <span class="hljs-keyword">operator</span> <span class="hljs-built_in">new</span>( <span class="hljs-built_in">sizeof</span>(String) ); <span class="hljs-comment">//分配内存</span>
    ps = <span class="hljs-built_in">static_cast</span>&lt;String*&gt;(mem); <span class="hljs-comment">//转型</span>
    ps-&gt;String::<span class="hljs-built_in">String</span>(<span class="hljs-string">"Hello"</span>); <span class="hljs-comment">//构</span>
}
</code></pre>
<h3 id="vc当中的内存分配">VC当中的内存分配<button class="cnblogs-toc-button" title="显示目录导航" aria-expanded="false"></button></h3>
<p><strong>注：仅限new的情况下。</strong></p>
<p><strong>Debug（左）Release（右）模式下：</strong></p>
<p><strong><img src="./C++面向对象笔记_上（侯捷老师视频） - yzhu798 - 博客园_files/VC当中的内存分配debug-1590131562489.png" alt="img" loading="lazy">    <img src="./C++面向对象笔记_上（侯捷老师视频） - yzhu798 - 博客园_files/VC当中的内存分配release-1590131565296.png" alt="img" loading="lazy"></strong></p>
<p><strong>浅绿色：</strong>Complex对象所占实际空间，大小为8bytes。</p>
<p><strong>上下砖红色：</strong>各4bytes，一共8bytes。是cookie，用来保存总分配内存大小，以及标志是给出去还是收回来。例如00000041，该数为16进制，4表示64，即总分配内存大小为64,1表示给出去（0表示收回来）。</p>
<p><strong>灰色：</strong>Debug模式下使用的额外空间，前面32bytes，后面1bytes，一共36bytes。</p>
<p><strong>深绿色：</strong>内存分配大小必须是16的倍数（这样砖红色部分里的数字最后都是0，可以用来借位表示给出去还是收回来），所以用了12byte的填充（padding）。</p>
<p><strong>同样，String对象的空间分配，如图：（左Debug，右Release）</strong></p>
<p><img src="./C++面向对象笔记_上（侯捷老师视频） - yzhu798 - 博客园_files/string内存分配debug.png" alt="img" loading="lazy">    <img src="./C++面向对象笔记_上（侯捷老师视频） - yzhu798 - 博客园_files/string内存分配release.png" alt="img" loading="lazy"></p>
<p><strong>Debug（左）Release（右）模式下，数组空间的分配：</strong></p>
<p><img src="./C++面向对象笔记_上（侯捷老师视频） - yzhu798 - 博客园_files/数组内存分配debug-1590131593574.png" alt="img" loading="lazy">    <img src="./C++面向对象笔记_上（侯捷老师视频） - yzhu798 - 博客园_files/数组内存分配release.png" alt="img" loading="lazy"></p>
<p><strong>灰色：</strong>即3个Complex对象的大小，每个是8bytes，一共24bytes。</p>
<p><strong>深绿色：</strong>填充为16的倍数。</p>
<p><strong>前后白色：</strong>51表示80bytes，“给出去”。</p>
<p><strong>黄色：</strong>Debug模式额外占用空间。</p>
<p><strong>中间白色：</strong>用一个整数表示数组中对象个数。</p>
<h2 id="九复习string类的实现过程">九、复习String类的实现过程<button class="cnblogs-toc-button" title="显示目录导航" aria-expanded="false"></button></h2>
<pre class="highlighter-hljs" highlighted="true"><code class="language-cpp highlighter-hljs hljs"><span class="hljs-keyword">class</span> <span class="hljs-title class_">String</span>
{
<span class="hljs-keyword">public</span>:
    <span class="hljs-built_in">String</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* cstr = <span class="hljs-number">0</span>)
    {
        <span class="hljs-keyword">if</span> (cstr) {
            m_data = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[<span class="hljs-built_in">strlen</span>(cstr)+<span class="hljs-number">1</span>];
            <span class="hljs-built_in">strcpy</span>(m_data, cstr);
        }<span class="hljs-keyword">else</span> { <span class="hljs-comment">// 未指定初值</span>
            m_data = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[<span class="hljs-number">1</span>];
            *m_data = <span class="hljs-string">'\0'</span>;
        }
    }
    <span class="hljs-built_in">String</span>(<span class="hljs-type">const</span> String&amp; str)
    {
        m_data = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[ <span class="hljs-built_in">strlen</span>(str.m_data) + <span class="hljs-number">1</span> ];
        <span class="hljs-built_in">strcpy</span>(m_data, str.m_data);
    }
    String&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> String&amp; str);
    ~<span class="hljs-built_in">String</span>()
    {
        <span class="hljs-keyword">delete</span>[] m_data;
    }
    <span class="hljs-function"><span class="hljs-type">char</span>* <span class="hljs-title">get_c_str</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>{ <span class="hljs-keyword">return</span> m_data; }
<span class="hljs-keyword">private</span>:
    <span class="hljs-type">char</span>* m_data;
};


<span class="hljs-keyword">inline</span> String&amp; String::<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> String&amp; str)
{
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == &amp;str)
        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;
    <span class="hljs-keyword">delete</span>[] m_data;
    m_data = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[ <span class="hljs-built_in">strlen</span>(str.m_data) + <span class="hljs-number">1</span> ];
    <span class="hljs-built_in">strcpy</span>(m_data, str.m_data);
    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;
}
</code></pre>
<h2 id="十扩展补充类模板函数模板及其他">十、扩展补充：类模板，函数模板，及其他<button class="cnblogs-toc-button" title="显示目录导航" aria-expanded="false"></button></h2>
<pre class="highlighter-hljs" highlighted="true"><code class="language-cpp highlighter-hljs hljs"><span class="hljs-comment">//class template,类模板</span>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">class</span> <span class="hljs-title class_">complex</span>
{ <span class="hljs-keyword">public</span>:
    <span class="hljs-built_in">complex</span> (T r = <span class="hljs-number">0</span>, T i = <span class="hljs-number">0</span>): <span class="hljs-built_in">re</span> (r), <span class="hljs-built_in">im</span> (i){ }
    complex&amp; <span class="hljs-keyword">operator</span> += (<span class="hljs-type">const</span> complex&amp;);
    <span class="hljs-function">T <span class="hljs-title">real</span> <span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>{ <span class="hljs-keyword">return</span> re; }
    <span class="hljs-function">T <span class="hljs-title">imag</span> <span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>{ <span class="hljs-keyword">return</span> im; }
<span class="hljs-keyword">private</span>:
    T re, im;
    <span class="hljs-keyword">friend</span> complex&amp; __doapl (complex*, <span class="hljs-type">const</span> complex&amp;);
};
<span class="hljs-comment">//函数模板</span>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;
<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">const</span> T&amp; <span class="hljs-title">min</span><span class="hljs-params">(<span class="hljs-type">const</span> T&amp; a, <span class="hljs-type">const</span> T&amp; b)</span>
</span>{
    <span class="hljs-keyword">return</span> b &lt; a ? b : a;
}

<span class="hljs-keyword">class</span> <span class="hljs-title class_">stone</span>
{ <span class="hljs-keyword">public</span>:
    <span class="hljs-built_in">stone</span>(<span class="hljs-type">int</span> w, <span class="hljs-type">int</span> h, <span class="hljs-type">int</span> we)
        : _w(w), _h(h), _weight(we){ }
    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt; (<span class="hljs-type">const</span> stone&amp; rhs) <span class="hljs-type">const</span>
    { <span class="hljs-keyword">return</span> _weight &lt; rhs._weight; }
<span class="hljs-keyword">private</span>:
    <span class="hljs-type">int</span> _w, _h, _weight;
};

<span class="hljs-comment">//引数推导的结果，T 为stone，于是调用stone::operator&lt;</span>
<span class="hljs-comment">//调用函数，那么就会传实参，编译器就会进行实参推导。</span>
<span class="hljs-function">stone <span class="hljs-title">r1</span><span class="hljs-params">(<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)</span>, <span class="hljs-title">r2</span><span class="hljs-params">(<span class="hljs-number">3</span>,<span class="hljs-number">3</span>)</span>, r3</span>;
r3 = <span class="hljs-built_in">min</span>(r1, r2);
</code></pre>
<p>（1）static ：静态数据 属于所有对象（类）。</p>
<p>静态函数 <strong>没有this pointer</strong>，而非静态函数有 this pointer，可以用this去取数据，<strong>静态函数要处理数据只能处理静态数据</strong>。<strong>静态数据一定要在class外面定义</strong>。</p>
<p>（2）template：类模板 &nbsp;函数模板<br>
&nbsp; &nbsp; （3）inline namespace：(C++11)</p>
<pre class="highlighter-hljs" highlighted="true"><code class="language-cpp highlighter-hljs hljs"><span class="hljs-keyword">namespace</span> Program {
  <span class="hljs-keyword">namespace</span> Version1 {
    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getVersion</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>; }
    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isFirstVersion</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; }
  }
  <span class="hljs-keyword">inline</span> <span class="hljs-keyword">namespace</span> Version2 {<span class="hljs-comment">//inline</span>
    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getVersion</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>; }
  }
}

<span class="hljs-type">int</span> version {Program::<span class="hljs-built_in">getVersion</span>()};              <span class="hljs-comment">// Uses getVersion() from Version2</span>
<span class="hljs-type">int</span> oldVersion {Program::Version1::<span class="hljs-built_in">getVersion</span>()}; <span class="hljs-comment">// Uses getVersion() from Version1</span>
<span class="hljs-type">bool</span> firstVersion {Program::<span class="hljs-built_in">isFirstVersion</span>()};    <span class="hljs-comment">// Does not compile when Version2 is added</span>
</code></pre>
<h2 id="十-一组合--has-a-与继承-is-a">十 一、组合  has-a 与继承 is-a<button class="cnblogs-toc-button" title="显示目录导航" aria-expanded="false"></button></h2>
<p>组合表示has-a。即A类里有B类的对象（非指针）<strong>实心，实在成员</strong>对象（UML）。</p>
<p><img src="./C++面向对象笔记_上（侯捷老师视频） - yzhu798 - 博客园_files/has-a.png" alt="image-20200518193613371" loading="lazy"></p>
<pre class="highlighter-hljs" highlighted="true"><code class="language-cpp highlighter-hljs hljs">由内而外<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Itr</span> {
    T* cur;
    T* first;
    T* last;
    T** node;
    <span class="hljs-comment">//Sizeof : 4 * 4</span>
};

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;
<span class="hljs-keyword">class</span> <span class="hljs-title class_">deque</span> {
<span class="hljs-keyword">protected</span>:
    Itr&lt;T&gt; start;
    Itr&lt;T&gt; finish;
    T** map;
    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> map_size;
    <span class="hljs-comment">//Sizeof : 16 * 2 + 4 + 4</span>
};

<span class="hljs-comment">//适配器模式(queue 适配器，deque成熟的类)</span>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;
<span class="hljs-keyword">class</span> <span class="hljs-title class_">queue</span> {
<span class="hljs-keyword">protected</span>:
    deque&lt;T&gt; c;
    <span class="hljs-comment">//Sizeof : 40</span>
};
<span class="hljs-comment">//组合</span>
<span class="hljs-comment">//构造顺序： Itr-&gt;deque-&gt;queue 由内到外</span>
<span class="hljs-comment">//析构顺序： queue-&gt;deque-&gt;Itr 由外到内</span>
<span class="hljs-comment">//queue内存大小：queue的内存大小+deque的内存大小</span>

</code></pre>
<p>（2）委托<code>delegation</code>，即composition by reference：在body中声明一个带指针的另一个类&nbsp;composition by reference 生命时间：&nbsp; classA 用一个<strong>指针</strong>指向classB，需要的时候才调用classB，而不是一直拥有classB。叫做<strong>“Copy on write”</strong></p>
<p><img src="./C++面向对象笔记_上（侯捷老师视频） - yzhu798 - 博客园_files/委托基于引用的复合.png" alt="img" loading="lazy"></p>
<p><strong>指针有点虚（UML）</strong></p>
<pre class="highlighter-hljs" highlighted="true"><code class="language-cpp highlighter-hljs hljs"><span class="hljs-comment">//委托delegation</span>
<span class="hljs-comment">// file String.hpp</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">StringRep</span>;
<span class="hljs-keyword">class</span> <span class="hljs-title class_">String</span> {<span class="hljs-comment">//Handle,稳定</span>
<span class="hljs-keyword">private</span>:
    StringRep* rep; <span class="hljs-comment">// pimpl ，指针指向实现的类（Handle/Body）</span>
};

<span class="hljs-comment">// file String.cpp</span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"String.hpp"</span></span>
<span class="hljs-keyword">namespace</span> {
<span class="hljs-keyword">class</span> <span class="hljs-title class_">StringRep</span> {<span class="hljs-comment">//Body ,有弹性变化</span>
    <span class="hljs-keyword">friend</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">String</span>;  <span class="hljs-comment">//friend</span>
    <span class="hljs-built_in">StringRep</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* s);
    ~<span class="hljs-built_in">StringRep</span>();
    <span class="hljs-type">int</span> count;
    <span class="hljs-type">char</span>* rep;
};
}
String::<span class="hljs-built_in">String</span>(){ ... }
</code></pre>
<p>（3）继承Inheritance：（三种继承方式：public protected private）is-a，继承主要搭配<strong>虚函数</strong>来使用函数的继承：指的是继承函数的调用权，<strong>子类可以调用父类的函数</strong>，如B继承A，则说明B是A的一种。</p>
<p><img src="./C++面向对象笔记_上（侯捷老师视频） - yzhu798 - 博客园_files/InheritanceUML.png" alt="img" loading="lazy"></p>
<pre class="highlighter-hljs" highlighted="true"><code class="language-cpp highlighter-hljs hljs"><span class="hljs-comment">//继承中的     构造函数与析构调用顺序</span>
<span class="hljs-comment">//构造顺序： 父类-&gt;子类  由内到外</span>
<span class="hljs-comment">//析构顺序： 子类-&gt;父类  由外到内</span>

<span class="hljs-comment">//继承+组合模式  构造函数与析构调用顺序</span>
Derived::<span class="hljs-built_in">Derived</span>(...):<span class="hljs-built_in">Base</span>(),<span class="hljs-built_in">Component</span>() { ... };
Derived::~<span class="hljs-built_in">Derived</span>(...){ ...  ~<span class="hljs-built_in">Component</span>(), ~<span class="hljs-built_in">Base</span>() };
</code></pre>
<p>继承+组合模式</p>
<pre class="highlighter-hljs" highlighted="true"><code class="language-cpp highlighter-hljs hljs"><span class="hljs-comment">//继承+组合模式  构造函数与析构调用顺序</span>
Derived::<span class="hljs-built_in">Derived</span>(...):<span class="hljs-built_in">Base</span>(),<span class="hljs-built_in">Component</span>() { ... };
Derived::~<span class="hljs-built_in">Derived</span>(...){ ...  ~<span class="hljs-built_in">Component</span>(), ~<span class="hljs-built_in">Base</span>() };
</code></pre>
<h2 id="十二虚函数与多态">十二、虚函数与多态<button class="cnblogs-toc-button" title="显示目录导航" aria-expanded="false"></button></h2>
<pre class="highlighter-hljs" highlighted="true"><code class="language-cpp highlighter-hljs hljs"><span class="hljs-comment">//虚函数 你期待derived class的行为</span>
non-<span class="hljs-keyword">virtual</span> 函数：不重新定义(<span class="hljs-keyword">override</span>, 覆写它).
<span class="hljs-keyword">virtual</span> 函数：重新定义(<span class="hljs-keyword">override</span>, 覆写) 它，且你对它已有默认定义。
pure <span class="hljs-keyword">virtual</span> 函数：必须重新定义(<span class="hljs-keyword">override</span> 覆写)它，你对它没有默认定义，不能直接实例化对象。
</code></pre>
<p>（1）虚函数：virtual&nbsp;纯虚函数：一定要重新定义。</p>
<p>（A）Inheritance + composition下的构造和析构</p>
<p>（B）delegation + Inheritance ——》 功能最强大的一种</p>
<h2 id="十三设计模式">十三、设计模式<button class="cnblogs-toc-button" title="显示目录导航" aria-expanded="false"></button></h2>
<blockquote>
<p>建议看李建忠老师视频23种C++设计模式</p>
</blockquote>
<p>图形展示</p>
<p><img src="./C++面向对象笔记_上（侯捷老师视频） - yzhu798 - 博客园_files/设计模式Template Method.png" alt="image-20200519233845305" loading="lazy"></p>
<p><img src="./C++面向对象笔记_上（侯捷老师视频） - yzhu798 - 博客园_files/设计模式Observer.png" alt="image-20200519235739912" loading="lazy"></p>
<p><img src="./C++面向对象笔记_上（侯捷老师视频） - yzhu798 - 博客园_files/设计模式_组合模式.png" alt="image-20200520000157555" loading="lazy"></p>
<p><img src="./C++面向对象笔记_上（侯捷老师视频） - yzhu798 - 博客园_files/设计模式Prototype.png" alt="image-20200520000235749" loading="lazy"></p>
<h3 id="template-method模式">Template Method模式<button class="cnblogs-toc-button" title="显示目录导航" aria-expanded="false"></button></h3>
<p>步骤：</p>
<blockquote>
<p>1.在父类CDocument中，实现共同的方法，例如OpenFile、CloseFile等。</p>
<p>2.CDocument中，将读文件内容的方法Serialize设计为虚函数或纯虚函数。</p>
<p>3.CMyDoc继承CDocument，实现Serialize()。</p>
<p>4.使用子类CMyDoc调用父类方法OnFileOpen()，按图中灰色曲线的顺序来调用内部函数。</p>
</blockquote>
<p>这样就实现了关键功能的延迟实现，实现应用与架构分离（Application framework）这就是典型的Template Method。</p>
<p><strong>为什么会有灰色曲线的调用过程：</strong></p>
<p>1.当子类myDoc调用OnFileOpen()的时候，实际上对于编译器是CDocument::OnFileOpen(&amp;myDoc);因为谁调用，this指针就指向谁，所以调用这个函数，myDoc的地址被传进去了。</p>
<p>2.当OnFileOpen()函数运行到Serilize()的时候，实际上是运行的this-&gt;Serialize()；由于this指向的是myDoc，所以调用的是子类的Serilize()函数。</p>
<pre class="highlighter-hljs" highlighted="true"><code class="language-cpp highlighter-hljs hljs"><span class="hljs-comment">//框架开发人员</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">CDocument</span> {
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">OnFileOpen</span><span class="hljs-params">()</span> </span>{ 
        cout &lt;&lt; <span class="hljs-string">"dialog..."</span> &lt;&lt; endl;
        cout &lt;&lt; <span class="hljs-string">"check file status..."</span> &lt;&lt; endl;
        cout &lt;&lt; <span class="hljs-string">"open file..."</span> &lt;&lt; endl;
        <span class="hljs-built_in">Serialize</span>();                       <span class="hljs-comment">//子类再实现</span>
        cout &lt;&lt; <span class="hljs-string">"close file..."</span> &lt;&lt; endl;
        cout &lt;&lt; <span class="hljs-string">"update status..."</span> &lt;&lt; endl;
    }
    <span class="hljs-comment">//父类的虚函数，当然这里是纯虚函数也是可以的，virtual void Serialize() = 0</span>
    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Serialize</span><span class="hljs-params">()</span> </span>{}
};
<span class="hljs-comment">//应用开发人员</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">CMyDoc</span> :<span class="hljs-keyword">public</span> CDocument {
<span class="hljs-keyword">public</span>:
    <span class="hljs-comment">//这里实现了父类的虚函数Serialize()</span>
    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Serialize</span><span class="hljs-params">()</span> </span>{
        cout &lt;&lt; <span class="hljs-string">"MyDoc Serialize..."</span> &lt;&lt; endl;
    }
};

<span class="hljs-comment">//call</span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"CDocument.h"</span></span>
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    CMyDoc mc;
    mc.<span class="hljs-built_in">OnFileOpen</span>();
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<p>output</p>
<pre class="highlighter-hljs" highlighted="true"><code class="highlighter-hljs hljs language-erlang">dialog...
check file status...
open file...
MyDoc Serialize...
close file...
update status...
</code></pre>
<pre style="--olcb-folder-code-block-toggler-bg-rgb:245,245,245; --olcb-folder-code-block-toggler-bg:linear-gradient(to bottom, rgba(245,245,245, 0.3) 10%, rgba(245,245,245, 0.8) 30%, rgb(245,245,245)); --olcb-folder-code-block-toggler-fontsize:12px; --olcb-folder-code-block-scroll-height:782px;" class="cnb-over-length-code-block cnb-over-length-code-block-expanded highlighter-hljs" highlighted="true"><code class="language-cpp highlighter-hljs hljs"><span class="hljs-comment">//程序库开发人员</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Library</span>
{
  <span class="hljs-keyword">public</span>:
    <span class="hljs-comment">//稳定 template method</span>
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Run</span><span class="hljs-params">()</span>
    </span>{
        <span class="hljs-built_in">Step1</span>();
        <span class="hljs-built_in">Step2</span>();<span class="hljs-comment">//支持变化 ==&gt; 虚函数的多态调用</span>
        <span class="hljs-built_in">Step3</span>();
        <span class="hljs-built_in">Step4</span>(); <span class="hljs-comment">//支持变化 ==&gt; 虚函数的多态调用</span>
        <span class="hljs-built_in">Step5</span>();
    }
    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Library</span>() {}

  <span class="hljs-keyword">protected</span>:
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Step1</span><span class="hljs-params">()</span></span>{}<span class="hljs-comment">//稳定</span>
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Step3</span><span class="hljs-params">()</span></span>{}<span class="hljs-comment">//稳定</span>
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Step5</span><span class="hljs-params">()</span></span>{}<span class="hljs-comment">//稳定</span>

    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">bool</span> <span class="hljs-title">Step2</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>; <span class="hljs-comment">//变化</span>
    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Step4</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>; <span class="hljs-comment">//变化</span>
};

<span class="hljs-comment">//应用程序开发人员</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Application</span> : <span class="hljs-keyword">public</span> Library
{
  <span class="hljs-keyword">protected</span>:
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">bool</span> <span class="hljs-title">Step2</span><span class="hljs-params">()</span></span>{    <span class="hljs-comment">//... 子类重写实现</span>
		<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
	}

	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Step4</span><span class="hljs-params">()</span></span>{     <span class="hljs-comment">//... 子类重写实现</span>
	}
};

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
	Library *pLib = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Application</span>();
	pLib-&gt;<span class="hljs-built_in">Run</span>();
	<span class="hljs-keyword">delete</span> pLib;
}
</code><div class="cnb-over-length-code-block-toggler cnb-over-length-code-block-toggler-hidden" style=""><span class="cnb-over-length-code-block-toggler-title">折叠 </span><span class="cnb-over-length-code-block-toggler-icon"><svg style="transform: rotateZ(180deg)" viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" width="200" height="200"><path d="M840.4 300H183.6c-19.7 0-30.7 20.8-18.5 35l328.4 380.8c9.4 10.9 27.5 10.9 37 0L858.9 335c12.2-14.2 1.2-35-18.5-35z"></path></svg></span></div></pre>
<h3 id="observer模式">Observer模式<button class="cnblogs-toc-button" title="显示目录导航" aria-expanded="false"></button></h3>
<p>我们的数据设计在类Subject中，窗口（观察者）设计为Observer，这是一个父类，可以被继承（即可以支持派生出不同类型的观察者）。</p>
<p><img src="./C++面向对象笔记_上（侯捷老师视频） - yzhu798 - 博客园_files/设计模式Observer-1590131631061.png" alt="image-20200519234006414" loading="lazy"></p>
<p><strong>用如下代码来实现：</strong></p>
<pre class="highlighter-hljs" highlighted="true"><code class="language-cpp highlighter-hljs hljs"><span class="hljs-comment">//数据类</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Subject</span> {
    <span class="hljs-type">int</span> m_value;
    vector&lt;Observer*&gt; m_views;
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">attach</span><span class="hljs-params">(Observer* obs)</span> </span>{ m_views.<span class="hljs-built_in">push_back</span>(obs);
    }
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">set_value</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> </span>{
        m_value = value;
        <span class="hljs-built_in">notify</span>();
    }
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">notify</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; m_views.<span class="hljs-built_in">size</span>();++i) {
            m_views[i]-&gt;<span class="hljs-built_in">update</span>(<span class="hljs-keyword">this</span>, m_value);
        }
    }
};
<span class="hljs-comment">//观察者基类</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Observer</span> {
<span class="hljs-keyword">public</span>:
    <span class="hljs-comment">//纯虚函数，提供给不同的实际观察者类来实现不同的特性</span>
    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">update</span><span class="hljs-params">(Subject*, <span class="hljs-type">int</span> value)</span> </span>= <span class="hljs-number">0</span>;
};
</code></pre>
<p>用图形来描述：</p>
<p><img src="./C++面向对象笔记_上（侯捷老师视频） - yzhu798 - 博客园_files/观察者类UML.png" alt="img" loading="lazy"></p>
<h3 id="组合模式">组合模式<button class="cnblogs-toc-button" title="显示目录导航" aria-expanded="false"></button></h3>
<p>　　在计算机文件系统中，有<strong>文件夹</strong>的概念，文件夹里面既可以放入文件也可以放入文件夹，但是文件中却不能放入任何东西。文件夹和文件构成了一种递归结构和容器结构。<br>
　　虽然文件夹和文件是不同的对象，但是他们都可以被放入到文件夹里，所以一定意义上，文件夹和文件又可以看作是同一种类型的对象，所以我们可以把文件夹和文件统称为目录条目（directory entry）。在这个视角下，文件和文件夹是同一种对象。<br>
　　所以，我们可以将文件夹和文件都看作是目录的条目，将容器和内容作为同一种东西看待，可以方便我们递归的处理问题，在容器中既可以放入容器，又可以放入内容，然后在小容器中，又可以继续放入容器和内容，这样就构成了容器结构和递归结构。<br>
　　这就引出了composite模式，也就是组合模式，组合模式就是用于创造出这样的容器结构的。是容器和内容具有一致性，可以进行递归操作。</p>
<p>图中Primitive代表基本的东西，即文件。Composite代表合成物，即文件夹。Component表示目录条目。</p>
<p>Primitive和Composite都是一种Component，而Composite中可以存放其他的Composite和Primitive，所以Composite中的Vector存放的类型时Component指针，也就包含了Primitive和Composite两种对象的指针。</p>
<p><strong>代码框架如下：</strong></p>
<pre class="highlighter-hljs" highlighted="true"><code class="language-cpp highlighter-hljs hljs"><span class="hljs-comment">//一个比较抽象的类，相当于目录条目</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Component</span> {
    <span class="hljs-type">int</span> value;
<span class="hljs-keyword">public</span>:
    <span class="hljs-built_in">Component</span>(<span class="hljs-type">int</span> val) :<span class="hljs-built_in">value</span>(val){}
    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(Component*)</span> </span>{}
};
<span class="hljs-comment">//相当于 文件类</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Primitive</span> {
<span class="hljs-keyword">public</span>:
    <span class="hljs-built_in">Primitive</span>(<span class="hljs-type">int</span> val):<span class="hljs-built_in">Component</span>(val){}
};
<span class="hljs-comment">//相当于 文件夹类</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Composite</span> {
    vector&lt;Component*&gt; c;
<span class="hljs-keyword">public</span>:
    <span class="hljs-built_in">Composite</span>(<span class="hljs-type">int</span> val) :<span class="hljs-built_in">Component</span>(val){}

    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(Component* elem)</span> </span>{
        c.<span class="hljs-built_in">push_back</span>(elem);
    }
};
</code></pre>
<h3 id="prototype模式">Prototype模式<button class="cnblogs-toc-button" title="显示目录导航" aria-expanded="false"></button></h3>
<p><strong>设计应用架构时，并不知道以后实现的子类名称，但有要提供给Client调用子类的功能怎么办？</strong></p>
<p>例如十年前设计的架构，子类在十年后继承父类并实现功能。Client只能调用架构中的父类，如何通过父类调用到不知道名字的子类对象。使用Prototype模式：</p>
<pre style="--olcb-folder-code-block-toggler-bg-rgb:245,245,245; --olcb-folder-code-block-toggler-bg:linear-gradient(to bottom, rgba(245,245,245, 0.3) 10%, rgba(245,245,245, 0.8) 30%, rgb(245,245,245)); --olcb-folder-code-block-toggler-fontsize:12px; --olcb-folder-code-block-scroll-height:962px;" class="cnb-over-length-code-block cnb-over-length-code-block-expanded highlighter-hljs" highlighted="true"><code class="language-cpp highlighter-hljs hljs"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;

<span class="hljs-comment">//可能是十年前写的框架，我们不知道子类的名字，但又希望通过该基类来产生子类对象</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Prototype</span> {
    <span class="hljs-comment">//用于保存子类对象的指针（让子类自己上报）</span>
    <span class="hljs-type">static</span> vector&lt;Prototype *&gt; vec;
<span class="hljs-keyword">public</span>:
    <span class="hljs-comment">//纯虚函数clone，让以后继承的子类来实现，也是获取子类对象的关键</span>
    <span class="hljs-function"><span class="hljs-keyword">virtual</span> Prototype* <span class="hljs-title">clone</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;
    <span class="hljs-comment">//子类上报自己模板用的方法</span>
    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">addPrototype</span><span class="hljs-params">(Prototype* se)</span> </span>{
        vec.<span class="hljs-built_in">push_back</span>(se);
    }
    <span class="hljs-comment">//利用该基类在vec中查找子类模板，并且通过模板来克隆更多的子类对象</span>
    <span class="hljs-function"><span class="hljs-type">static</span> Prototype* <span class="hljs-title">findAndClone</span><span class="hljs-params">(<span class="hljs-type">int</span> idx)</span> </span>{
        <span class="hljs-keyword">return</span> vec[idx]-&gt;<span class="hljs-built_in">clone</span>();
    }

    <span class="hljs-comment">//子类实现自己操作的函数，hello()只是个例子</span>
    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">hello</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;
};
<span class="hljs-comment">//定义静态vector，很重要，class定义中只是声明</span>
vector&lt;Prototype *&gt; Prototype::vec;

<span class="hljs-comment">//十年后实现的子类，继承了Prototype</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreatePrototype</span> : <span class="hljs-keyword">public</span> Prototype{
<span class="hljs-keyword">public</span>:
    <span class="hljs-comment">//用于在Prototype.findAndClone()中克隆子类对象用</span>
    <span class="hljs-function">Prototype * <span class="hljs-title">clone</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-comment">//使用另一个构造函数，为了区分创建静态对象的构造函数，添加了一个无用的int参数</span>
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">ConcreatePrototype</span>(<span class="hljs-number">1</span>);
    }

    <span class="hljs-comment">//子类实现的具体操作</span>
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">hello</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>{
        cout &lt;&lt; <span class="hljs-string">"hello"</span> &lt;&lt; endl;
    }

<span class="hljs-keyword">private</span>:
    <span class="hljs-comment">//静态属性，自己创建自己，并上报给父类Prototype</span>
    <span class="hljs-type">static</span> ConcreatePrototype se;
    <span class="hljs-comment">//上报静态属性给父类</span>
    <span class="hljs-built_in">ConcreatePrototype</span>() {
        <span class="hljs-built_in">addPrototype</span>(<span class="hljs-keyword">this</span>);
    }
    <span class="hljs-comment">//clone时用的构造方法，参数a无用，只是用来区分两个构造方法</span>
    <span class="hljs-built_in">ConcreatePrototype</span>(<span class="hljs-type">int</span> a) {}
};
<span class="hljs-comment">//定义静态属性，很重要，有了这句，才会创建静态子类对象se</span>
ConcreatePrototype ConcreatePrototype::se;
</code><div class="cnb-over-length-code-block-toggler cnb-over-length-code-block-toggler-hidden" style=""><span class="cnb-over-length-code-block-toggler-title">折叠 </span><span class="cnb-over-length-code-block-toggler-icon"><svg style="transform: rotateZ(180deg)" viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" width="200" height="200"><path d="M840.4 300H183.6c-19.7 0-30.7 20.8-18.5 35l328.4 380.8c9.4 10.9 27.5 10.9 37 0L858.9 335c12.2-14.2 1.2-35-18.5-35z"></path></svg></span></div></pre>
<p>步骤：</p>
<p>1.子类继承Prototype父类，定义静态属性的时候，自己创建一个自己的对象，此时调用的是无参数的构造函数。并将创建好的自己的指针通过addPrototype(this)上传给基类的vector容器保存。</p>
<p>2.基类定义好的纯虚函数clone()，由子类实现，并在其中通过另一个构造函数产生对象并返回。</p>
<p>3.在Client端，使用基类的findAndClone()，获取vector中的子类对象模板的指针，来调用子类对象的clone功能，返回一个新的子类对象，调用多次则可创建多个对象供用户使用。</p>
<p>4.创建出的子类对象可以调用在子类中实现的hello()方法，进行想要的操作。</p>
<pre class="highlighter-hljs" highlighted="true"><code class="language-cpp highlighter-hljs hljs">Prototype* p = Prototype::<span class="hljs-built_in">findAndClone</span>(<span class="hljs-number">0</span>);
p-&gt;<span class="hljs-built_in">hello</span>();
</code></pre>
<h2 id="附录overload-override-overwrite的区别">附录*、overload override overwrite的区别<button class="cnblogs-toc-button" title="显示目录导航" aria-expanded="false"></button></h2>
<blockquote>
<p>深入请参考C++ primer</p>
</blockquote>
<p><strong>1. Overload（重载）</strong></p>
<p>　在同一作用域中，定义了多个同名不同参数（类型或者个数）函数。特征：</p>
<p><strong>（1）</strong>同一作用域；<br>
<strong>（2）</strong>函数名字相同；<br>
<strong>（3）</strong>参数不同，底层const算重载；<br>
<strong>（4）</strong>virtual 关键字可有可无。</p>
<p><strong>2. Override（覆盖）</strong></p>
<p>用来实现C++多态性的，子类改写父类的virtual函数。</p>
<p><strong>通过<code>override</code>显示声明，</strong>使得程序员的意图更加清晰的同时让编译器可以为我们发现一些错误。</p>
<p><strong>（1）</strong>不同的范围（分别位于派生类与基类）；<br>
<strong>（2）</strong>函数名字相同；<br>
<strong>（3）</strong>参数列表完全相同；<br>
<strong>（4）</strong>基类函数必须有virtual 关键字。</p>
<p><strong>通常情况下，覆盖函数必须与虚函数的参数类型及返回类型相同</strong>：例外是，当类的虚函数返回类型是类本身的<strong>指针或引用</strong>时</p>
<p><strong>3. Overwrite（改写）</strong></p>
<p>基类与派生类之间同名函数重载：派生类重写函数名<strong>屏蔽了基类</strong>中的同名函数。</p>
<blockquote>
<p>解决办法：<strong>在派生类中通过using为父类函数成员提供声明</strong></p>
</blockquote>
<p><strong>（1）</strong>若派生类的函数与基类的函数同名，不同参数。基类的函数将被隐藏。<br>
<strong>（2）</strong>若派生类的函数与基类的函数同名，也同参数，但基类函数无virtual关键字。基类函数被隐藏。</p>
<pre class="highlighter-hljs" highlighted="true"><code class="language-cpp highlighter-hljs hljs"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span> : <span class="hljs-keyword">public</span> Base {
 <span class="hljs-keyword">public</span>:
  <span class="hljs-keyword">using</span> Base::print;<span class="hljs-comment">//解决办法</span>
  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> </span>{
    cout &lt;&lt; <span class="hljs-string">"print() in Derived."</span> &lt;&lt; endl;
  }
};
</code></pre>
<p>【1】大纲是Gayhub上热心网友的，进行了部分补充，非常感谢共享 。</p>
<p>​      因个人水平有限，欢迎大家指导。   yzhu798#gmail.com 。2020.03.07</p>

</div>
<div class="clear"></div>
<div id="blog_post_info_block" role="contentinfo">
<div id="EntryTag">
    标签: 
            <a href="https://www.cnblogs.com/yan1345/tag/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">读书笔记</a></div>

    <div id="blog_post_info">
<div id="green_channel">
        <a href="javascript:void(0);" id="green_channel_digg" onclick="DiggIt(13928915,cb_blogId,1);green_channel_success(this,&#39;谢谢推荐！&#39;);">好文要顶</a>
        <a id="green_channel_follow" onclick="follow(&#39;55462169-872d-e311-8d02-90b11c0b17d6&#39;);" href="javascript:void(0);">关注我</a>
    <a id="green_channel_favorite" onclick="AddToWz(cb_entryId);return false;" href="javascript:void(0);">收藏该文</a>
    <a id="green_channel_weibo" href="javascript:void(0);" title="分享至新浪微博" onclick="ShareToTsina()"><img src="./C++面向对象笔记_上（侯捷老师视频） - yzhu798 - 博客园_files/icon_weibo_24.png" alt=""></a>
    <a id="green_channel_wechat" href="javascript:void(0);" title="分享至微信" onclick="shareOnWechat()"><img src="./C++面向对象笔记_上（侯捷老师视频） - yzhu798 - 博客园_files/wechat.png" alt=""></a>
</div>
<div id="author_profile">
    <div id="author_profile_info" class="author_profile_info">
            <a href="https://home.cnblogs.com/u/yan1345/" target="_blank"><img src="./C++面向对象笔记_上（侯捷老师视频） - yzhu798 - 博客园_files/20200623214926.png" class="author_avatar" alt=""></a>
        <div id="author_profile_detail" class="author_profile_info">
            <a href="https://home.cnblogs.com/u/yan1345/">yzhu798</a><br>
            <a href="https://home.cnblogs.com/u/yan1345/followers/">粉丝 - <span class="follower-count">4</span></a>
            <a href="https://home.cnblogs.com/u/yan1345/followees/">关注 - <span class="following-count">8</span></a><br>
        </div>
    </div>
    <div class="clear"></div>
    <div id="author_profile_honor"></div>
    <div id="author_profile_follow" class="follow-tip">
                <a href="javascript:void(0);" onclick="follow(&#39;55462169-872d-e311-8d02-90b11c0b17d6&#39;);return false;">+加关注</a>
    </div>
</div>
<div id="div_digg">
    <div class="diggit" onclick="votePost(13928915,&#39;Digg&#39;)">
        <span class="diggnum" id="digg_count">0</span>
    </div>
    <div class="buryit" onclick="votePost(13928915,&#39;Bury&#39;)">
        <span class="burynum" id="bury_count">0</span>
    </div>
    <div class="clear"></div>
    <div class="diggword" id="digg_tips">
    </div>
</div>

<script type="text/javascript">
    currentDiggType = 0;
</script></div>
    <div class="clear"></div>
    <div id="post_next_prev">

    <a href="https://www.cnblogs.com/yan1345/p/NoteOfDesignPattern_GOF.html" class="p_n_p_prefix">« </a> 上一篇：    <a href="https://www.cnblogs.com/yan1345/p/NoteOfDesignPattern_GOF.html" data-featured-image="" title="发布于 2020-10-17 19:52">c++设计模式总结</a>
    <br>
    <a href="https://www.cnblogs.com/yan1345/p/DesignDatternsOfCpp.html" class="p_n_p_prefix">» </a> 下一篇：    <a href="https://www.cnblogs.com/yan1345/p/DesignDatternsOfCpp.html" data-featured-image="" title="发布于 2020-11-04 22:01">[转+总结]C++ 常用设计模式</a>

</div>
</div>
            </div>
            <div class="postDesc">posted @ 
<span id="post-date">2020-11-04 21:54</span>&nbsp;
<a href="https://www.cnblogs.com/yan1345/">yzhu798</a>&nbsp;
阅读(<span id="post_view_count">667</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=13928915" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(13928915);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: &#39;&#39;, targetType: &#39;blogPost&#39;, targetId: &#39;13928915&#39;, targetLink: &#39;https://www.cnblogs.com/yan1345/p/13928915.html&#39;, title: &#39;C++面向对象笔记_上（侯捷老师视频）&#39; })">举报</a></div>
        </div>
	    
	    
    </div><!--end: topics 文章、评论容器-->
</div>

<script>
    var cb_entryId = 13928915, cb_entryCreatedDate = '2020-11-04 21:54', cb_postType = 1, cb_postTitle = 'C++面向对象笔记_上（侯捷老师视频）';
    var allowComments = false, cb_blogId = 165136, cb_blogApp = 'yan1345', cb_blogUserGuid = '55462169-872d-e311-8d02-90b11c0b17d6';
    mermaidRender.render()
    markdown_highlight()
    zoomManager.apply("#cnblogs_post_body img:not(.code_img_closed):not(.code_img_opened)");
    updatePostStats(
            [cb_entryId],
            function(id, count) { $("#post_view_count").text(count) },
            function(id, count) { $("#post_comment_count").text(count) })
</script>
<a id="!comments"></a>
<div id="blog-comments-placeholder"></div>
<div id="comment_form" class="commentform">
    <a name="commentform"></a>
    <div id="divCommentShow"></div>
    <div id="comment_nav"><span id="span_refresh_tips"></span><a href="javascript:void(0);" onclick="return RefreshCommentList();" id="lnk_RefreshComments" runat="server" clientidmode="Static">刷新评论</a><a href="https://www.cnblogs.com/yan1345/p/13928915.html#" onclick="return RefreshPage();">刷新页面</a><a href="https://www.cnblogs.com/yan1345/p/13928915.html#top">返回顶部</a></div>
    <div id="comment_form_container" style="visibility: visible;">（评论功能已被禁用）</div>
    <div class="ad_text_commentbox" id="ad_text_under_commentbox"></div>
    <div id="cnblogs_ch"></div>
    <div id="opt_under_post"></div>
    <div id="cnblogs_c1" class="under-post-card" style="display: none;">
            <div id="div-gpt-ad-1592365906576-0" style="width: 300px; height: 250px;"></div>
    </div>
    <div id="under_post_card1"><div class="under-post-card">
<b>编辑推荐：</b>
<br>

· <a href="https://www.cnblogs.com/skychen1218/p/16424567.html" target="_blank">重新理解微服务之终究绕不过这4个坎？(观点探讨)</a>
    <br>
· <a href="https://www.cnblogs.com/wucy/p/16419496.html" target="_blank">由 ASP.NET Core 根据路径下载文件异常引发的探究</a>
    <br>
· <a href="https://www.cnblogs.com/huangxincheng/p/16415242.html" target="_blank">记一次 .NET 某物管后台服务 卡死分析</a>
    <br>
· <a href="https://www.cnblogs.com/InCerry/p/Get-GC-STW-Time.html" target="_blank">如何获取 GC(垃圾回收器)的 STW(暂停)时间?</a>
    <br>
· <a href="https://www.cnblogs.com/eventhorizon/p/16414593.html" target="_blank">从位图到布隆过滤器，C#实现</a>
    <br>
</div></div>
    <div id="under_post_card2"><div class="itnews under-post-card">
    <b>最新新闻</b>：
    <br>
 ·          <a href="https://news.cnblogs.com/n/723844/" target="_blank">主播们最害怕的事，是榜一大哥未成年</a>
        <br>
 ·          <a href="https://news.cnblogs.com/n/723841/" target="_blank">芯片巨头正在偷偷研发这些新AI技术，不比拍照有意思</a>
        <br>
 ·          <a href="https://news.cnblogs.com/n/723845/" target="_blank">沃尔玛否认遭阎罗王攻击</a>
        <br>
 ·          <a href="https://news.cnblogs.com/n/723858/" target="_blank">MIT 建议造巴西大小的“太空气泡”帮地球降温</a>
        <br>
 ·          <a href="https://news.cnblogs.com/n/723857/" target="_blank">腾讯会议应用市场正式上线，首批入驻超20款应用</a>
        <br>
    » <a href="https://news.cnblogs.com/" title="IT 新闻" target="_blank">更多新闻...</a>
</div></div>
    <div id="HistoryToday" class="under-post-card"></div>
    <script type="text/javascript">
        var commentManager = new blogCommentManager();
        commentManager.renderComments(0);
        fixPostBody();

        window.tocManager.displayDisableTocTips = false;
        window.tocManager.generateToc();
    
        setTimeout(function() { countViews(cb_blogId, cb_entryId); }, 50);
    
        deliverT2();
        deliverC1C2();
        loadNewsAndKb();
    
        LoadPostCategoriesTags(cb_blogId, cb_entryId);
    
        LoadPostInfoBlock(cb_blogId, cb_entryId, cb_blogApp, cb_blogUserGuid);
        GetPrevNextPost(cb_entryId, cb_blogId, cb_entryCreatedDate, cb_postType);
        loadOptUnderPost();
        GetHistoryToday(cb_blogId, cb_blogApp, cb_entryCreatedDate);
        
    </script>
</div>

	</div><!--end: forFlow -->
	</div><!--end: mainContent 主体内容容器-->
	<div id="sideBar">
		<div id="sideBarMain">
			<div id="sidebar_news" class="newsItem"><!--done-->
<h3 class="catListTitle">公告</h3>

<div id="blog-news">
    

    <div id="profile_block">
        昵称：
        <a href="https://home.cnblogs.com/u/yan1345/">
            yzhu798
        </a>
        <br>
        园龄：
        <a href="https://home.cnblogs.com/u/yan1345/" title="入园时间：2013-10-05">
            8年8个月
        </a>
        <br>
        粉丝：
        <a class="follower-count" href="https://home.cnblogs.com/u/yan1345/followers/">
            4
        </a>
        <br>
        关注：
        <a class="folowing-count" href="https://home.cnblogs.com/u/yan1345/followees/">
            8
        </a>
        <div id="p_b_follow" class="follow-tip">
<a href="javascript:void(0)" onclick="follow(&#39;55462169-872d-e311-8d02-90b11c0b17d6&#39;)">+加关注</a></div>
        <script>getFollowStatus('55462169-872d-e311-8d02-90b11c0b17d6');</script>
    </div>
</div>

</div>
<div id="sidebar_c3"></div>
			<div id="blog-calendar" style="">

<table id="blogCalendar" class="Cal" cellspacing="0" cellpadding="0" title="Calendar" border="0">
    <tbody>
        <tr>
            <td colspan="7">
                <table class="CalTitle" cellspacing="0" border="0">
                    <tbody>
                        <tr>
                            <td class="CalNextPrev">
                                <a href="javascript:void(0);" onclick="loadBlogCalendar(&#39;2022/06/02&#39;); return false;">&lt;</a>
                            </td>
                            <td align="center">2022年7月</td>
                            <td align="right" class="CalNextPrev">
                                <a href="javascript:void(0);" onclick="loadBlogCalendar(&#39;2022/08/02&#39;); return false;">&gt;</a>
                            </td>
                        </tr>
                    </tbody>
                </table>
            </td>
        </tr>
    <tr>
        <th class="CalDayHeader" align="center" abbr="日" scope="col">日</th>
        <th class="CalDayHeader" align="center" abbr="一" scope="col">一</th>
        <th class="CalDayHeader" align="center" abbr="二" scope="col">二</th>
        <th class="CalDayHeader" align="center" abbr="三" scope="col">三</th>
        <th class="CalDayHeader" align="center" abbr="四" scope="col">四</th>
        <th class="CalDayHeader" align="center" abbr="五" scope="col">五</th>
        <th class="CalDayHeader" align="center" abbr="六" scope="col">六</th>
    </tr>
            <tr>
                            <td class="CalOtherMonthDay" align="center">26</td>
                            <td class="CalOtherMonthDay" align="center">27</td>
                            <td class="CalOtherMonthDay" align="center">28</td>
                            <td class="CalOtherMonthDay" align="center">29</td>
                            <td class="CalOtherMonthDay" align="center">30</td>
                        <td class="" align="center">
                            1
                        </td>
                    <td class="CalTodayDay" align="center">
                        2
                    </td>
            </tr>
                <tr>
                        <td class="CalWeekendDay" align="center">
                            3
                        </td>
                            <td class="" align="center">
                                4
                            </td>
                            <td class="" align="center">
                                5
                            </td>
                            <td class="" align="center">
                                6
                            </td>
                            <td class="" align="center">
                                7
                            </td>
                            <td class="" align="center">
                                8
                            </td>
                        <td class="CalWeekendDay" align="center">
                            9
                        </td>
                </tr>
                <tr>
                        <td class="CalWeekendDay" align="center">
                            10
                        </td>
                            <td class="" align="center">
                                11
                            </td>
                            <td class="" align="center">
                                12
                            </td>
                            <td class="" align="center">
                                13
                            </td>
                            <td class="" align="center">
                                14
                            </td>
                            <td class="" align="center">
                                15
                            </td>
                        <td class="CalWeekendDay" align="center">
                            16
                        </td>
                </tr>
                <tr>
                        <td class="CalWeekendDay" align="center">
                            17
                        </td>
                            <td class="" align="center">
                                18
                            </td>
                            <td class="" align="center">
                                19
                            </td>
                            <td class="" align="center">
                                20
                            </td>
                            <td class="" align="center">
                                21
                            </td>
                            <td class="" align="center">
                                22
                            </td>
                        <td class="CalWeekendDay" align="center">
                            23
                        </td>
                </tr>
                <tr>
                        <td class="CalWeekendDay" align="center">
                            24
                        </td>
                            <td class="" align="center">
                                25
                            </td>
                            <td class="" align="center">
                                26
                            </td>
                            <td class="" align="center">
                                27
                            </td>
                            <td class="" align="center">
                                28
                            </td>
                            <td class="" align="center">
                                29
                            </td>
                        <td class="CalWeekendDay" align="center">
                            30
                        </td>
                </tr>
                <tr>
                        <td class="CalWeekendDay" align="center">
                            31
                        </td>
                            <td class="CalOtherMonthDay" align="center">
                                1
                            </td>
                            <td class="CalOtherMonthDay" align="center">
                                2
                            </td>
                            <td class="CalOtherMonthDay" align="center">
                                3
                            </td>
                            <td class="CalOtherMonthDay" align="center">
                                4
                            </td>
                            <td class="CalOtherMonthDay" align="center">
                                5
                            </td>
                        <td class="CalOtherMonthDay" align="center">
                            6
                        </td>
                </tr>
    </tbody>
</table></div><script>loadBlogDefaultCalendar();</script>			
			<div id="leftcontentcontainer">
				<div id="blog-sidecolumn"><!-- 搜索 -->
<div id="sidebar_search" class="sidebar-block">
    <div id="sidebar_search" class="mySearch">
        <h3 class="catListTitle">搜索</h3>
        <div id="sidebar_search_box">
            <div id="widget_my_zzk" class="div_my_zzk">
                <input type="text" id="q" onkeydown="return zzk_go_enter(event);" class="input_my_zzk">&nbsp;<input onclick="zzk_go()" type="button" value="找找看" id="btnZzk" class="btn_my_zzk">
            </div>
            <div id="widget_my_google" class="div_my_zzk">
                <input type="text" name="google_q" id="google_q" onkeydown="return google_go_enter(event);" class="input_my_zzk">&nbsp;<input onclick="google_go()" type="button" value="谷歌搜索" class="btn_my_zzk">
            </div>
        </div>
    </div>
</div>

<!-- 常用链接 -->
<div id="sidebar_shortcut" class="sidebar-block"><div class="catListLink">
<h3 class="catListTitle">
常用链接
</h3>
<ul>
    <li><a href="https://www.cnblogs.com/yan1345/p/" title="我的博客的随笔列表">我的随笔</a></li>
<li><a href="https://www.cnblogs.com/yan1345/MyComments.html" title="我的发表过的评论列表">我的评论</a></li>
<li><a href="https://www.cnblogs.com/yan1345/OtherPosts.html" title="我评论过的随笔列表">我的参与</a></li>
<li><a href="https://www.cnblogs.com/yan1345/comments" title="我的博客的评论列表">最新评论</a></li>
<li><a href="https://www.cnblogs.com/yan1345/tag/" title="我的博客的标签列表">我的标签</a></li>

</ul>
</div>

</div>

<!-- 最新随笔 -->


<!-- 我的标签 -->
<div id="sidebar_toptags" class="sidebar-block"><div class="catListTag">
<h3 class="catListTitle">我的标签</h3>
<ul>
        <li>
            <a href="https://www.cnblogs.com/yan1345/tag/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">读书笔记<span class="tag-count">(5)</span></a>
        </li>
        <li>
            <a href="https://www.cnblogs.com/yan1345/tag/Effective%E7%B3%BB%E5%88%97/">Effective系列<span class="tag-count">(4)</span></a>
        </li>
        <li>
            <a href="https://www.cnblogs.com/yan1345/tag/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构<span class="tag-count">(2)</span></a>
        </li>
        <li>
            <a href="https://www.cnblogs.com/yan1345/tag/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/">软件工程<span class="tag-count">(2)</span></a>
        </li>
        <li>
            <a href="https://www.cnblogs.com/yan1345/tag/NAS/">NAS<span class="tag-count">(1)</span></a>
        </li>
        <li>
            <a href="https://www.cnblogs.com/yan1345/tag/docker/">docker<span class="tag-count">(1)</span></a>
        </li>
        <li>
            <a href="https://www.cnblogs.com/yan1345/tag/ListView/">ListView<span class="tag-count">(1)</span></a>
        </li>
        <li>
            <a href="https://www.cnblogs.com/yan1345/tag/qml/">qml<span class="tag-count">(1)</span></a>
        </li>
        <li>
            <a href="https://www.cnblogs.com/yan1345/tag/%E5%81%9A%E4%BA%BA%E5%81%9A%E4%BA%8B/">做人做事<span class="tag-count">(1)</span></a>
        </li>
        <li>
            <a href="https://www.cnblogs.com/yan1345/tag/%E7%AE%97%E6%B3%95/">算法<span class="tag-count">(1)</span></a>
        </li>
    <li>
        <a href="https://www.cnblogs.com/yan1345/tag/">更多</a>
    </li>

</ul>
</div>

</div>

<!-- 积分与排名 -->


<!-- 随笔分类、随笔档案、文章分类、新闻分类、相册、链接 -->
<div id="sidebar_categories">

    <div id="sidebar_postcategory" class="catListPostCategory sidebar-block">
        <h3 class="catListTitle">
            
    <a class="sidebar-card-title-a" href="https://www.cnblogs.com/yan1345/categories">随笔分类</a>



        </h3>

        <ul>

                <li data-category-list-item-visible="true" style="display: block">
                    
<a href="https://www.cnblogs.com/yan1345/category/2064696.html" class="category-item-link" rel="" target="">docker(1)</a>
 
                </li>                
            
        </ul>


    </div>    
    <div id="sidebar_postarchive" class="catListPostArchive sidebar-block">
        <h3 class="catListTitle">
            
随笔档案


        </h3>

        <ul>

                <li data-category-list-item-visible="true" style="display: block">
                    
<a href="https://www.cnblogs.com/yan1345/archive/2022/01.html" class="category-item-link" rel="" target="">2022年1月(1)</a>
 
                </li>                
                <li data-category-list-item-visible="true" style="display: block">
                    
<a href="https://www.cnblogs.com/yan1345/archive/2021/12.html" class="category-item-link" rel="" target="">2021年12月(2)</a>
 
                </li>                
                <li data-category-list-item-visible="true" style="display: block">
                    
<a href="https://www.cnblogs.com/yan1345/archive/2021/11.html" class="category-item-link" rel="" target="">2021年11月(1)</a>
 
                </li>                
                <li data-category-list-item-visible="true" style="display: block">
                    
<a href="https://www.cnblogs.com/yan1345/archive/2020/12.html" class="category-item-link" rel="" target="">2020年12月(2)</a>
 
                </li>                
                <li data-category-list-item-visible="true" style="display: block">
                    
<a href="https://www.cnblogs.com/yan1345/archive/2020/11.html" class="category-item-link" rel="" target="">2020年11月(5)</a>
 
                </li>                
                <li data-category-list-item-visible="true" style="display: block">
                    
<a href="https://www.cnblogs.com/yan1345/archive/2020/10.html" class="category-item-link" rel="" target="">2020年10月(1)</a>
 
                </li>                
                <li data-category-list-item-visible="true" style="display: block">
                    
<a href="https://www.cnblogs.com/yan1345/archive/2020/06.html" class="category-item-link" rel="" target="">2020年6月(9)</a>
 
                </li>                
                <li data-category-list-item-visible="true" style="display: block">
                    
<a href="https://www.cnblogs.com/yan1345/archive/2020/05.html" class="category-item-link" rel="" target="">2020年5月(2)</a>
 
                </li>                
                <li data-category-list-item-visible="true" style="display: block">
                    
<a href="https://www.cnblogs.com/yan1345/archive/2020/04.html" class="category-item-link" rel="" target="">2020年4月(2)</a>
 
                </li>                
            
        </ul>


    </div>    
</div>

<!-- 最新评论 -->
<!-- 阅读排行榜 -->
<div id="sidebar_topviewedposts" class="sidebar-block"><div class="catListView">
    <h3 class="catListTitle">
        <a href="https://www.cnblogs.com/yan1345/most-viewed" class="sidebar-card-title-a">
    阅读排行榜
</a>

    </h3>
    <div id="TopViewPostsBlock">
        <ul style="word-break:break-all">
                    <li>
                        <a href="https://www.cnblogs.com/yan1345/p/13928915.html">
                            1. C++面向对象笔记_上（侯捷老师视频）(667)
                        </a>
                    </li>
                    <li>
                        <a href="https://www.cnblogs.com/yan1345/p/13188806.html">
                            2. Markdown用于加粗文章变色(570)
                        </a>
                    </li>
                    <li>
                        <a href="https://www.cnblogs.com/yan1345/p/c_plus_plus_object_oriented_notes_2.html">
                            3. C++面向对象笔记_下（侯捷老师视频）(559)
                        </a>
                    </li>
                    <li>
                        <a href="https://www.cnblogs.com/yan1345/p/Unit_Test_Guidelines.html">
                            4. 单元测试准则(371)
                        </a>
                    </li>
                    <li>
                        <a href="https://www.cnblogs.com/yan1345/p/Install-Google-Test.html">
                            5. 【总结】Install Google Test for c++(334)
                        </a>
                    </li>
            <li>
                
            </li>
        </ul>
    </div>
</div></div>

<!-- 评论排行榜 -->
<div id="sidebar_topcommentedposts" class="sidebar-block"></div>

<!-- 推荐排行榜 -->
<div id="sidebar_topdiggedposts" class="sidebar-block"></div><div id="sidebar_recentcomments" class="sidebar-block"></div>


</div>
                    <script>loadBlogSideColumn();</script>
			</div>			
		</div><!--end: sideBarMain -->
	</div><!--end: sideBar 侧边栏容器 -->
	<div class="clear"></div>
	</div><!--end: main -->
	<div class="clear"></div>
	<div id="footer">
		<!--done-->
Copyright © 2022 yzhu798
<br><span id="poweredby">Powered by .NET 6 on Kubernetes</span>



	</div><!--end: footer -->
</div><!--end: home 自定义的最大容器 -->



<div id="page_end_html">

<link href="./C++面向对象笔记_上（侯捷老师视频） - yzhu798 - 博客园_files/jajian.catalog.css" rel="stylesheet">



</div>

<input type="hidden" id="antiforgery_token" value="CfDJ8EOBBtWq0dNFoDS-ZHPSe522xVRXNM-CsznbP7D9EFHvl_2QDOMPY3HyanKmH0HeHxjct8FoA56TlSRo660scYjsPhX7CJUZunIj52IDOhWp3ISDPig3PRMxDAh9iuK86cy5AtmX-CUILyD5M20qCsQ">
    <script async="" src="./C++面向对象笔记_上（侯捷老师视频） - yzhu798 - 博客园_files/js"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        var kv = getGACustom();
        if (kv) {
            gtag('set', kv);
        }
        gtag('config', 'UA-476124-1');
    </script>
<script defer="" src="https://hm.baidu.com/hm.js?866c9be12d4a814454792b1fd0fed295"></script>

</body></html>